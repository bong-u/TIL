<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Bong-u's TIL</title><link>https://bong-u.github.io/til/algorithm/</link><description>Recent content in Algorithm on Bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://bong-u.github.io/til/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>프로그래머스 - 순위 검색 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%9C%EC%9C%84_%EA%B2%80%EC%83%89/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%9C%EC%9C%84_%EA%B2%80%EC%83%89/</guid><description>1from itertools import combinations 2from collections import defaultdict 3from bisect import bisect_left 4 5def solution(infos, queries): 6 answer = [] 7 dataset = defaultdict(list) 8 9 for info in infos: 10 token = info.split(&amp;#39; &amp;#39;) 11 12 for j in range(5): 13 for case in list(combinations([0,1,2,3], j)): 14 temp = token[:-1] 15 for c in case: 16 temp[c] = &amp;#39;-&amp;#39; 17 dataset[&amp;#39;&amp;#39;.join(temp)].append(int(token[-1])) 18 for value in dataset.values(): 19 value.sort() 20 21 for query in queries: 22 query = query.</description></item><item><title>프로그래머스 - 괄호 회전하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%84%ED%98%B8_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%84%ED%98%B8_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid><description>1def check(string): 2 stack = [] 3 for i in string: 4 if i == &amp;#39;(&amp;#39; or i == &amp;#39;{&amp;#39; or i == &amp;#39;[&amp;#39;: 5 stack.append(i) 6 else: 7 if len(stack) == 0: 8 return False 9 if i == &amp;#39;)&amp;#39;: 10 if stack[-1] != &amp;#39;(&amp;#39;: return False 11 if i == &amp;#39;}&amp;#39;: 12 if stack[-1] != &amp;#39;{&amp;#39;: return False 13 if i == &amp;#39;]&amp;#39;: 14 if stack[-1] != &amp;#39;[&amp;#39;: return False 15 stack.</description></item><item><title>프로그래머스 - 행렬 테두리 회전하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%96%89%EB%A0%AC_%ED%85%8C%EB%91%90%EB%A6%AC_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%96%89%EB%A0%AC_%ED%85%8C%EB%91%90%EB%A6%AC_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid><description>1dx = [1, 0, -1, 0] 2dy = [0, 1, 0, -1] 3 4def solution(rows, columns, queries): 5 table = [[(j*columns)+i+1 for i in range(columns)] for j in range(rows)] 6 answer = [] 7 8 for y1, x1, y2, x2 in queries: 9 min_num = 10000 10 x1 -= 1 11 y1 -= 1 12 x2 -= 1 13 y2 -= 1 14 direction = 0 15 curX, curY = x1, y1 16 postNum = table[y1][x1] 17 while True: 18 curX = curX+dx[direction] 19 curY = curY+dy[direction] 20 21 temp = table[curY][curX] 22 table[curY][curX] = postNum 23 postNum = temp 24 25 min_num = min(min_num ,postNum) 26 27 if ((curX == x2 and curY == y1) or 28 (curX == x2 and curY == y2) or 29 (curX == x1 and curY == y2)): 30 direction += 1 31 32 if curX == x1 and curY == y1: 33 break 34 35 answer.</description></item><item><title>프로그래머스 - 2개 이하로 다른 비트 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_2%EA%B0%9C_%EC%9D%B4%ED%95%98%EB%A1%9C_%EB%8B%A4%EB%A5%B8_%EB%B9%84%ED%8A%B8/</link><pubDate>Wed, 23 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_2%EA%B0%9C_%EC%9D%B4%ED%95%98%EB%A1%9C_%EB%8B%A4%EB%A5%B8_%EB%B9%84%ED%8A%B8/</guid><description>1def solution(numbers): 2 answer = [] 3 for number in numbers: 4 num = list(str(bin(number)).split(&amp;#39;b&amp;#39;)[1]) 5 6 # 첫번째 자릿수가 0인 경우 7 if num[-1] == &amp;#39;0&amp;#39;: 8 num[-1] = &amp;#39;1&amp;#39; 9 answer.append(int(&amp;#39;0b&amp;#39;+&amp;#39;&amp;#39;.join(num), 2)) 10 continue 11 12 # 첫번째 자릿수가 1인 경우 13 num = [&amp;#39;0&amp;#39;]+num 14 # 두번째 자리부터 순회 15 for i in range(len(num)-2, -1, -1): 16 # 가장 오른쪽의 0을 찾았을 때 17 if num[i] == &amp;#39;0&amp;#39;: 18 # 0을 오른쪽으로, 1을 왼쪽으로 옮긴다 19 num[i], num[i+1] = num[i+1], num[i] 20 answer.</description></item><item><title>프로그래머스 - 거리두기 확인하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0_%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0_%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</guid><description>1dx = [-1, 1, 0, 0] 2dy = [0, 0, -1, 1] 3def quest(table): 4 table = [list(line) for line in table] 5 for j in range(5): 6 for i in range(5): 7 if table[i][j] == &amp;#39;P&amp;#39;: 8 flag = [False]*4 9 target = [] 10 for k in range(4): 11 nx = i+dx[k] 12 ny = j+dy[k] 13 if 0 &amp;lt;= nx &amp;lt; 5 and 0 &amp;lt;= ny &amp;lt; 5: 14 target.</description></item><item><title>프로그래머스 - 모음사전 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AA%A8%EC%9D%8C%EC%82%AC%EC%A0%84/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AA%A8%EC%9D%8C%EC%82%AC%EC%A0%84/</guid><description>1def solution(word): 2 answer = 0 3 char = [&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;] 4 cnt = 0 5 6 def traverse(cur): 7 nonlocal char, cnt, word 8 if cur == word: 9 return cnt 10 11 if len(cur) &amp;lt; 5: 12 for ch in char: 13 cnt += 1 14 if traverse(cur+ch) != None: 15 return cnt 16 return traverse(&amp;#39;&amp;#39;) 문제 사전에 A,E,I,O,U만 사용하여 만들 수 있는 길이 5이하의 모든 단어가 수록되어있다 단어 하나 word가 주어질때 사전에서 몇번째 단어인지 구하라 TC input &amp;lsquo;I&amp;rsquo;</description></item><item><title>프로그래머스 - 빛의 경로 사이클 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%B9%9B%EC%9D%98_%EA%B2%BD%EB%A1%9C_%EC%82%AC%EC%9D%B4%ED%81%B4/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%B9%9B%EC%9D%98_%EA%B2%BD%EB%A1%9C_%EC%82%AC%EC%9D%B4%ED%81%B4/</guid><description>1dx = [1, 0, -1, 0] 2dy = [0, 1, 0, -1] 3def solution(grid): 4 N = len(grid) 5 M = len(grid[0]) 6 grid = [list(line) for line in grid] 7 route = [[[False]*4 for _ in range(M)] for _ in range(N)] 8 answer = [] 9 10 for i in range(M): 11 for j in range(N): 12 for k in range(4): 13 cur = [i, j] 14 dir = k 15 cnt = 0 16 while not route[cur[1]][cur[0]][dir]: 17 cnt += 1 18 route[cur[1]][cur[0]][dir] = True 19 cur[0] = (cur[0]+dx[dir]) % M 20 cur[1] = (cur[1]+dy[dir]) % N 21 22 if grid[cur[1]][cur[0]] == &amp;#39;L&amp;#39;: 23 dir = (dir-1) % 4 24 elif grid[cur[1]][cur[0]] == &amp;#39;R&amp;#39;: 25 dir = (dir+1) % 4 26 if cnt !</description></item><item><title>프로그래머스 - 전력망을 둘로 나누기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84_%EB%91%98%EB%A1%9C_%EB%82%98%EB%88%84%EA%B8%B0/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84_%EB%91%98%EB%A1%9C_%EB%82%98%EB%88%84%EA%B8%B0/</guid><description>1def solution(n, wires): 2 tower = [[] for _ in range(n)] 3 answer = 100 4 for wire in wires: 5 wire[0] -= 1 6 wire[1] -= 1 7 tower[wire[0]].append(wire[1]) 8 tower[wire[1]].append(wire[0]) 9 10 def traverse(visited, start): 11 visited[start] = True 12 for i in tower[start]: 13 if not visited[i]: 14 traverse(visited, i) 15 for wire in wires: 16 tower[wire[0]].remove(wire[1]) 17 tower[wire[1]].remove(wire[0]) 18 19 visited = [False]*n 20 a = 0 21 traverse(visited, wire[0]) 22 for i in range(n): 23 if visited[i]: 24 a += 1 25 26 visited = [False]*n 27 b = 0 28 traverse(visited, wire[1]) 29 for i in range(n): 30 if visited[i]: 31 b += 1 32 answer = min(answer, abs(a-b)) 33 tower[wire[0]].</description></item><item><title>프로그래머스 - 교점에 별 만들기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B5%90%EC%A0%90%EC%97%90_%EB%B3%84_%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B5%90%EC%A0%90%EC%97%90_%EB%B3%84_%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>1def calc(a1, b1, c1, a2, b2, c2): 2 if a1*b2-a2*b1 == 0: 3 return (0.1, 0.1) 4 return ((b1*c2-b2*c1)/(a1*b2-a2*b1), (c1*a2-a1*c2)/(a1*b2-a2*b1)) 5 6def solution(line): 7 answer = [] 8 length = len(line) 9 points = [] 10 size = [1e15, -1e15, 1e15,- 1e15] 11 12 for i in range(length): 13 for j in range(i): 14 point = calc(line[i][0],line[i][1], line[i][2], line[j][0], line[j][1], line[j][2]) 15 if point[0]%1 != 0 or point[1]%1 != 0: 16 continue 17 x = int(point[0]) 18 y = int(point[1]) 19 points.</description></item><item><title>프로그래머스 - n^2 배열 자르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_n2_%EB%B0%B0%EC%97%B4_%EC%9E%90%EB%A5%B4%EA%B8%B0/</link><pubDate>Wed, 16 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_n2_%EB%B0%B0%EC%97%B4_%EC%9E%90%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(n, left, right): 2 answer = [] 3 start = (left//n, left%n) 4 end = (right//n, right%n) 5 6 for i in range(start[0], end[0]+1): 7 line = [i+1]*(i+1) + [i for i in range(i+2, n+1)] 8 answer += line 9 10 return answer[start[1]:right-(start[0]*n)+1] 문제 정수 n, left, right가 주어진다 n X n 크기의 2차원 배열을 만든다 i=1,2,3..n에 대해서, 1행 1열부터 i형 i행까지 숫자 i로 채운다 1행, 2행.. n행을 모두 이어붙인 새로운 1차원 배열을 만든다 새로운 1차원 배열에서 left번째 숫자부터 right번째 숫자까지를 배열로 반환하라 TC input n : 3, left : 2, right : 5</description></item><item><title>프로그래머스 - 피로도 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%94%BC%EB%A1%9C%EB%8F%84/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%94%BC%EB%A1%9C%EB%8F%84/</guid><description>1def solution(k, dungeons): 2 result = 0 3 length = len(dungeons) 4 def dfs(cur, visited, cnt): 5 nonlocal result 6 visit = False 7 for i in range(length): 8 if not visited[i] and cur &amp;gt;= dungeons[i][0]: 9 visit = True 10 visited[i] = True 11 dfs(cur-dungeons[i][1], visited, cnt+1) 12 visited[i] = False 13 14 if not visit: 15 result = max(result, cnt) 16 17 dfs(k, [False]*length, 0) 18 19 return result 문제 유저의 현재 피로도 k, 던전별 [&amp;ldquo;최소 필요 피로도&amp;rdquo;, &amp;ldquo;소모 피로도&amp;rdquo;]를 담은 2차원 배열 dungeons가 주어진다 던전을 탐험하기 위해서는 유저의 현재 남은 피로도가 최소 필요 피로도 이상이어야 한다 던전을 클리어하면 &amp;ldquo;소모 피로도&amp;quot;만큼 피로도가 소모된다 던전을 탐험할 수 있는 최대 던전 수를 구하라 TC input k:80, dungeons:[[80,20],[50,40],[30,10]]</description></item><item><title>프로그래머스 - k진수에서 소수 개수 구하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C_%EC%86%8C%EC%88%98_%EA%B0%9C%EC%88%98_%EA%B5%AC%ED%95%98%EA%B8%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C_%EC%86%8C%EC%88%98_%EA%B0%9C%EC%88%98_%EA%B5%AC%ED%95%98%EA%B8%B0/</guid><description>1def convert10toN(n, k): 2 result = &amp;#39;&amp;#39; 3 while n &amp;gt; 1: 4 result = str(n%k)+ result 5 n = n // k 6 return (str(n)+result).lstrip(&amp;#39;0&amp;#39;) 7 8def is_prime(n): 9 if n &amp;lt;= 1: 10 return False 11 12 end = int(n**(1/2))+1 13 for i in range(2, end): 14 if n%i == 0: 15 return False 16 return True 17 18 19def solution(n, k): 20 A = convert10toN(n, k) 21 answer = 0 22 for i in A.</description></item><item><title>프로그래머스 - 주차 요금 계산 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A3%BC%EC%B0%A8_%EC%9A%94%EA%B8%88_%EA%B3%84%EC%82%B0/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A3%BC%EC%B0%A8_%EC%9A%94%EA%B8%88_%EA%B3%84%EC%82%B0/</guid><description>1import math 2 3def diff(start, end): 4 sh, sm = map(int, start.split(&amp;#39;:&amp;#39;)) 5 eh, em = map(int, end.split(&amp;#39;:&amp;#39;)) 6 7 return (eh*60+em) - (sh*60+sm) 8 9def calc(time, baseTime, baseFee, unitTime, unitFee): 10 if time &amp;lt; baseTime: 11 return baseFee 12 time -= baseTime 13 return baseFee + math.ceil(time/unitTime)*unitFee 14 15def solution(fees, records): 16 cars = {} 17 for i in records: 18 time, car_num, _ = i.split(&amp;#39; &amp;#39;) 19 # 새로 입차 한 경우 20 if not car_num in cars: 21 cars[car_num] = [0, time] 22 else: 23 # 출차 후 다시 입차한 경우 24 if cars[car_num][1] == &amp;#39;&amp;#39;: 25 cars[car_num][1] = time 26 # 출차한 경우 27 else: 28 cars[car_num][0] += diff(cars[car_num][1], time) 29 cars[car_num][1] = &amp;#39;&amp;#39; 30 31 # 아직 출차하지 않은 차량들에 대해 23:59에 출차한 것으로 간주 32 for num in cars: 33 if cars[num][1] !</description></item><item><title>프로그래머스 - 양궁대회 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C/</guid><description>1def solution(n, info): 2 # 각각 몇 번 맞춰야 점수를 얻는지 저장하였다 3 goal_list = [i+1 for i in info] 4 5 cases = [] 6 7 def dfs(score, cnt, case): 8 # 몇 번째 점수인지 나타낸다 (0:10점, 1:9점, ...) 9 length = len(case) 10 if length == 11: 11 # 화살 개수가 남았다면 0점에 채워준다 12 if cnt != n: 13 case[-1] += n-cnt 14 cases.append((score, case)) 15 return 16 # 현재 단계에서 몇 점 맞아야 점수를 따는지를 나타낸다 17 goal = goal_list[length] 18 19 # 점수를 따는 경우 20 if cnt + goal &amp;lt;= n: 21 # 딴 점수를 더해준다 22 dfs(score+(10-length), cnt+goal, case+[goal]) 23 # 상대가 점수를 따는 경우 24 if goal !</description></item><item><title>프로그래머스 - 두 큐 합 같게 만들기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%ED%81%90_%ED%95%A9_%EA%B0%99%EA%B2%8C_%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%ED%81%90_%ED%95%A9_%EA%B0%99%EA%B2%8C_%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>1from collections import deque 2 3def solution(queue1, queue2): 4 sum1, sum2 = sum(queue1), sum(queue2) 5 dq1 = deque(queue1) 6 dq2 = deque(queue2) 7 cnt = 0 8 9 while cnt &amp;lt;= len(queue1)*2+1 and sum1 != sum2: 10 if sum1 &amp;gt; sum2: 11 tmp = dq1.popleft() 12 dq2.append(tmp) 13 sum1 -= tmp 14 sum2 += tmp 15 elif sum1 &amp;lt; sum2: 16 tmp = dq2.popleft() 17 dq1.append(tmp) 18 sum1 += tmp 19 sum2 -= tmp 20 cnt += 1 21 22 return cnt if sum1 == sum2 else -1 문제 길이가 같은 두 큐가 주어진다 두 큐의 합이 같아지도록 큐의 원소를 교환할 수 있는 최소 횟수를 구하라 큐의 pop은 왼쪽에서, push는 오른쪽에서 이루어진다 TC input queue1 : [3, 2, 7, 2], queue2 : [4 ,6, 5, 1]</description></item><item><title>프로그래머스 - 할인 행사 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%95%A0%EC%9D%B8_%ED%96%89%EC%82%AC/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%95%A0%EC%9D%B8_%ED%96%89%EC%82%AC/</guid><description>1from collections import deque 2 3def solution(want, number, discount): 4 want_dict = dict() 5 answer = 0 6 7 for i in range(len(want)): 8 want_dict[want[i]] = number[i] 9 10 for i in discount[:10]: 11 if i in want_dict: 12 want_dict[i] -= 1 13 14 for i in range(0, len(discount)-9): 15 if all(map(lambda x: x &amp;lt;= 0, want_dict.values())): 16 answer += 1 17 18 if discount[i] in want_dict: 19 want_dict[discount[i]] += 1 20 if i+10 &amp;lt; len(discount) and discount[i+10] in want_dict: 21 want_dict[discount[i+10]] -= 1 22 23 return answer 문제 XYZ마트에서는 회원에 가입하면 10일동안 할인혜택을 받는다 할인하는 제품은 하루에 하나씩만 구매할 수 있다 정현이가 원하는 제품 리스트, 원하는 제품의 수량 리스트, 마트에서 할인하는 제품 리스트가 주어진다 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원 등록 날짜의 수를 구하라 TC input want: [&amp;ldquo;banana&amp;rdquo;, &amp;ldquo;apple&amp;rdquo;, &amp;ldquo;rice&amp;rdquo;, &amp;ldquo;pork&amp;rdquo;, &amp;ldquo;pot&amp;rdquo;]</description></item><item><title>프로그래머스 - 혼자 놀기의 달인 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90_%EB%86%80%EA%B8%B0%EC%9D%98_%EB%8B%AC%EC%9D%B8/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90_%EB%86%80%EA%B8%B0%EC%9D%98_%EB%8B%AC%EC%9D%B8/</guid><description>1def solution(cards): 2 length = len(cards) 3 visited = [False] * length 4 answer = [] 5 6 for i in range(length): 7 cnt = 0 8 cur = i 9 while not visited[cur-1]: 10 visited[cur-1] = True 11 cur = cards[cur-1] 12 cnt += 1 13 if cnt != 0: 14 answer.append(cnt) 15 16 if len(answer) &amp;lt;= 1: 17 return 0 18 answer.sort(reverse=True) 19 return answer[0]*answer[1] 문제 주어진 배열 cards를 순회한다 cards[i]번째 원소를 방문한다, 이미 방문한 원소인 경우 그만한다 한번 이어서 방문한 원소를 그룹화한다고 할 때, 두 그룹의 원소개수의 곱의 최대값을 구하라 TC input [8,6,3,7,2,5,1,4]</description></item><item><title>프로그래머스 - 연속 수열 합의 개수 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4_%ED%95%A9%EC%9D%98_%EA%B0%9C%EC%88%98/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4_%ED%95%A9%EC%9D%98_%EA%B0%9C%EC%88%98/</guid><description>첫번째 풀이 1def solution(elements): 2 result = set() 3 length = len(elements) 4 elements = elements*2 5 for i in range(length): 6 temp = 0 7 for j in range(length): 8 temp += elements[i+j] 9 result.add(temp) 10 11 return len(result) 개선한 풀이 1def solution(elements): 2result = set() 3length = len(elements) 4for i in range(length): 5 temp = 0 6 for j in range(length): 7 temp += elements[(i+j)%length] 8 result.</description></item><item><title>프로그래머스 - 택배상자 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0%EC%83%81%EC%9E%90/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0%EC%83%81%EC%9E%90/</guid><description>1def solution(order): 2 answer = 0 3 length = len(order) 4 stackA = [i for i in range(length, 0, -1)] 5 stackB = [] 6 7 for i in order: 8 while True: 9 if stackA and stackA[-1] == i: 10 stackA.pop() 11 break 12 if stackB and stackB[-1] == i: 13 stackB.pop() 14 break 15 16 if stackB and stackB[-1] &amp;gt; i: 17 return answer 18 19 stackB.append(stackA.pop()) 20 answer += 1 21 22 return answer 문제 원하는 상자 순서를 나타내는 정수배열 order가 주어진다 컨베이어 벨트에 [N&amp;hellip; 3, 2, 1]와 같이 박스가 놓여있다 박스는 1번 상자부터 순차적으로 뺄 수 있다 뺀 상자를 잠깐 보조 컨베이어 벨트에 보관할 수 있다 보조 컨베이어 벨트는 스택과 같이 FILO가 적용된다 순서대로 상자를 싣지 못하면, 그만둔다 박스를 order에 맞게 몇 개까지 실을 수 있는지 구하라 TC input [4, 3, 1, 2, 5]</description></item><item><title>프로그래머스 - 롤케이크 자르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A1%A4%EC%BC%80%EC%9D%B4%ED%81%AC_%EC%9E%90%EB%A5%B4%EA%B8%B0/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A1%A4%EC%BC%80%EC%9D%B4%ED%81%AC_%EC%9E%90%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(topping): 2 answer = 0 3 length = len(topping) 4 toppingA = [] 5 toppingB = [] 6 setA = set() 7 setB = set() 8 9 for i in range(length-1): 10 setA.add(topping[i]) 11 setB.add(topping[length-i-1]) 12 toppingA.append(len(setA)) 13 toppingB.append(len(setB)) 14 15 toppingB = toppingB[::-1] 16 for i in range(length-1): 17 if toppingA[i] == toppingB[i]: 18 answer+=1 19 return answer 문제 롤케이크 위에 올려진 토핑번호의 정수 배열 topping이 주어진다 롤케이크를 잘랐을 때, 두 조각의 토핑 종류를 똑같이 만드는 방법의 수를 구하라 TC input [1, 2, 1, 3, 1, 4, 1, 2]</description></item><item><title>프로그래머스 - 우박수열 정적분 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%B0%EB%B0%95%EC%88%98%EC%97%B4_%EC%A0%95%EC%A0%81%EB%B6%84/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%B0%EB%B0%95%EC%88%98%EC%97%B4_%EC%A0%95%EC%A0%81%EB%B6%84/</guid><description>1def solution(k, ranges): 2 answer = [] 3 seq = [k] 4 section = [0] 5 while k &amp;gt; 1: 6 if k%2 == 0: 7 k = k//2 8 else: 9 k = k*3+1 10 seq.append(k) 11 12 for i in range(0, len(seq)-1): 13 a, b = seq[i], seq[i+1] 14 if a &amp;gt; b: 15 a, b = b, a 16 17 section.append((b-a)/2+a) 18 if len(section) != 0: 19 section[-1] += section[-2] 20 21 for i in ranges: 22 a, b = i[0], len(seq)+i[1]-1 23 if a &amp;gt; b: 24 answer.</description></item><item><title>프로그래머스 - 숫자 카드 나누기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EC%B9%B4%EB%93%9C_%EB%82%98%EB%88%84%EA%B8%B0/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EC%B9%B4%EB%93%9C_%EB%82%98%EB%88%84%EA%B8%B0/</guid><description>첫번째 통과한 풀이
1import math 2 3def gcd(a, b): 4 while b &amp;gt; 0: 5 a, b = b, a%b 6 return a 7 8def gcdOfArr(l): 9 result = l[0] 10 for i in range(1, len(l)): 11 result = gcd(result, l[i]) 12 return result 13 14def solution(arrayA, arrayB): 15 a1 = gcdOfArr(arrayA) 16 for i in arrayB: 17 if i % a1 == 0: 18 a1 = 0 19 break 20 a2 = gcdOfArr(arrayB) 21 for i in arrayA: 22 if i % a2 == 0: 23 a2 = 0 24 break 25 return max(a1, a2) 개선한 풀이</description></item><item><title>프로그래머스 - 귤 고르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(k, tangerine): 2 D = {} 3 for i in tangerine: 4 if i in D: 5 D[i] += 1 6 else: 7 D[i] = 1 8 D = sorted(D.items(), key=lambda x: -x[1]) 9 answer = 0 10 for _, num in D: 11 k -= num 12 answer += 1 13 if k &amp;lt;= 0: 14 break 15 16 return answer 문제 귤의 개수 k와 귤의 개수를 담은 배열 tangerine이 주어진다 귤 k개를 고를 때, 크기가 서로 다른 종류의 수의 최소값을 구하라 TC input k: 6, tangerine: [1, 3, 2, 5, 4, 5, 2, 3]</description></item><item><title>프로그래머스 - 점 찍기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</guid><description>1import math 2 3def solution(k, d): 4 answer = 0 5 6 for x in range(0, d+1, k): 7 a = math.floor((d**2-x**2)**0.5) // k + 1 8 answer += a 9 10 return answer 문제 2차원 좌표 평면에서 (xk (x=0,1,2,3&amp;hellip;), yk (y=0,1,2,3&amp;hellip;)) 지점에 점을 찍는다 원점과의 거리가 d가 넘으면 점을 찍지 않는다 k와 d가 주어질 때, 점이 총 몇 개 찍히는지 구하라 TC input k:2, d:4
ouput 6</description></item><item><title>프로그래머스 - 디펜스 게임 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</guid><description>1import heapq 2 3def solution(n, k, enemy): 4 heap = [] 5 cnt = 0 6 for i in enemy: 7 n -= i 8 heapq.heappush(heap, -i) 9 while n &amp;lt; 0: 10 k -= 1 11 if not heap or k &amp;lt; 0: 12 return cnt 13 tmp = -heapq.heappop(heap) 14 n += tmp 15 cnt += 1 16 return cnt 문제 n: 가지고 있는 병사 수 k: 사용할 수 있는 무적권 스킬 수 enemy: 라운드마다 존재하는 적 수의 배열 라운드마다 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있다 무적권을 적절히 사용하여 버틸 수 있는 최대 라운드 수를 구하라 TC input n: 7, k: 3, enemy: [4, 2, 4, 5, 3, 3, 1]</description></item><item><title>프로그래머스 - 테이블 해시 함수 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</guid><description>1def solution(data, col, row_begin, row_end): 2 answer = 0 3 data.sort(key=lambda x: (x[col-1], -x[0])) 4 s = [] 5 for i in range(row_begin-1, row_end): 6 s.append(sum(map(lambda x: x%(i+1), data[i]))) 7 8 for i in s: 9 answer ^= i 10 return answer 문제 해시 함수는 col, row_begin, row_end을 입력으로 받는다 테이블의 튜플을 col번째 컬럼의 값을 기준으로 오름차순 정렬을 하되, 만약 그 값이 동일하면 기본키인 첫 번째 컬럼의 값을 기준으로 내림차순 정렬한다 정렬된 데이터에서 S_i를 i 번째 행의 튜플에 대해 각 컬럼의 값을 i 로 나눈 나머지들의 합으로 정의한다 row_begin ≤ i ≤ row_end 인 모든 S_i를 누적하여 bitwise XOR 한 값을 해시 값으로서 반환하라 TC input data: [[2,2,6],[1,5,10],[4,2,9],[3,8,3]]</description></item><item><title>프로그래머스 - 마법의 엘리베이터 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</link><pubDate>Mon, 24 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</guid><description>첫번째 BFS 풀이 1from collections import deque 2 3def solution(storey): 4 answer = 0 5 q = deque() 6 q.append((storey, 0)) 7 visited = [False] * (10**8+1) 8 9 while q: 10 cur, cnt = q.popleft() 11 12 13 visited[cur] = True 14 while cur != 0 and cur%10 == 0: 15 cur = cur // 10 16 if cur == 0: 17 answer = cnt 18 break 19 for j in [-1, 1]: 20 dest = cur + j 21 if 0 &amp;lt;= dest &amp;lt;= 10**8 and not visited[dest]: 22 q.</description></item><item><title>프로그래머스 - 이모티콘 할인행사 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</guid><description>1result = [] 2 3def dfs(size, percent, users, emoticons): 4 global result 5 6 if len(percent) == size: 7 temp = [0] * len(users) 8 for i in range(size): 9 for j in range(len(users)): 10 if percent[i]*100 &amp;gt;= users[j][0]: 11 temp[j] += emoticons[i]*(1-percent[i]) 12 serviceNum = 0 13 income = 0 14 for i in range(len(users)): 15 if temp[i] &amp;gt;= users[i][1]: 16 serviceNum += 1 17 else: 18 income += temp[i] 19 result.</description></item><item><title>프로그래머스 - 택배 배달과 수거하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</guid><description>1def solution(cap, n, deliveries, pickups): 2 answer = 0 3 tempD = 0 4 tempP = 0 5 for i in range(n-1, -1, -1): 6 tempD += deliveries[i] 7 tempP += pickups[i] 8 9 while tempD &amp;gt; 0 or tempP &amp;gt; 0: 10 tempD -= cap 11 tempP -= cap 12 answer += (i+1)*2 13 return answer 문제 트럭에 실을 수 있는 재활용 택배 상자의 최대개수 cap, 배달할 집의 개수 n 택배 상자의 개수를 담은 deliveries, 재활용 택배 상자의 개수를 담은 pickups가 주어진다 트럭하나로 모든 배달과 수거를 마치고 돌아올 수 있는 최소 이동 거리를 구하라 TC input (cap, n, deliveries, pickups) 4, 5, [1, 0, 3, 1, 2], [0, 3, 0, 4, 0]</description></item><item><title>프로그래머스 - 시소 짝꿍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</guid><description>1def solution(weights): 2 answer = 0 3 wdict = {} 4 5 weights.sort(reverse=True) 6 for i in weights: 7 if i in wdict: 8 answer += wdict[i] 9 if i*3/2 in wdict: 10 answer += wdict[i*3/2] 11 if i*2 in wdict: 12 answer += wdict[i*2] 13 if i*4/3 in wdict: 14 answer += wdict[i*4/3] 15 16 wdict[i] = wdict[i]+1 if i in wdict else 1 17 return answer 문제 시소에는 중심으로부터 2m, 3m, 4m 떨어진 거리에 좌석이 존재한다 양쪽의 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 같아서 시소가 평행을 이룬다면 그 둘을 시소 짝꿍이라고 할 수 있다 사람들의 몸무게 배열이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하라 TC input [100,180,360,100,270]</description></item><item><title>프로그래머스 - 숫자 변환하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</guid><description>1from collections import deque 2 3def solution(x, y, n): 4 q = deque() 5 visited = [False] * 1000001 6 q.append((x, 0)) 7 8 while q: 9 cx, cnt = q.popleft() 10 if cx == y: 11 return cnt 12 13 if cx + n &amp;lt;= y and not visited[cx+n]: 14 q.append((cx+n, cnt+1)) 15 visited[cx+n] = True 16 if cx * 2 &amp;lt;= y and not visited[cx*2]: 17 q.append((cx*2, cnt+1)) 18 visited[cx*2] = True 19 if cx * 3 &amp;lt;= y and not visited[cx*3]: 20 q.</description></item><item><title>프로그래머스 - 뒤에 있는 큰 수 찾기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</link><pubDate>Tue, 18 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</guid><description>1def solution(numbers): 2 stack = [] 3 answer = [-1] * len(numbers) 4 5 for i in range(len(numbers)): 6 while stack and stack[-1][1] &amp;lt; numbers[i]: 7 answer[stack[-1][0]] = numbers[i] 8 stack.pop() 9 stack.append((i, numbers[i])) 10 print(stack) 11 12 return answer 문제 정수로 이루어진 배열 numbers가 주어진다 자신 보다 뒤에 있는 숫자 중 가장 크면서 가까운 수를 뒷 큰수라고 한다 모든 원소에 대해서 뒷 큰수를 구하여라 (존재하지 않으면 -1) TC input [2, 3, 3, 5]</description></item><item><title>프로그래머스 - 무인도 여행 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</guid><description>1from collections import deque 2 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def solution(maps): 7 N = len(maps) 8 M = len(maps[0]) 9 answer = [] 10 11 visited = [[False]*M for _ in range(N)] 12 13 for i in range(N): 14 for j in range(M): 15 if maps[i][j] != &amp;#39;X&amp;#39; and not visited[i][j]: 16 cnt = 0 17 q = deque() 18 q.append((j, i)) 19 visited[i][j] = True 20 while q: 21 cx, cy = q.</description></item><item><title>프로그래머스 - 호텔 대실 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</guid><description>1import heapq 2 3def time_calc(time): 4 time_split = time.split(&amp;#39;:&amp;#39;) 5 return int(time_split[0])*60 + int(time_split[1]) 6 7def solution(book_time): 8 time = [] 9 q = [] 10 for start, end in book_time: 11 time.append((time_calc(start), time_calc(end))) 12 time.sort(key=lambda x: x[0]) 13 print (time) 14 for start, end in time: 15 if q: 16 top = heapq.heappop(q) 17 if top &amp;gt; start: 18 heapq.heappush(q, top) 19 heapq.heappush(q, end+10) 20 else: 21 heapq.heappush(q, end+10) 22 return len(q) 문제 호텔의 예약시간이 담긴 2차원 배열이 주어진다 ex) [[&amp;ldquo;12:00&amp;rdquo;, &amp;ldquo;12:30&amp;rdquo;], [&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;16:00&amp;rdquo;]] 퇴실 시간 10분 이후에 다음 손님이 입실 할 수 있다 최소 객실의 개수를 구하여라 TC input [[&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;17:00&amp;rdquo;], [&amp;ldquo;16:40&amp;rdquo;, &amp;ldquo;18:20&amp;rdquo;], [&amp;ldquo;14:20&amp;rdquo;, &amp;ldquo;15:20&amp;rdquo;], [&amp;ldquo;14:10&amp;rdquo;, &amp;ldquo;19:20&amp;rdquo;], [&amp;ldquo;18:20&amp;rdquo;, &amp;ldquo;21:20&amp;rdquo;]]</description></item><item><title>프로그래머스 - 미로 탈출 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</link><pubDate>Fri, 14 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</guid><description>1from collections import deque 2 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def bfs(maps, N, M, p1, p2): 7 visited = [[False]*M for _ in range(N)] 8 q = deque() 9 q.append(list(p1)+[0]) 10 11 while q: 12 curY, curX, cnt = q.popleft() 13 14 if p2 == (curY, curX): 15 return cnt 16 17 for i in range(4): 18 x = curX + vx[i] 19 y = curY + vy[i] 20 if 0 &amp;lt;= x &amp;lt; M and 0 &amp;lt;= y &amp;lt; N and not visited[y][x] and maps[y][x] !</description></item><item><title>프로그래머스 - 혼자서 하는 틱택토 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</guid><description>1V = [[(-1, 0), (1, 0)], [(0, -1), (0, 1)], [(-1, -1), (1, 1)], [(-1, 1), (1, -1)]] 2P = [[(1, 0), (1, 1), (1, 2)], [(0, 1), (1, 1), (2, 1)], [(1, 1)], [(1, 1)]] 3 4def solution(board): 5 answer = -1 6 o_line = 0 7 x_line = 0 8 9 for i, p_list in enumerate(P): 10 for p in p_list: 11 if board[p[0]][p[1]] != &amp;#39;.&amp;#39; and board[p[0]][p[1]]== board[p[0]+V[i][0][0]][p[1]+V[i][0][1]] == board[p[0]+V[i][1][0]][p[1]+V[i][1][1]]: 12 if board[p[0]][p[1]] == &amp;#39;O&amp;#39;: 13 o_line += 1 14 elif board[p[0]][p[1]] == &amp;#39;X&amp;#39;: 15 x_line += 1 16 17 o_cnt = 0 18 x_cnt = 0 19 20 21 for i in &amp;#39;&amp;#39;.</description></item><item><title>프로그래머스 - 당구 연습 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</guid><description>1def solution(m, n, startX, startY, balls): 2 answer = [] 3 for bx, by in balls: 4 tmp = [] 5 for x, y in [(-1*startX, startY), (startX, -1*startY), (startX, 2*n-startY), (2*m-startX, startY)]: 6 if bx==x and (y &amp;lt; 0 &amp;lt; by &amp;lt; startY or startY &amp;lt; by &amp;lt; n &amp;lt; y): 7 continue 8 if by==y and (x &amp;lt; 0 &amp;lt; bx &amp;lt; startX or startX &amp;lt; bx &amp;lt; m &amp;lt; x): 9 continue 10 tmp.</description></item><item><title>프로그래머스 - 리코쳇 로봇 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</guid><description>1from collections import deque 2visited = [] 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def bfs(board, N, M, sp): 7 global visited 8 q = deque() 9 q.append(sp+[1]) 10 11 while q: 12 cy, cx, cnt = q.popleft() 13 visited[cy][cx] = True 14 for i in range(4): 15 x = cx 16 y = cy 17 while True: 18 x += vx[i] 19 y += vy[i] 20 if not (0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; M) or board[y][x] == &amp;#39;D&amp;#39;: 21 x -= vx[i] 22 y -= vy[i] 23 break 24 if board[y][x] == &amp;#39;G&amp;#39;: 25 return cnt 26 if not visited[y][x]: 27 q.</description></item><item><title>프로그래머스 - 광물 캐기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</guid><description>1def solution(picks, minerals): 2 bundles = [] 3 tmp = [0, 0, 0] 4 DATA = [[1, 1, 1], [5, 1, 1], [25, 5, 1]] 5 answer = 0 6 7 for i in range(len(minerals)): 8 if minerals[i] == &amp;#34;diamond&amp;#34;: 9 for j in range(3): 10 tmp[j] += DATA[j][0] 11 elif minerals[i] == &amp;#34;iron&amp;#34;: 12 for j in range(3): 13 tmp[j] += DATA[j][1] 14 elif minerals[i] == &amp;#34;stone&amp;#34;: 15 for j in range(3): 16 tmp[j] += DATA[j][2] 17 18 if (i+1) % 5 == 0 or i == len(minerals)-1: 19 bundles.</description></item><item><title>프로그래머스 - 과제 진행하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</guid><description>내 답안 1def solution(plans): 2 q = [] 3 answer = [] 4 for plan in plans: 5 h, m = map(int, plan[1].split(&amp;#39;:&amp;#39;)) 6 plan[1] = h*60 + m 7 plan[2] = int(plan[2]) 8 plans.sort(key = lambda x: x[1]) 9 10 for plan in plans: 11 if q: 12 free_time = plan[1] - q[-1][1] 13 while q: 14 q[-1][2] -= free_time 15 free_time = -1 * q[-1][2] 16 17 print (free_time, q[-1][2]) 18 if free_time &amp;lt; 0: 19 break 20 21 if q[-1][2] &amp;lt;= 0: 22 answer.</description></item><item><title>프로그래머스 - 연속된 부분 수열의 합 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</guid><description>1def solution(sequence, k): 2 answer = [] 3 e = len(sequence)-1 4 s = len(sequence) 5 cur = 0 6 7 while s &amp;gt;= 0: 8 if cur &amp;lt; k: 9 s -= 1 10 cur += sequence[s] 11 elif cur &amp;gt; k: 12 cur -= sequence[e] 13 e -= 1 14 else: 15 answer.append((s, e)) 16 s -= 1 17 cur += sequence[s] 18 answer.sort(key=lambda x: (x[1]-x[0], x[0])) 19 return answer[0] 문제 수열과 k가 주어진다 수열의 부분합이 k가 되게 하는 시작인덱스와 끝인덱스를 구하라 이때, 길이가 짧은 수열을 찾는다, 길이가 같은것이 여러가지라면 시작인덱스가 작은 것을 찾는다 TC input [1, 2, 3, 4, 5], 7</description></item><item><title>프로그래머스 - 두 원 사이의 정수 쌍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</guid><description>1import math 2 3def calc1(r): 4 result = 0 5 for i in range(1, r): 6 result += math.floor(math.sqrt(r**2 - i**2)) 7 return result*4 + r*4 + 1 8 9def calc2(r): 10 result = 0 11 for i in range(1, r): 12 a = math.sqrt(r**2 - i**2) 13 result += math.floor(a) 14 if a % 1 == 0: 15 result -= 1 16 return result*4 + r*4 + 1 17 18def solution(r1, r2): 19 return calc1(r2)-calc2(r1)+4 문제 두 원의 반지름 r1, r2가 주어진다.</description></item><item><title>프로그래머스 - 요격 시스템 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</guid><description>1def solution(targets): 2 answer = 0 3 targets.sort(key=lambda x:x[1]) 4 cur = 0 5 6 for i in targets: 7 if i[0] &amp;gt;= cur: 8 answer += 1 9 cur = i[1] 10 11 return answer 문제 개구간 (s, e)의 리스트가 주어진다. 이때, 모든 개구간을 포함하는 최소 숫자의 수를 구하여라 TC input [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]]
ouput 3
해결방법 개구간을 (s, e)에서 e를 정렬하여 해결하였다.</description></item><item><title>11000 : 강의실 배정 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_11000/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11000/</guid><description>1import heapq 2 3N = int(input()) 4 5L = [] 6for _ in range(N): 7 L.append(tuple(map(int, input().split()))) 8 9L.sort() 10q = [] 11 12heapq.heappush(q, L[0][1]) 13for i in L[1:]: 14 if q[0] &amp;gt; i[0]: 15 heapq.heappush(q, i[1]) 16 else: 17 heapq.heappop(q) 18 heapq.heappush(q, i[1]) 19 20print (len(q)) 문제 강의 개수와 강의 당 시작시간, 종료시간이 주어진다 필요한 강의실 개수를 구하라 (연강 가능)) TC
input 3 1 3 2 4 3 5</description></item><item><title>2638 : 치즈 (G3)</title><link>https://bong-u.github.io/til/algorithm/boj_2638/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2638/</guid><description>1from collections import deque 2 3dx = [0, 0, -1, 1] 4dy = [-1, 1, 0, 0] 5 6N, M = map(int, input().split()) 7L = [list(map(int, input().split())) for _ in range(N)] 8 9def check(): 10 q = deque() 11 q.append((0, 0)) 12 13 visited = [[0]*M for _ in range(N)] 14 visited[0][0] = 1 15 16 while q: 17 curX, curY = q.popleft() 18 19 for i in range(4): 20 nX = curX + dx[i] 21 nY = curY + dy[i] 22 23 if 0 &amp;lt;= nX &amp;lt; N and 0 &amp;lt;= nY &amp;lt; M: 24 if L[nX][nY] == 0 and visited[nX][nY] == 0: 25 q.</description></item><item><title>11444 : 피보나치 수 6 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_11444/</link><pubDate>Tue, 09 May 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11444/</guid><description>1def multiply(m1, m2): 2 result = [0, 0, 0, 0] 3 result[0] = (m1[0]*m2[0] + m1[1]*m2[2]) % 1000000007 4 result[1] = (m1[0]*m2[1] + m1[1]*m2[3]) % 1000000007 5 result[2] = (m1[2]*m2[0] + m1[3]*m2[2]) % 1000000007 6 result[3] = (m1[2]*m2[1] + m1[3]*m2[3]) % 1000000007 7 return result 8 9def power(m, n): 10 if (n &amp;gt; 1): 11 m = power (m, n//2) 12 13 m = multiply (m, m) 14 if n % 2 == 1: 15 m = multiply(m, [1,1,1,0]) 16 return m 17 18N = int(input()) 19 20mat = power ([1,1,1,0], N) 21print (mat[1]%1000000007) 문제 n이 주어질 때 n번째 피보나치 수를 구하여라.</description></item><item><title>1976 : 여행 가자 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1976/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1976/</guid><description>1N = int(input()) 2M = int(input()) 3 4parent = [i for i in range(N)] 5 6def find(node): 7 if parent[node] != node: 8 parent[node] = find(parent[node]) 9 return parent[node] 10 11def union(a, b): 12 a = find(a) 13 b = find(b) 14 if a &amp;lt; b: 15 parent[b] = a 16 else: 17 parent[a] = b 18 19for i in range(N): 20 for j, item in enumerate(map(int, input().split())): 21 if item: 22 union(i, j) 23 24path = list(map(int, input().</description></item><item><title>11003 : 최솟값 찾기 (P5)</title><link>https://bong-u.github.io/til/algorithm/boj_11003/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11003/</guid><description>1from collections import deque 2N, L = map(int, input().split()) 3A = list(map(int, input().split())) 4 5Q = deque([(A[0], 0)]) 6result = [A[0]] 7 8for i in range(1, N): 9if Q[0][1] == i-L: 10Q.popleft() 11while Q and Q[-1][0] &amp;gt;= A[i]: 12Q.pop() 13Q.append((A[i], i)) 14result.append(Q[0][0]) 15 16print(*result) 문제 N개의 수 A1, A2, &amp;hellip;, AN 과 L이 주어진다. Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. TC input 12 3</description></item><item><title>17144 : 미세먼지 안녕! (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17144/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17144/</guid><description>1R, C, T = map(int, input().split()) 2L = [list(map(int, input().split())) for _ in range(R)] 3 4dx = [0, 1, 0, -1] 5dy = [-1, 0, 1, 0] 6dx2 = [0, 1, 0, -1] 7dy2 = [1, 0, -1, 0] 8 9pur_a = (0, 0) 10pur_b = (0, 0) 11 12for i in range(R): 13 if L[i][0] == -1: 14 pur_a = (i, 0) 15 pur_b = (i+1, 0) 16 break 17 18def diffuse(L): 19 L_ = [[0]*C for _ in range(R)] 20 21 for i in range(R): 22 for j in range(C): 23 if L[i][j] &amp;gt; 0: 24 cnt = 0 25 for k in range(4): 26 px = j+dx[k] 27 py = i+dy[k] 28 29 if 0 &amp;lt;= px &amp;lt; C and 0 &amp;lt;= py &amp;lt; R and L[py][px] !</description></item><item><title>12851 : 숨바꼭질 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_12851/</link><pubDate>Tue, 07 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12851/</guid><description>1from collections import deque 2 3position_a, position_b = map(int, input().split()) 4 5q = deque() 6visited = [False]*100001 7result = 0 8cnt = 1 9 10q.append((0, position_a)) 11while q: 12 time, cur = q.popleft(); 13 visited[cur] = True 14 15 if cur == position_b: 16 result = time 17 for i in q: 18 if i == (time, cur): 19 cnt += 1 20 break 21 if cur-1 &amp;gt;= 0 and not visited[cur-1]: 22 q.</description></item><item><title>2448 : 별 찍기 - 11 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2448/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2448/</guid><description>1import math 2 3N = int(input()) 4K = int(math.log2(N//3)) 5arr = [[&amp;#39; &amp;#39;] * (2*N-1) for _ in range(N)] 6 7 8def solve(depth, bx, by): 9 if depth == 0: 10 for i in range(3): 11 for j in range(i*2+1): 12 arr[by+i][bx+(2-i)+j] = &amp;#39;*&amp;#39; 13 arr[by+1][bx+2] = &amp;#39; &amp;#39; 14 else: 15 px = 2**(depth)*3 16 py = 2**(depth-1)*3 17 solve(depth-1, bx+px//2, by) 18 solve(depth-1, bx, by+py) 19 solve(depth-1, bx+px, by+py) 20solve(K, 0, 0) 21for i in arr: 22 print (&amp;#39;&amp;#39;.</description></item><item><title>1043 : 거짓말 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1043/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1043/</guid><description>1N, M = map(int, input().split()) 2T = list(map(int, input().split())) 3T = set(T[1:]) 4 5member = [set() for _ in range(N)] 6party = [] 7visit = [False]*M 8 9def explore(n): 10 for i in member[n]: 11 if not visit[i]: 12 visit[i] = True 13 for j in party[i]: 14 explore(j-1) 15 16for i in range(M): 17 lst = list(map(int, input().split())) 18 lst = lst[1:] 19 for j in lst: 20 member[j-1].add(i) 21 party.</description></item><item><title>5639 : 이진 검색 트리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5639/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5639/</guid><description>풀이방법 1 : 직접 구현 1import sys 2 3sys.setrecursionlimit(10**6) 4class Node: 5 def __init__(self, value): 6 self.value = value 7 self.left = None 8 self.right = None 9 10class BinaryTree: 11 def __init__(self, root): 12 self.root = root 13 14 def insert(self, value): 15 cur_node = self.root 16 while True: 17 if value &amp;lt; cur_node.value: 18 if cur_node.left != None: 19 cur_node = cur_node.left 20 else: 21 cur_node.left = Node(value) 22 break 23 else: 24 if cur_node.</description></item><item><title>14938 : 서강그라운드 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_14938/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14938/</guid><description>1N, M, R = map(int, input().split()) 2 3item = list(map(int, input().split())) 4G = [[] for _ in range(N)] 5for _ in range(R): 6 a, b, c = map(int, input().split()) 7 G[a-1].append((b-1, c)) 8 G[b-1].append((a-1, c)) 9 10def dfs(node, dist): 11 global result 12 if dist &amp;gt; M: 13 return 14 if not visit[node]: 15 result += item[node] 16 visit[node] = True 17 18 for n_node, n_dist in G[node]: 19 dfs(n_node, dist+n_dist) 20 21max_result = 0 22 23for i in range(N): 24 result = 0 25 visit = [False]*N 26 dfs(i, 0) 27 max_result = max(max_result, result) 28 29print (max_result) 분류에 다익스트라, 플로이드-워셜로 되어있지만 DFS로 풀었다 풀이 방법 여기서는 재방문 했다고 해서 탐색을 하지 않으면 안된다 재방문했을때 전에 방문했을 때보다 더 짧은 통로로 들어왔다면 더 많은 아이템을 얻을 수 있기 때문이다 다만, 아이템은 방문할 때마다 얻을 수 있는 것이 아니기 때문에 주의하여야 한다 위의 내용을 질문게시판을 보다가 깨닫고 풀 수 있었다</description></item><item><title>1167 : 트리의 지름 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1167/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1167/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3input = sys.stdin.readline 4 5V = int(input()) 6G = [[] for _ in range(V)] 7for _ in range(V): 8 token = list(map(int, input().split()))[:-1] 9 for i in range(1, len(token), 2): 10 G[token[0]-1].append((token[i]-1, token[i+1])) 11 12def dfs(node, dist): 13 global max_node, max_dist 14 visited[node] = True 15 if dist &amp;gt; max_dist: 16 max_node = node 17 max_dist = dist 18 for n_node, n_dist in G[node]: 19 if not visited[n_node]: 20 dfs(n_node, dist+n_dist) 21 22max_node = 0 23 24max_dist = 0 25visited = [False]*V 26dfs(0, 0) 27max_dist = 0 28visited = [False]*V 29dfs(max_node, 0) 30 31print (max_dist) 최근에 푼 &amp;ldquo;1967: 트리의 지름&amp;rdquo; 덕분에 쉽게 해결할 수 있었다 기억하자 트리의 지름 = (어떤 한 정점에서 가장 먼 점 P)에서 가장 먼 점 사이의 거리</description></item><item><title>1967 : 트리의 지름(G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1967/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1967/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3M = int(input()) 4G = [[] for _ in range(M)] 5 6for _ in range(M-1): 7 a, b, c = map(int, input().split()) 8 G[a-1].append((b-1, c)) 9 G[b-1].append((a-1, c)) 10 11n1 = 0 12tmp = 0 13 14def dfs(node, length): 15 global n1, tmp 16 visit[node] = True 17 if length &amp;gt; tmp: 18 tmp = length 19 n1 = node 20 for child, v in G[node]: 21 if not visit[child]: 22 dfs(child, length+v) 23 24visit = [False]*M 25dfs(0, 0) 26tmp = 0 27visit = [False]*M 28dfs(n1, 0) 29print (tmp) 인터넷에서 접근 방법을 참고했다 해결 방법 아무 정점에서 가장 먼 어떤 정점을 N이라고 하자 정점 N에서 가장 먼 정점 사이의 거리가 트리의 지름과 같다 느낀 점 루트를 구할 필요가 없다는 것을 깨달았다</description></item><item><title>15681 : 트리와 쿼리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15681/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15681/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3input = sys.stdin.readline 4N, R, Q = map(int, input().split()) 5G = [[] for _ in range(N)] 6cnt = [1]*N 7visited = [False]*N 8 9for _ in range(N-1): 10 a, b = map(int, input().split()) 11 G[a-1].append(b-1) 12 G[b-1].append(a-1) 13 14def dfs(node): 15 visited[node] = True 16 17 for i in G[node]: 18 if not visited[i]: 19 cnt[node] += dfs(i) 20 return cnt[node] 21 22dfs(R-1) 23 24for _ in range(Q): 25 print (cnt[int(input())-1]) 혼자 풀었다!</description></item><item><title>2502 : 떡 먹는 호랑이 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_2502/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2502/</guid><description>1D, K = map(int, input().split()) 2L = [(1, 0), (0, 1)] 3 4for i in range(2, D): 5 L.append((L[i-2][0]+L[i-1][0], L[i-2][1]+L[i-1][1])) 6 7A = 1 8B = 2 9 10while True: 11 if A*L[D-1][0] + B*L[D-1][1] == K: 12 break 13 14 if A+1 == B: 15 B += 1 16 A = 1 17 else: 18 A += 1 19 20print (A,&amp;#39;\n&amp;#39;,B, sep=&amp;#39;&amp;#39;) 해결방법 N번째날 떡 개수를 구하기 위해 첫째날 떡, 둘째날 떡을 각각 몇번 더해야하는지 리스트에 구한다 첫째, 둘째 날 떡을 하나하나 넣어보면서 브루트 포스를 수행한다</description></item><item><title>13398 : 연속합 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_13398/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_13398/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3res = 0 4dp = [[-1000]*N for _ in range(2)] 5dp[0][0] = L[0] 6for i in range(1, N): 7 dp[0][i] = max(dp[0][i-1]+L[i], L[i]) 8 dp[1][i] = max(dp[1][i-1]+L[i], dp[0][i-1]) 9 10print (max(max(dp[0]), max(dp[1]))) 이번 문제에서 사용할 dp 배열의 크기는 N X 2 이다. 배열은 최솟값인 -1000으로 초기화하여야 한다</description></item><item><title>15486 : 퇴사 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15486/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15486/</guid><description>1import sys 2input = sys.stdin.readline 3N = int(input()) 4T = [] 5P = [] 6dp = [0]*(N+1) 7 8for _ in range(N): 9 a, b = map(int, input().split()) 10 T.append(a) 11 P.append(b) 12 13for i in range(N-1, -1, -1): 14 if i+T[i] &amp;gt; N: 15 dp[i] = dp[i+1] 16 else: 17 dp[i] = max(P[i]+dp[i+T[i]], dp[i+1]) 18 19print (dp[0]) dp라는 변수를 만들어야하는데 안 만들고 리스트 P만 가지고 memoization 하려다 실패했다 점화식은 잘 적었으나 조건문이 잘 못되어서 다른 풀이를 참고했다</description></item><item><title>2631 : 줄세우기 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2631/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2631/</guid><description>1N = int(input()) 2L = [] 3for i in range(N): 4 L.append(int(input())) 5 6dp = [1]*N 7 8for i in range(N): 9 for j in range(i): 10 if L[j] &amp;lt; L[i]: 11 dp[i] = max(dp[i], dp[j]+1) 12 13print (N-max(dp)) LIS를 활용한 문제이다 풀이 유도는 잘했으나 LIS가 헷갈려서 전에 풀었던 코드를 참고하였다</description></item><item><title>1915 : 가장 큰 정사각형 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1915/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1915/</guid><description>1N, M = map(int, input().split()) 2 3L = [list(map(int, input())) for _ in range(N)] 4 5dp = [[0]*(M+1) for _ in range(N+1)] 6 7result = 0 8 9for i in range(1, N+1): 10 for j in range(1, M+1): 11 dp[i][j] = L[i-1][j-1] 12 13 if L[i-1][j-1]: 14 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 15 result = max(result, dp[i][j]) 16 17for i in dp: 18 print (i) 19print (result**2) 조금 시간이 걸렸지만 혼자 힘으로 풀었다 점화식은 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1이다.</description></item><item><title>1918 : 후위 표기식 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1918/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1918/</guid><description>1string = list(input()) 2 3priority = {&amp;#39;(&amp;#39;:0, &amp;#39;)&amp;#39;:0, &amp;#39;+&amp;#39;:1, &amp;#39;-&amp;#39;:1, &amp;#39;*&amp;#39;:2, &amp;#39;/&amp;#39;:2} 4operator = [] 5result = &amp;#39;&amp;#39; 6 7for c in string: 8 if c.isalpha(): 9 result += c 10 elif c == &amp;#39;(&amp;#39;: 11 operator.append(c) 12 elif c == &amp;#39;)&amp;#39;: 13 while operator: 14 op = operator.pop() 15 if op == &amp;#39;(&amp;#39;: 16 break 17 result += op 18 else: 19 if operator: 20 if priority[operator[-1]] &amp;lt; priority[c]: 21 operator.</description></item><item><title>9252 : LCS 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_9252/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9252/</guid><description>1S1 = list(input()) 2S2 = list(input()) 3 4N1 = len(S1)+1 5N2 = len(S2)+1 6 7dp = [[0]*(N1) for _ in range(N2)] 8 9for i in range(1, N2): 10 for j in range(1, N1): 11 if S2[i-1] == S1[j-1]: 12 dp[i][j] = dp[i-1][j-1] + 1 13 else: 14 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 15i = N2-1 16j = N1-1 17print (dp[i][j]) 18if dp[i][j] == 0: 19 exit() 20 21result = &amp;#39;&amp;#39; 22while True: 23 if i==0 or j==0: 24 break 25 26 if dp[i][j] == dp[i-1][j]: 27 i -= 1 28 elif dp[i][j] == dp[i][j-1]: 29 j -= 1 30 else: 31 result = S1[j-1] + result 32 i -= 1 33 j -= 1 34 35print (result) 점화식을 잘못 세웠었다 문자가 같은 경우에 max(dp[i-1][j], dp[i][j-1])+1이 아닌 dp[i-1][j-1]+1이다.</description></item><item><title>10942 : 팰린드롬? (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_10942/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10942/</guid><description>1import sys 2input = sys.stdin.readline 3 4N = int(input()) 5L = list(map(int, input().split())) 6 7dp = [[0]*N for _ in range(N)] 8 9for i in range(N): 10 dp[i][i] = 1 11 if i &amp;lt; N-1 and L[i] == L[i+1]: 12 dp[i][i+1] = 1 13 14for i in range(N, -1, -1): 15 for j in range(i+1, N): 16 if dp[i+1][j-1] and L[i] == L[j]: 17 dp[i][j] = 1 18 19for i in range(int(input())): 20 S, E = map(int, input().</description></item><item><title>5582 : 공통 부분 문자열 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5582/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5582/</guid><description>1S1 = list(input()) 2S2 = list(input()) 3L1 = len(S1)+1 4L2 = len(S2)+1 5 6dp = [[0]*L1 for _ in range(L2)] 7result = 0 8 9for i in range(1, L2): 10 for j in range(1, L1): 11 if S1[j-1] == S2[i-1]: 12 dp[i][j] = dp[i-1][j-1]+1 13 result = max(result, dp[i][j]) 14 15print (result) 혼자 힘으로 해결! 깔끔한 풀이가 나와 기분이 좋다</description></item><item><title>5557 : 1학년 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5557/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5557/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3dp = [[0]*21 for _ in range(N-1)] 4 5dp[0][L[0]] = 1 6 7for i in range(0, N-2): 8 for j in range(21): 9 if dp[i][j] != 0: 10 k = L[i+1] 11 if k != 0: 12 if 0 &amp;lt;= j+k &amp;lt;= 20: 13 dp[i+1][j+k] += dp[i][j] 14 if 0 &amp;lt;= j-k &amp;lt;= 20: 15 dp[i+1][j-k] += dp[i][j] 16 else: 17 dp[i+1][j] = dp[i][j]*2 18print (dp[N-2][L[-1]]) 혼자 힘으로 풀었다!</description></item><item><title>10164 : 격자상의 경로 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10164/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10164/</guid><description>1N, M, K = map(int, input().split()) 2K -= 1 3ox = K % M 4oy = K // M 5def solve(sx, sy, ex, ey): 6 dp = [[0]*M for _ in range(N)] 7 dp[sy][sx] = 1 8 for i in range(sy, ey+1): 9 for j in range(sx, ex+1): 10 if i-1 &amp;gt;= 0: 11 dp[i][j] += dp[i-1][j] 12 if j-1 &amp;gt;= 0: 13 dp[i][j] += dp[i][j-1] 14 return dp[ey][ex] 15 16if K !</description></item><item><title>2011 : 암호코드 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2011/</link><pubDate>Sat, 28 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2011/</guid><description>1L = list(input()) 2N = len(L) 3MOD = 10**6 4 5def solution(): 6 if L[0] == &amp;#39;0&amp;#39;: 7 return 0 8 9 dp = [1, 1]+[0]*(N-1) 10 11 for i in range(2, N+1): 12 if L[i-1] != &amp;#39;0&amp;#39;: 13 dp[i] = (dp[i]+dp[i-1]) % MOD 14 if 10 &amp;lt;= int(L[i-2]+L[i-1]) &amp;lt;= 26: 15 dp[i] = (dp[i]+dp[i-2]) % MOD 16 17 return dp[N] 18 19 20print (solution()) 인터넷을 참고하여 풀었다</description></item><item><title>1495 : 기타리스트 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1495/</link><pubDate>Fri, 27 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1495/</guid><description>1N, S, M = map(int, input().split()) 2P = list(map(int, input().split())) 3dp = [[False]*(M+1) for _ in range(N+1)] 4 5dp[0][S] = True 6 7for i in range(1, N+1): 8 for j in range(M+1): 9 if dp[i-1][j]: 10 if 0 &amp;lt;= j-P[i-1] &amp;lt;= M: 11 dp[i][j-P[i-1]] = True 12 if 0 &amp;lt;= j+P[i-1] &amp;lt;= M: 13 dp[i][j+P[i-1]] = True 14result = -1 15for i in range(M+1): 16 if dp[N][i]: 17 result = i 18print (result) 인터넷에서 접근을 참고했다</description></item><item><title>16194 : 카드 구매하기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_16194/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_16194/</guid><description>1N = int(input()) 2P = list(map(int, input().split())) 3dp = [10000000]*(N) 4 5for i in range(N): 6 for j in range(i): 7 dp[i] = min(dp[i], dp[j]+P[i-j-1]) 8 dp[i] = min(dp[i], P[i]) 9 10print (dp[N-1])</description></item><item><title>1965 : 상자넣기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1965/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1965/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3dp = [0]*N 4 5for i in range(1, N): 6 for j in range(i): 7 if L[j]&amp;lt;L[i] and dp[i]&amp;lt;dp[j]+1: 8 dp[i] = dp[j]+1 9print(max(dp)+1) LIS를 구하는 문제이다</description></item><item><title>17070 : 파이프 옮기기 1 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_17070/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17070/</guid><description>1N = int(input()) 2 3L = [list(map(int, input().split())) for _ in range(N)] 4result = 0 5 6def dfs(x, y, direc): 7 global result 8 if x == N-1 and y == N-1: 9 result += 1 10 return 11 12 if x+1 &amp;lt; N and y+1 &amp;lt; N and L[y+1][x] == 0 and L[y][x+1] == 0 and L[y+1][x+1] == 0: 13 dfs(x+1, y+1, 2) 14 15 if (direc == 0 or direc == 2) and x+1 &amp;lt; N and L[y][x+1] == 0: 16 dfs(x+1, y, 0) 17 18 if (direc == 1 or direc == 2) and y+1 &amp;lt; N and L[y+1][x] == 0: 19 dfs(x, y+1, 1) 20 21dfs(1, 0, 0) 22print(result) 별거 아닌게.</description></item><item><title>12852 : 1로 만들기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_12852/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12852/</guid><description>1N = int(input()) 2 3dp = [0, 0] + [10**6]*(N-1) 4bt = [0]*(N+1) 5 6for i in range(2, N+1): 7 dp[i] = min(dp[i-1]+1, dp[i]) 8 bt[i] = i-1 9 10 if i%3 == 0: 11 if dp[i//3]+1 &amp;lt; dp[i]: 12 dp[i] = dp[i//3]+1 13 bt[i] = i//3 14 if i%2 == 0: 15 if dp[i//2]+1 &amp;lt; dp[i]: 16 dp[i] = dp[i//2]+1 17 bt[i] = i//2 18 dp[i] = min(dp[i], dp[i//2]+1) 19 20print(dp[N]다 21i = N 22while i !</description></item><item><title>2096 : 내려가기 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2096/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2096/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3dp1 = [L[0][i] for i in range(3)] 4dp2 = [L[0][i] for i in range(3)] 5 6for i in range(1, N): 7tmp1 = [0]*3 8tmp2 = [0]*3 9for j in range(3): 10 11 if j == 0: 12 tmp1[0] = L[i][j] + max(dp1[0], dp1[1]) 13 tmp2[0] = L[i][j] + min(dp2[0], dp2[1]) 14 elif j == 1: 15 tmp1[1] = L[i][j] + max(dp1[0], dp1[1], dp1[2]) 16 tmp2[1] = L[i][j] + min(dp2[0], dp2[1], dp2[2]) 17 else: 18 tmp1[2] = L[i][j] + max(dp1[1], dp1[2]) 19 tmp2[2] = L[i][j] + min(dp2[1], dp2[2]) 20 dp1 = [i for i in tmp1] 21 dp2 = [i for i in tmp2] 22 23print (max(dp1), min(dp2)) Memoization과정이 다른 memoization 변수에 대해 종속적이라면 잘못된 결과를 초래한다 위 코드에서는 이를 방지하기 위해 tmp1, tmp2 변수를 사용한다 깊이 생각하지 않고 여러 번 제출해서 WA개수가 조금 많다;;</description></item><item><title>1890 : 점프 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1890/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1890/</guid><description>1N = int(input()) 2 3L = [list(map(int, input().split())) for _ in range(N)] 4dp = [[0]*N for _ in range(N)] 5dp[0][0] = 1 6for i in range(N): 7 for j in range(N): 8 if L[i][j] == 0: 9 continue 10 if dp[i][j] != 0: 11 right = j+L[i][j] 12 bottom = i+L[i][j] 13 14 if right &amp;lt; N: 15 dp[i][right] += dp[i][j] 16 if bottom &amp;lt; N: 17 dp[bottom][j] += dp[i][j] 18print (dp[N-1][N-1]) dp에 있는 값을 더해야하는데 1을 더해서 몇 번 틀렸다 거의 혼자 힘으로 풀었다</description></item><item><title>1309 : 동물원 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1309/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1309/</guid><description>1N = int(input()) 2dp = [1, 3] + [0]*(N-1) 3 4for i in range(2, N+1): 5 dp[i] = (dp[i-1]*2 + dp[i-2]) % 9901 6 7print(dp[N]) 고민 끝에 답을 찾아보긴 했다 점화식 생각해내는 놈들 머리에 뭐가 든건지 모르겠다</description></item><item><title>9655 : 돌게임 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_9655/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9655/</guid><description>1N = int(input()) 2print (&amp;#39;CY&amp;#39; if N%2==0 else &amp;#39;SK&amp;#39;) 게임이론에서 기초 중 기초 문제이다</description></item><item><title>1010 : 다리놓기 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_1010/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1010/</guid><description>1import math 2 3for _ in range(int(input())): 4 a, b = map(int, input().split()) 5 print(math.comb(max(a,b), min(a,b)))</description></item><item><title>10844 : 쉬운 계단 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10844/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10844/</guid><description> 접근이 어려워 인터넷을 참고했다. 코드는 보지 않았다. 수의 길이가 i이면서 마지막 숫자가 j인 계단 수의 개수를 저장하는 것이 핵심이다. 점화식은 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 이다. 1N = int(input()) 2L = [[0]*12 for _ in range(100)] 3L[0] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] 4 5for i in range(1, N): 6 for j in range(1, 11): 7 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 8 9print (sum(L[N-1])%1000000000)</description></item><item><title>11048 : 이동하기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11048/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11048/</guid><description>1N, M = map(int, input().split()) 2dp = [list(map(int, input().split())) for _ in range(N)] 3 4for i in range(1, N): 5 dp[i][0] = dp[i][0]+dp[i-1][0] 6for i in range(1, M): 7 dp[0][i] = dp[0][i]+dp[0][i-1] 8 9for i in range(1, N): 10 for j in range(1, M): 11 dp[i][j] = dp[i][j]+max(dp[i-1][j], dp[i][j-1]) 12 13print (dp[N-1][M-1])</description></item><item><title>11051 : 이항계수2 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11051/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11051/</guid><description> 내장 함수 사용
1import math 2 3N, K = map(int, input().split()) 4 5print (math.comb(N, K)%10007 파스칼의 사각형? dp 구현
1N, K = map(int, input().split()) 2 3if K == 0: 4 print(1) 5 exit() 6 7dp = [[0]*N for _ in range(K)] 8 9for i in range(N): 10 dp[0][i] = i+1 11 12for i in range(1, K): 13 for j in range(i, N): 14 dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % 10007 15 16print (dp[K-1][N-1])</description></item><item><title>11052 : 카드 구매하기 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11052/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11052/</guid><description>1N = int(input()) 2P = list(map(int, input().split())) 3 4D = [P[0]]+[0]*(N-1) 5 6for i in range(1, N): 7 for j in range(1, i+1): 8 D[i] = max(D[i-j]+P[j-1], D[i]) 9 D[i] = max(P[i], D[i]) 10 11print (D[N-1]</description></item><item><title>11057 : 오르막 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11057/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11057/</guid><description>1N = int(input()) 2dp = [[1]+[0]*9 for _ in range(N+1)] 3 4for i in range(1, N+1): 5 for j in range(1, 10): 6 dp[i][j] = dp[i-1][j]+dp[i][j-1] 7 8print (sum(dp[N])%10007)</description></item><item><title>14891 : 톱니바퀴 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_14891/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14891/</guid><description>1from collections import deque 2 3wheels = [deque(map(int, list(input()))) for _ in range(4)] 4 5def rotate(wheel, direction): 6 if direction == 1: 7 wheel.appendleft(wheel.pop()) 8 else: 9 wheel.append(wheel.popleft()) 10 return wheel 11 12K = int(input()) 13vd = [1, -1] 14res = 0 15 16for _ in range(K): 17 N, D = map(int, input().split()) 18 q = deque() 19 q.append((N-1, D)) 20 visited = [False] * 4 21 tmp = [] 22 23 while q: 24 cur, curD = q.</description></item><item><title>15683 : 감시 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_15683/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15683/</guid><description>1import copy, sys 2 3N, M = map(int, input().split()) 4L = [list(map(int, input().split())) for _ in range(N)] 5cctv = [] 6direction = [[[(0, 1)], [(0, -1)], [(1, 0)], [(-1, 0)]], 7[[(-1, 0), (1, 0)], [(0, -1), (0, 1)]], 8[[(-1, 0), (0, -1)], [(0, -1), (1, 0)], [(1, 0), (0, 1)], [(0, 1), (-1, 0)]], 9[[(-1, 0), (0, -1), (1, 0)], [(0, -1), (1, 0), (0, 1)], [(1, 0), (0, 1), (-1, 0)], [(0, 1), (-1, 0), (0, -1)]], 10[[(-1, 0), (0, -1), (1, 0), (0, 1)]]] 11res = sys.</description></item><item><title>1699 : 제곱수의 합 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1699/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1699/</guid><description>1N = int(input()) 2 3dp = [100000]*(N+1) 4tmp = 1 5 6for i in range(1, N+1): 7 if i**(1/2) % 1 == 0: 8 dp[i] = 1 9 tmp += 1 10 else: 11 for j in range(1, tmp): 12 dp[i] = min(dp[i], dp[i-(j**2)]+1) 13 14print (dp[N])</description></item><item><title>17404 : RGB거리 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17404/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17404/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3 4result = 100000 5 6for i in range(3): 7 dp = [[0, 0, 0] for _ in range(N)] 8 dp[0] = [10000]*3 9 dp[0][i] = L[0][i] 10 for j in range(1, N): 11 dp[j][0] = min(dp[j-1][1], dp[j-1][2])+L[j][0] 12 dp[j][1] = min(dp[j-1][0], dp[j-1][2])+L[j][1] 13 dp[j][2] = min(dp[j-1][0], dp[j-1][1])+L[j][2] 14 15 dp[N-1][i] = 100000 16 result = min([result]+dp[N-1]) 17 18print (result) 인터넷을 참고하여 풀었다</description></item><item><title>2193 : 이친수 (S3)</title><link>https://bong-u.github.io/til/algorithm/boj_2193/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2193/</guid><description>1N = int(input()) 2dp = [1]*N 3for i in range(2, N): 4 dp[i] = dp[i-2]+dp[i-1] 5print (dp[N-1]) 피보나치였다</description></item><item><title>2225 - 합분해 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2225/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2225/</guid><description>1N, K = map(int, input().split()) 2 3dp = [[0]*(N+1) for _ in range(K+1)] 4for i in range(1, K+1): 5 dp[i][0] = 1 6 7for i in range(1, K+1): 8 for j in range(1, N+1): 9 dp[i][j] = (dp[i-1][j] + dp[i][j-1])%1000000000 10print (dp[K][N]) 내 힘으로 풀었다!</description></item><item><title>2294 : 동전 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2294/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2294/</guid><description>1N, K = map(int, input().split()) 2V = [] 3for _ in range(N): 4 V.append(int(input())) 5dp = [[0]+([10001]*K) for _ in range(N+1)] 6 7for i in range(1, N+1): 8 for j in range(1, K+1): 9 if j &amp;gt;= V[i-1]: 10 dp[i][j] = min(dp[i-1][j], dp[i][j-V[i-1]]+1) 11 else: 12 dp[i][j] = dp[i-1][j] 13 14res = dp[N][K] 15 16print (res if res != 10001 else -1) dp를 많이 풀어보자</description></item><item><title>2565 : 전깃줄 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2565/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2565/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3L = [i[1] for i in sorted(L)] 4dp = [0]*N 5for i in range(N): 6 dp[i] = 1 7 for j in range(i): 8 if L[j] &amp;lt; L[i]: 9 dp[i] = max(dp[i], dp[j]+1) 10 11print (N-max(dp)) LIS를 이용하는 문제</description></item><item><title>2573 : 빙산 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2573/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2573/</guid><description>1import copy 2from collections import deque 3 4N, M = map(int, input().split()) 5L = [list(map(int, input().split())) for _ in range(N)] 6L[0][0] = 0 7L[N-1][M-1] = 0 8vx = [0, 0, -1, 1] 9vy = [-1, 1, 0, 0] 10 11def melt(L): 12 L_ = copy.deepcopy(L) 13 for i in range(M): 14 for j in range(N): 15 if L[j][i] != 0: 16 for k in range(4): 17 nx = j + vx[k] 18 ny = i + vy[k] 19 20 if not 0 &amp;lt;= nx &amp;lt; N or not 0 &amp;lt;= ny &amp;lt; M: 21 continue 22 if L[nx][ny] == 0 and L_[j][i] !</description></item><item><title>2748 : 피보나치 수2 (B2)</title><link>https://bong-u.github.io/til/algorithm/boj_2748/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2748/</guid><description> &amp;ldquo;알고리즘 분류-DP&amp;quot;에서 안 푼 문제이길래 한 번 풀어봤다. 1N = int(input()) 2 3L = [0, 1] + [0]*89 4 5for i in range(2, N+1): 6 L[i] = L[i-1]+L[i-2] 7 8print (L[N])</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🧠|Algorithm on Bong-u's TIL</title><link>https://bong-u.github.io/til/algorithm/</link><description>Recent content in 🧠|Algorithm on Bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://bong-u.github.io/til/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>리코쳇 로봇 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</guid><description>from collections import deque visited = [] vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def bfs(board, N, M, sp): global visited q = deque() q.append(sp+[1]) while q: cy, cx, cnt = q.popleft() visited[cy][cx] = True for i in range(4): x = cx y = cy while True: x += vx[i] y += vy[i] if not (0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; M) or board[y][x] == &amp;#39;D&amp;#39;: x -= vx[i] y -= vy[i] break if board[y][x] == &amp;#39;G&amp;#39;: return cnt if not visited[y][x]: q.</description></item><item><title>광물 캐기(L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</guid><description>def solution(picks, minerals): bundles = [] tmp = [0, 0, 0] DATA = [[1, 1, 1], [5, 1, 1], [25, 5, 1]] answer = 0 for i in range(len(minerals)): if minerals[i] == &amp;#34;diamond&amp;#34;: for j in range(3): tmp[j] += DATA[j][0] elif minerals[i] == &amp;#34;iron&amp;#34;: for j in range(3): tmp[j] += DATA[j][1] elif minerals[i] == &amp;#34;stone&amp;#34;: for j in range(3): tmp[j] += DATA[j][2] if (i+1) % 5 == 0 or i == len(minerals)-1: bundles.</description></item><item><title>과제 진행하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</guid><description>내 답안 def solution(plans): q = [] answer = [] for plan in plans: h, m = map(int, plan[1].split(&amp;#39;:&amp;#39;)) plan[1] = h*60 + m plan[2] = int(plan[2]) plans.sort(key = lambda x: x[1]) for plan in plans: if q: free_time = plan[1] - q[-1][1] while q: q[-1][2] -= free_time free_time = -1 * q[-1][2] print (free_time, q[-1][2]) if free_time &amp;lt; 0: break if q[-1][2] &amp;lt;= 0: answer.append(q.pop()[0]) q.append(plan) while q: answer.append(q.pop()[0]) return answer 다른 사람 답안 def solution(plans): plans = sorted(map(lambda x: [x[0], int(x[1][:2]) * 60 + int(x[1][3:]), int(x[2])], plans), key=lambda x: -x[1]) q = [] while plans: cur = plans.</description></item><item><title>연속된 부분 수열의 합 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</guid><description>def solution(sequence, k): answer = [] e = len(sequence)-1 s = len(sequence) cur = 0 while s &amp;gt;= 0: if cur &amp;lt; k: s -= 1 cur += sequence[s] elif cur &amp;gt; k: cur -= sequence[e] e -= 1 else: answer.append((s, e)) s -= 1 cur += sequence[s] answer.sort(key=lambda x: (x[1]-x[0], x[0])) return answer[0] 문제 수열과 k가 주어진다 수열의 부분합이 k가 되게 하는 시작인덱스와 끝인덱스를 구하라 이때, 길이가 짧은 수열을 찾는다, 길이가 같은것이 여러가지라면 시작인덱스가 작은 것을 찾는다 TC input [1, 2, 3, 4, 5], 7</description></item><item><title>두 원 사이의 정수 쌍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</guid><description>import math def calc1(r): result = 0 for i in range(1, r): result += math.floor(math.sqrt(r**2 - i**2)) return result*4 + r*4 + 1 def calc2(r): result = 0 for i in range(1, r): a = math.sqrt(r**2 - i**2) result += math.floor(a) if a % 1 == 0: result -= 1 return result*4 + r*4 + 1 def solution(r1, r2): return calc1(r2)-calc2(r1)+4 문제 두 원의 반지름 r1, r2가 주어진다. 두 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 구하라 이때, 각 원 위의 점도 포함하여 센다.</description></item><item><title>요격 시스템 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</guid><description>def solution(targets): answer = 0 targets.sort(key=lambda x:x[1]) cur = 0 for i in targets: if i[0] &amp;gt;= cur: answer += 1 cur = i[1] return answer 문제 개구간 (s, e)의 리스트가 주어진다. 이때, 모든 개구간을 포함하는 최소 숫자의 수를 구하여라 TC input [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]]
ouput 3
해결방법 개구간을 (s, e)에서 e를 정렬하여 해결하였다. s 기준으로 정렬해도 해결할 수 있다는데 나는 e로 정렬하는게 편했다</description></item><item><title>11000 : 강의실 배정 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_11000/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11000/</guid><description>import heapq N = int(input()) L = [] for _ in range(N): L.append(tuple(map(int, input().split()))) L.sort() q = [] heapq.heappush(q, L[0][1]) for i in L[1:]: if q[0] &amp;gt; i[0]: heapq.heappush(q, i[1]) else: heapq.heappop(q) heapq.heappush(q, i[1]) print (len(q)) 문제 강의 개수와 강의 당 시작시간, 종료시간이 주어진다 필요한 강의실 개수를 구하라 (연강 가능)) TC
input 3 1 3 2 4 3 5
output 4</description></item><item><title>2638 : 치즈 (G3)</title><link>https://bong-u.github.io/til/algorithm/boj_2638/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2638/</guid><description>from collections import deque dx = [0, 0, -1, 1] dy = [-1, 1, 0, 0] N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] def check(): q = deque() q.append((0, 0)) visited = [[0]*M for _ in range(N)] visited[0][0] = 1 while q: curX, curY = q.popleft() for i in range(4): nX = curX + dx[i] nY = curY + dy[i] if 0 &amp;lt;= nX &amp;lt; N and 0 &amp;lt;= nY &amp;lt; M: if L[nX][nY] == 0 and visited[nX][nY] == 0: q.</description></item><item><title>11444 : 피보나치 수 6 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_11444/</link><pubDate>Tue, 09 May 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11444/</guid><description>def multiply(m1, m2): result = [0, 0, 0, 0] result[0] = (m1[0]*m2[0] + m1[1]*m2[2]) % 1000000007 result[1] = (m1[0]*m2[1] + m1[1]*m2[3]) % 1000000007 result[2] = (m1[2]*m2[0] + m1[3]*m2[2]) % 1000000007 result[3] = (m1[2]*m2[1] + m1[3]*m2[3]) % 1000000007 return result def power(m, n): if (n &amp;gt; 1): m = power (m, n//2) m = multiply (m, m) if n % 2 == 1: m = multiply(m, [1,1,1,0]) return m N = int(input()) mat = power ([1,1,1,0], N) print (mat[1]%1000000007) 문제 n이 주어질 때 n번째 피보나치 수를 구하여라.</description></item><item><title>1976 : 여행 가자 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1976/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1976/</guid><description>N = int(input()) M = int(input()) parent = [i for i in range(N)] def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(a, b): a = find(a) b = find(b) if a &amp;lt; b: parent[b] = a else: parent[a] = b for i in range(N): for j, item in enumerate(map(int, input().split())): if item: union(i, j) path = list(map(int, input().split())) start = parent[path[0]-1] for i in range(1, M): if parent[path[i]-1] !</description></item><item><title>11003 : 최솟값 찾기 (P5)</title><link>https://bong-u.github.io/til/algorithm/boj_11003/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11003/</guid><description>from collections import deque N, L = map(int, input().split()) A = list(map(int, input().split())) Q = deque([(A[0], 0)]) result = [A[0]] for i in range(1, N): if Q[0][1] == i-L: Q.popleft() while Q and Q[-1][0] &amp;gt;= A[i]: Q.pop() Q.append((A[i], i)) result.append(Q[0][0]) print(*result) 문제 N개의 수 A1, A2, &amp;hellip;, AN 과 L이 주어진다. Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. TC input 12 3</description></item><item><title>17144 : 미세먼지 안녕! (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17144/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17144/</guid><description>R, C, T = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(R)] dx = [0, 1, 0, -1] dy = [-1, 0, 1, 0] dx2 = [0, 1, 0, -1] dy2 = [1, 0, -1, 0] pur_a = (0, 0) pur_b = (0, 0) for i in range(R): if L[i][0] == -1: pur_a = (i, 0) pur_b = (i+1, 0) break def diffuse(L): L_ = [[0]*C for _ in range(R)] for i in range(R): for j in range(C): if L[i][j] &amp;gt; 0: cnt = 0 for k in range(4): px = j+dx[k] py = i+dy[k] if 0 &amp;lt;= px &amp;lt; C and 0 &amp;lt;= py &amp;lt; R and L[py][px] !</description></item><item><title>12851 : 숨바꼭질 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_12851/</link><pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12851/</guid><description>from collections import deque position_a, position_b = map(int, input().split()) q = deque() visited = [False]*100001 result = 0 cnt = 1 q.append((0, position_a)) while q: time, cur = q.popleft(); visited[cur] = True if cur == position_b: result = time for i in q: if i == (time, cur): cnt += 1 break if cur-1 &amp;gt;= 0 and not visited[cur-1]: q.append((time+1, cur-1)) if cur+1 &amp;lt;= 100000 and not visited[cur+1]: q.append((time+1, cur+1)) if cur*2 &amp;lt;= 100000 and not visited[cur*2]: q.</description></item><item><title>2448 : 별 찍기 - 11 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2448/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2448/</guid><description>import math N = int(input()) K = int(math.log2(N//3)) arr = [[&amp;#39; &amp;#39;] * (2*N-1) for _ in range(N)] def solve(depth, bx, by): if depth == 0: for i in range(3): for j in range(i*2+1): arr[by+i][bx+(2-i)+j] = &amp;#39;*&amp;#39; arr[by+1][bx+2] = &amp;#39; &amp;#39; else: px = 2**(depth)*3 py = 2**(depth-1)*3 solve(depth-1, bx+px//2, by) solve(depth-1, bx, by+py) solve(depth-1, bx+px, by+py) solve(K, 0, 0) for i in arr: print (&amp;#39;&amp;#39;.join(i)) 혼자 풀었다 별이 찍혀져있는 모습을 보고 규칙을 찾아내서 구현하는 문제였다 N이 3*(2^N)으로만 주어진다는 것을 토대로 재귀를 이용하여 풀었다</description></item><item><title>1043 : 거짓말 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1043/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1043/</guid><description>N, M = map(int, input().split()) T = list(map(int, input().split())) T = set(T[1:]) member = [set() for _ in range(N)] party = [] visit = [False]*M def explore(n): for i in member[n]: if not visit[i]: visit[i] = True for j in party[i]: explore(j-1) for i in range(M): lst = list(map(int, input().split())) lst = lst[1:] for j in lst: member[j-1].add(i) party.append(set(lst)) for i in T: explore(i-1) cnt = 0 for i in visit: if not i: cnt += 1 print (cnt) 내방식대로 푸는데 오래걸렸다 유니온 파인드로 푸는 사람도 있었다</description></item><item><title>5639 : 이진 검색 트리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5639/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5639/</guid><description>풀이방법 1 : 직접 구현 import sys sys.setrecursionlimit(10**6) class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self, root): self.root = root def insert(self, value): cur_node = self.root while True: if value &amp;lt; cur_node.value: if cur_node.left != None: cur_node = cur_node.left else: cur_node.left = Node(value) break else: if cur_node.right != None: cur_node = cur_node.right else: cur_node.right = Node(value) break def traverse(self, node): if node.</description></item><item><title>14938 : 서강그라운드 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_14938/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14938/</guid><description>N, M, R = map(int, input().split()) item = list(map(int, input().split())) G = [[] for _ in range(N)] for _ in range(R): a, b, c = map(int, input().split()) G[a-1].append((b-1, c)) G[b-1].append((a-1, c)) def dfs(node, dist): global result if dist &amp;gt; M: return if not visit[node]: result += item[node] visit[node] = True for n_node, n_dist in G[node]: dfs(n_node, dist+n_dist) max_result = 0 for i in range(N): result = 0 visit = [False]*N dfs(i, 0) max_result = max(max_result, result) print (max_result) 분류에 다익스트라, 플로이드-워셜로 되어있지만 DFS로 풀었다 풀이 방법 여기서는 재방문 했다고 해서 탐색을 하지 않으면 안된다 재방문했을때 전에 방문했을 때보다 더 짧은 통로로 들어왔다면 더 많은 아이템을 얻을 수 있기 때문이다 다만, 아이템은 방문할 때마다 얻을 수 있는 것이 아니기 때문에 주의하여야 한다 위의 내용을 질문게시판을 보다가 깨닫고 풀 수 있었다</description></item><item><title>1167 : 트리의 지름 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1167/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1167/</guid><description>import sys sys.setrecursionlimit(10**6) input = sys.stdin.readline V = int(input()) G = [[] for _ in range(V)] for _ in range(V): token = list(map(int, input().split()))[:-1] for i in range(1, len(token), 2): G[token[0]-1].append((token[i]-1, token[i+1])) def dfs(node, dist): global max_node, max_dist visited[node] = True if dist &amp;gt; max_dist: max_node = node max_dist = dist for n_node, n_dist in G[node]: if not visited[n_node]: dfs(n_node, dist+n_dist) max_node = 0 max_dist = 0 visited = [False]*V dfs(0, 0) max_dist = 0 visited = [False]*V dfs(max_node, 0) print (max_dist) 최근에 푼 &amp;ldquo;1967: 트리의 지름&amp;rdquo; 덕분에 쉽게 해결할 수 있었다 기억하자 트리의 지름 = (어떤 한 정점에서 가장 먼 점 P)에서 가장 먼 점 사이의 거리</description></item><item><title>1967 : 트리의 지름(G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1967/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1967/</guid><description>import sys sys.setrecursionlimit(10**6) M = int(input()) G = [[] for _ in range(M)] for _ in range(M-1): a, b, c = map(int, input().split()) G[a-1].append((b-1, c)) G[b-1].append((a-1, c)) n1 = 0 tmp = 0 def dfs(node, length): global n1, tmp visit[node] = True if length &amp;gt; tmp: tmp = length n1 = node for child, v in G[node]: if not visit[child]: dfs(child, length+v) visit = [False]*M dfs(0, 0) tmp = 0 visit = [False]*M dfs(n1, 0) print (tmp) 인터넷에서 접근 방법을 참고했다 해결 방법 아무 정점에서 가장 먼 어떤 정점을 N이라고 하자 정점 N에서 가장 먼 정점 사이의 거리가 트리의 지름과 같다 느낀 점 루트를 구할 필요가 없다는 것을 깨달았다</description></item><item><title>15681 : 트리와 쿼리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15681/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15681/</guid><description>import sys sys.setrecursionlimit(10**6) input = sys.stdin.readline N, R, Q = map(int, input().split()) G = [[] for _ in range(N)] cnt = [1]*N visited = [False]*N for _ in range(N-1): a, b = map(int, input().split()) G[a-1].append(b-1) G[b-1].append(a-1) def dfs(node): visited[node] = True for i in G[node]: if not visited[i]: cnt[node] += dfs(i) return cnt[node] dfs(R-1) for _ in range(Q): print (cnt[int(input())-1]) 혼자 풀었다!
서브트리에 속한 정점의 수를 memoization해놓고 쿼리마다 index의 값을 출력하면 된다</description></item><item><title>2502 : 떡 먹는 호랑이 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_2502/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2502/</guid><description>D, K = map(int, input().split()) L = [(1, 0), (0, 1)] for i in range(2, D): L.append((L[i-2][0]+L[i-1][0], L[i-2][1]+L[i-1][1])) A = 1 B = 2 while True: if A*L[D-1][0] + B*L[D-1][1] == K: break if A+1 == B: B += 1 A = 1 else: A += 1 print (A,&amp;#39;\n&amp;#39;,B, sep=&amp;#39;&amp;#39;) 해결방법 N번째날 떡 개수를 구하기 위해 첫째날 떡, 둘째날 떡을 각각 몇번 더해야하는지 리스트에 구한다 첫째, 둘째 날 떡을 하나하나 넣어보면서 브루트 포스를 수행한다</description></item><item><title>13398 : 연속합 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_13398/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_13398/</guid><description>N = int(input()) L = list(map(int, input().split())) res = 0 dp = [[-1000]*N for _ in range(2)] dp[0][0] = L[0] for i in range(1, N): dp[0][i] = max(dp[0][i-1]+L[i], L[i]) dp[1][i] = max(dp[1][i-1]+L[i], dp[0][i-1]) print (max(max(dp[0]), max(dp[1]))) 이번 문제에서 사용할 dp 배열의 크기는 N X 2 이다. 배열은 최솟값인 -1000으로 초기화하여야 한다</description></item><item><title>15486 : 퇴사 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15486/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15486/</guid><description>import sys input = sys.stdin.readline N = int(input()) T = [] P = [] dp = [0]*(N+1) for _ in range(N): a, b = map(int, input().split()) T.append(a) P.append(b) for i in range(N-1, -1, -1): if i+T[i] &amp;gt; N: dp[i] = dp[i+1] else: dp[i] = max(P[i]+dp[i+T[i]], dp[i+1]) print (dp[0]) dp라는 변수를 만들어야하는데 안 만들고 리스트 P만 가지고 memoization 하려다 실패했다 점화식은 잘 적었으나 조건문이 잘 못되어서 다른 풀이를 참고했다</description></item><item><title>2631 : 줄세우기 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2631/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2631/</guid><description>N = int(input()) L = [] for i in range(N): L.append(int(input())) dp = [1]*N for i in range(N): for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 활용한 문제이다 풀이 유도는 잘했으나 LIS가 헷갈려서 전에 풀었던 코드를 참고하였다</description></item><item><title>1915 : 가장 큰 정사각형 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1915/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1915/</guid><description>N, M = map(int, input().split()) L = [list(map(int, input())) for _ in range(N)] dp = [[0]*(M+1) for _ in range(N+1)] result = 0 for i in range(1, N+1): for j in range(1, M+1): dp[i][j] = L[i-1][j-1] if L[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 result = max(result, dp[i][j]) for i in dp: print (i) print (result**2) 조금 시간이 걸렸지만 혼자 힘으로 풀었다 점화식은 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1이다. 모두 0이면 0, 하나라도 1이면 1이 답이라는 것을 생각해야 한다.</description></item><item><title>1918 : 후위 표기식 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1918/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1918/</guid><description>string = list(input()) priority = {&amp;#39;(&amp;#39;:0, &amp;#39;)&amp;#39;:0, &amp;#39;+&amp;#39;:1, &amp;#39;-&amp;#39;:1, &amp;#39;*&amp;#39;:2, &amp;#39;/&amp;#39;:2} operator = [] result = &amp;#39;&amp;#39; for c in string: if c.isalpha(): result += c elif c == &amp;#39;(&amp;#39;: operator.append(c) elif c == &amp;#39;)&amp;#39;: while operator: op = operator.pop() if op == &amp;#39;(&amp;#39;: break result += op else: if operator: if priority[operator[-1]] &amp;lt; priority[c]: operator.append(c) else: while operator and priority[operator[-1]] &amp;gt;= priority[c]: result += operator.pop() operator.append(c) else: operator.append(c) while operator: result += operator.</description></item><item><title>9252 : LCS 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_9252/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9252/</guid><description>S1 = list(input()) S2 = list(input()) N1 = len(S1)+1 N2 = len(S2)+1 dp = [[0]*(N1) for _ in range(N2)] for i in range(1, N2): for j in range(1, N1): if S2[i-1] == S1[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) i = N2-1 j = N1-1 print (dp[i][j]) if dp[i][j] == 0: exit() result = &amp;#39;&amp;#39; while True: if i==0 or j==0: break if dp[i][j] == dp[i-1][j]: i -= 1 elif dp[i][j] == dp[i][j-1]: j -= 1 else: result = S1[j-1] + result i -= 1 j -= 1 print (result) 점화식을 잘못 세웠었다 문자가 같은 경우에 max(dp[i-1][j], dp[i][j-1])+1이 아닌 dp[i-1][j-1]+1이다.</description></item><item><title>10942 : 팰린드롬? (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_10942/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10942/</guid><description>import sys input = sys.stdin.readline N = int(input()) L = list(map(int, input().split())) dp = [[0]*N for _ in range(N)] for i in range(N): dp[i][i] = 1 if i &amp;lt; N-1 and L[i] == L[i+1]: dp[i][i+1] = 1 for i in range(N, -1, -1): for j in range(i+1, N): if dp[i+1][j-1] and L[i] == L[j]: dp[i][j] = 1 for i in range(int(input())): S, E = map(int, input().split()) print (dp[S-1][E-1]) 인터넷을 참고했다 쉽지 않은 문제였다</description></item><item><title>5582 : 공통 부분 문자열 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5582/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5582/</guid><description>S1 = list(input()) S2 = list(input()) L1 = len(S1)+1 L2 = len(S2)+1 dp = [[0]*L1 for _ in range(L2)] result = 0 for i in range(1, L2): for j in range(1, L1): if S1[j-1] == S2[i-1]: dp[i][j] = dp[i-1][j-1]+1 result = max(result, dp[i][j]) print (result) 혼자 힘으로 해결! 깔끔한 풀이가 나와 기분이 좋다</description></item><item><title>5557 : 1학년 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5557/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5557/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [[0]*21 for _ in range(N-1)] dp[0][L[0]] = 1 for i in range(0, N-2): for j in range(21): if dp[i][j] != 0: k = L[i+1] if k != 0: if 0 &amp;lt;= j+k &amp;lt;= 20: dp[i+1][j+k] += dp[i][j] if 0 &amp;lt;= j-k &amp;lt;= 20: dp[i+1][j-k] += dp[i][j] else: dp[i+1][j] = dp[i][j]*2 print (dp[N-2][L[-1]]) 혼자 힘으로 풀었다! 이전에 비슷한 dp 문제를 풀어본 적이 있어서 쉽게 풀 수 있었다</description></item><item><title>10164 : 격자상의 경로 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10164/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10164/</guid><description>N, M, K = map(int, input().split()) K -= 1 ox = K % M oy = K // M def solve(sx, sy, ex, ey): dp = [[0]*M for _ in range(N)] dp[sy][sx] = 1 for i in range(sy, ey+1): for j in range(sx, ex+1): if i-1 &amp;gt;= 0: dp[i][j] += dp[i-1][j] if j-1 &amp;gt;= 0: dp[i][j] += dp[i][j-1] return dp[ey][ex] if K != -1: print (solve(0, 0, ox, oy) * solve(ox, oy, M-1, N-1)) else: print (solve(0, 0, M-1, N-1)) 혼자 힘으로 해결하였다!</description></item><item><title>2011 : 암호코드 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2011/</link><pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2011/</guid><description>L = list(input()) N = len(L) MOD = 10**6 def solution(): if L[0] == &amp;#39;0&amp;#39;: return 0 dp = [1, 1]+[0]*(N-1) for i in range(2, N+1): if L[i-1] != &amp;#39;0&amp;#39;: dp[i] = (dp[i]+dp[i-1]) % MOD if 10 &amp;lt;= int(L[i-2]+L[i-1]) &amp;lt;= 26: dp[i] = (dp[i]+dp[i-2]) % MOD return dp[N] print (solution()) 인터넷을 참고하여 풀었다</description></item><item><title>1495 : 기타리스트 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1495/</link><pubDate>Fri, 27 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1495/</guid><description>N, S, M = map(int, input().split()) P = list(map(int, input().split())) dp = [[False]*(M+1) for _ in range(N+1)] dp[0][S] = True for i in range(1, N+1): for j in range(M+1): if dp[i-1][j]: if 0 &amp;lt;= j-P[i-1] &amp;lt;= M: dp[i][j-P[i-1]] = True if 0 &amp;lt;= j+P[i-1] &amp;lt;= M: dp[i][j+P[i-1]] = True result = -1 for i in range(M+1): if dp[N][i]: result = i print (result) 인터넷에서 접근을 참고했다</description></item><item><title>16194 : 카드 구매하기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_16194/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_16194/</guid><description>N = int(input()) P = list(map(int, input().split())) dp = [10000000]*(N) for i in range(N): for j in range(i): dp[i] = min(dp[i], dp[j]+P[i-j-1]) dp[i] = min(dp[i], P[i]) print (dp[N-1])</description></item><item><title>1965 : 상자넣기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1965/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1965/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [0]*N for i in range(1, N): for j in range(i): if L[j]&amp;lt;L[i] and dp[i]&amp;lt;dp[j]+1: dp[i] = dp[j]+1 print(max(dp)+1) LIS를 구하는 문제이다</description></item><item><title>17070 : 파이프 옮기기 1 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_17070/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17070/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 0 def dfs(x, y, direc): global result if x == N-1 and y == N-1: result += 1 return if x+1 &amp;lt; N and y+1 &amp;lt; N and L[y+1][x] == 0 and L[y][x+1] == 0 and L[y+1][x+1] == 0: dfs(x+1, y+1, 2) if (direc == 0 or direc == 2) and x+1 &amp;lt; N and L[y][x+1] == 0: dfs(x+1, y, 0) if (direc == 1 or direc == 2) and y+1 &amp;lt; N and L[y+1][x] == 0: dfs(x, y+1, 1) dfs(1, 0, 0) print(result) 별거 아닌게.</description></item><item><title>12852 : 1로 만들기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_12852/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12852/</guid><description>N = int(input()) dp = [0, 0] + [10**6]*(N-1) bt = [0]*(N+1) for i in range(2, N+1): dp[i] = min(dp[i-1]+1, dp[i]) bt[i] = i-1 if i%3 == 0: if dp[i//3]+1 &amp;lt; dp[i]: dp[i] = dp[i//3]+1 bt[i] = i//3 if i%2 == 0: if dp[i//2]+1 &amp;lt; dp[i]: dp[i] = dp[i//2]+1 bt[i] = i//2 dp[i] = min(dp[i], dp[i//2]+1) print(dp[N]다 i = N while i != 1: print (i, end=&amp;#39; &amp;#39;) i = bt[i] print (1) dp 아직 많이 멀었다는 생각이 든다</description></item><item><title>2096 : 내려가기 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2096/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2096/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp1 = [L[0][i] for i in range(3)] dp2 = [L[0][i] for i in range(3)] for i in range(1, N): tmp1 = [0]*3 tmp2 = [0]*3 for j in range(3): if j == 0: tmp1[0] = L[i][j] + max(dp1[0], dp1[1]) tmp2[0] = L[i][j] + min(dp2[0], dp2[1]) elif j == 1: tmp1[1] = L[i][j] + max(dp1[0], dp1[1], dp1[2]) tmp2[1] = L[i][j] + min(dp2[0], dp2[1], dp2[2]) else: tmp1[2] = L[i][j] + max(dp1[1], dp1[2]) tmp2[2] = L[i][j] + min(dp2[1], dp2[2]) dp1 = [i for i in tmp1] dp2 = [i for i in tmp2] print (max(dp1), min(dp2)) Memoization과정이 다른 memoization 변수에 대해 종속적이라면 잘못된 결과를 초래한다 위 코드에서는 이를 방지하기 위해 tmp1, tmp2 변수를 사용한다 깊이 생각하지 않고 여러 번 제출해서 WA개수가 조금 많다;;</description></item><item><title>1890 : 점프 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1890/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1890/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp = [[0]*N for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(N): if L[i][j] == 0: continue if dp[i][j] != 0: right = j+L[i][j] bottom = i+L[i][j] if right &amp;lt; N: dp[i][right] += dp[i][j] if bottom &amp;lt; N: dp[bottom][j] += dp[i][j] print (dp[N-1][N-1]) dp에 있는 값을 더해야하는데 1을 더해서 몇 번 틀렸다 거의 혼자 힘으로 풀었다</description></item><item><title>1309 : 동물원 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1309/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1309/</guid><description>N = int(input()) dp = [1, 3] + [0]*(N-1) for i in range(2, N+1): dp[i] = (dp[i-1]*2 + dp[i-2]) % 9901 print(dp[N]) 고민 끝에 답을 찾아보긴 했다 점화식 생각해내는 놈들 머리에 뭐가 든건지 모르겠다</description></item><item><title>9655 : 돌게임 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_9655/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9655/</guid><description>N = int(input()) print (&amp;#39;CY&amp;#39; if N%2==0 else &amp;#39;SK&amp;#39;) 게임이론에서 기초 중 기초 문제이다</description></item><item><title>1010 : 다리놓기 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_1010/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1010/</guid><description>import math for _ in range(int(input())): a, b = map(int, input().split()) print(math.comb(max(a,b), min(a,b)))</description></item><item><title>10844 : 쉬운 계단 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10844/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10844/</guid><description> 접근이 어려워 인터넷을 참고했다. 코드는 보지 않았다. 수의 길이가 i이면서 마지막 숫자가 j인 계단 수의 개수를 저장하는 것이 핵심이다. 점화식은 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 이다. N = int(input()) L = [[0]*12 for _ in range(100)] L[0] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] for i in range(1, N): for j in range(1, 11): L[i][j] = L[i-1][j-1]+L[i-1][j+1] print (sum(L[N-1])%1000000000)</description></item><item><title>11048 : 이동하기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11048/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11048/</guid><description>N, M = map(int, input().split()) dp = [list(map(int, input().split())) for _ in range(N)] for i in range(1, N): dp[i][0] = dp[i][0]+dp[i-1][0] for i in range(1, M): dp[0][i] = dp[0][i]+dp[0][i-1] for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i][j]+max(dp[i-1][j], dp[i][j-1]) print (dp[N-1][M-1])</description></item><item><title>11051 : 이항계수2 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11051/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11051/</guid><description> 내장 함수 사용
import math N, K = map(int, input().split()) print (math.comb(N, K)%10007 파스칼의 사각형? dp 구현
N, K = map(int, input().split()) if K == 0: print(1) exit() dp = [[0]*N for _ in range(K)] for i in range(N): dp[0][i] = i+1 for i in range(1, K): for j in range(i, N): dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % 10007 print (dp[K-1][N-1])</description></item><item><title>11052 : 카드 구매하기 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11052/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11052/</guid><description>N = int(input()) P = list(map(int, input().split())) D = [P[0]]+[0]*(N-1) for i in range(1, N): for j in range(1, i+1): D[i] = max(D[i-j]+P[j-1], D[i]) D[i] = max(P[i], D[i]) print (D[N-1]</description></item><item><title>11057 : 오르막 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11057/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11057/</guid><description>N = int(input()) dp = [[1]+[0]*9 for _ in range(N+1)] for i in range(1, N+1): for j in range(1, 10): dp[i][j] = dp[i-1][j]+dp[i][j-1] print (sum(dp[N])%10007)</description></item><item><title>14891 : 톱니바퀴 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_14891/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14891/</guid><description>from collections import deque wheels = [deque(map(int, list(input()))) for _ in range(4)] def rotate(wheel, direction): if direction == 1: wheel.appendleft(wheel.pop()) else: wheel.append(wheel.popleft()) return wheel K = int(input()) vd = [1, -1] res = 0 for _ in range(K): N, D = map(int, input().split()) q = deque() q.append((N-1, D)) visited = [False] * 4 tmp = [] while q: cur, curD = q.popleft() tmp.append((cur, curD)) visited[cur] = True for v in vd: nxt = cur+v if 0 &amp;lt;= nxt &amp;lt; 4 and not visited[nxt]: if (v == -1 and wheels[cur][6] !</description></item><item><title>15683 : 감시 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_15683/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15683/</guid><description>import copy, sys N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] cctv = [] direction = [[[(0, 1)], [(0, -1)], [(1, 0)], [(-1, 0)]], [[(-1, 0), (1, 0)], [(0, -1), (0, 1)]], [[(-1, 0), (0, -1)], [(0, -1), (1, 0)], [(1, 0), (0, 1)], [(0, 1), (-1, 0)]], [[(-1, 0), (0, -1), (1, 0)], [(0, -1), (1, 0), (0, 1)], [(1, 0), (0, 1), (-1, 0)], [(0, 1), (-1, 0), (0, -1)]], [[(-1, 0), (0, -1), (1, 0), (0, 1)]]] res = sys.</description></item><item><title>1699 : 제곱수의 합 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1699/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1699/</guid><description>N = int(input()) dp = [100000]*(N+1) tmp = 1 for i in range(1, N+1): if i**(1/2) % 1 == 0: dp[i] = 1 tmp += 1 else: for j in range(1, tmp): dp[i] = min(dp[i], dp[i-(j**2)]+1) print (dp[N])</description></item><item><title>17404 : RGB거리 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17404/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17404/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 100000 for i in range(3): dp = [[0, 0, 0] for _ in range(N)] dp[0] = [10000]*3 dp[0][i] = L[0][i] for j in range(1, N): dp[j][0] = min(dp[j-1][1], dp[j-1][2])+L[j][0] dp[j][1] = min(dp[j-1][0], dp[j-1][2])+L[j][1] dp[j][2] = min(dp[j-1][0], dp[j-1][1])+L[j][2] dp[N-1][i] = 100000 result = min([result]+dp[N-1]) print (result) 인터넷을 참고하여 풀었다
첫째집 3가지 X 마지막집 3가지 = 9가지 이지만</description></item><item><title>2193 : 이친수 (S3)</title><link>https://bong-u.github.io/til/algorithm/boj_2193/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2193/</guid><description>N = int(input()) dp = [1]*N for i in range(2, N): dp[i] = dp[i-2]+dp[i-1] print (dp[N-1]) 피보나치였다</description></item><item><title>2225 - 합분해 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2225/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2225/</guid><description>N, K = map(int, input().split()) dp = [[0]*(N+1) for _ in range(K+1)] for i in range(1, K+1): dp[i][0] = 1 for i in range(1, K+1): for j in range(1, N+1): dp[i][j] = (dp[i-1][j] + dp[i][j-1])%1000000000 print (dp[K][N]) 내 힘으로 풀었다!</description></item><item><title>2294 : 동전 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2294/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2294/</guid><description>N, K = map(int, input().split()) V = [] for _ in range(N): V.append(int(input())) dp = [[0]+([10001]*K) for _ in range(N+1)] for i in range(1, N+1): for j in range(1, K+1): if j &amp;gt;= V[i-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-V[i-1]]+1) else: dp[i][j] = dp[i-1][j] res = dp[N][K] print (res if res != 10001 else -1) dp를 많이 풀어보자</description></item><item><title>2565 : 전깃줄 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2565/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2565/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] L = [i[1] for i in sorted(L)] dp = [0]*N for i in range(N): dp[i] = 1 for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 이용하는 문제</description></item><item><title>2573 : 빙산 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2573/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2573/</guid><description>import copy from collections import deque N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] L[0][0] = 0 L[N-1][M-1] = 0 vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def melt(L): L_ = copy.deepcopy(L) for i in range(M): for j in range(N): if L[j][i] != 0: for k in range(4): nx = j + vx[k] ny = i + vy[k] if not 0 &amp;lt;= nx &amp;lt; N or not 0 &amp;lt;= ny &amp;lt; M: continue if L[nx][ny] == 0 and L_[j][i] !</description></item><item><title>2748 : 피보나치 수2 (B2)</title><link>https://bong-u.github.io/til/algorithm/boj_2748/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2748/</guid><description> &amp;ldquo;알고리즘 분류-DP&amp;quot;에서 안 푼 문제이길래 한 번 풀어봤다. N = int(input()) L = [0, 1] + [0]*89 for i in range(2, N+1): L[i] = L[i-1]+L[i-2] print (L[N])</description></item></channel></rss>
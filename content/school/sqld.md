---
title: "SQLD 대비 정리"
date: 2024-05-09
---

### 과목 1 : 데이터 모델링의 이해
#### 데이터 모델링을 할때 유의 사항
1. 중복 : 여러 장소에 같은 정보 X
2. 비유연성 : 데이터의 정의와 사용 프로세스를 분리 -> 데이터가 적게 변화되도록
3. 비일관성 : 데이터 간의 상호 연관관계를 명확히 정의

#### 데이터 모델링의 종류
1. 개념적 데이터 모델링
2. 물리적 데이터 모델링

#### 데이터 베이스 모델링의 특징
> 추상화, 단순화, 명확화

#### 데이터베이스 스키마의 구조
- 외부 스키마 : 사용자 관점의 데이터베이스 구조
- 개념 스키마 : 전체 데이터베이스의 논리적 구조
- 내부 스키마 : 물리적 저장장치에 대한 데이터베이스 구조

#### 엔터티의 특징
1. 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야한다.
2. 유일한 식별자에 의해 식별이 가능해야 한다.
3. 영속적으로 존재하는 인스턴스의 집합이어야 한다.
4. 엔터티는 업무 프로세스에 의해 이용 되어야 한다.
5. 엔터티는 반드시 속성이 있어야 한다.
6. 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.

#### 엔터티, 인스턴스, 속성, 속성값의 관계
- 한 개의 엔터티는 두 개 이상의 인스턴스로 구성
- 한 개의 엔터티는 두 개 이상의 속성을 갖는다
- 한 개의 속성은 한 개의 속성값을 갖는다

#### 속성의 분류
- 기본 속성 : 본래의 속성
- 설계 속성 : 데이터 모델링 과정에서 추가된 속성
- 파생 속성 : 다른 속성에 의해 만들어지는 속성

#### 관계의 표기법
- 관계명
- 관계차수
- 관계선택사양

#### 식별자의 종류
- 주식별자 vs 보조식별자
- 내부식별자 vs 외부식별자 (타 엔티티에서 받아옴)
- 단일식별자 (하나의 속성) vs 복합식별자 (둘 이상의 속성)
- 본질식별자 vs 인조식별자

#### 데이터 모델링의 순서
1. 데이터모델링을 할 때 정규화를 정확하게 수행한다.
2. 데이터베이스 용량산정을 수행한다.
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행 한다.
5. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.

#### 조인
1. Nested Loop Join
2. Single Loop Join
3. Sort Merge Join
4. Hash Join

#### 정규화
- 제 1 정규화
    > 각 열은 원자값만을 포함하고 있어야 한다.
- 제 2 정규화
    > 기본키가 복합키일 경우, 부분 함수 종속을 제거
- 제 3 정규화
    > 이행적 함수 종속을 제거
- BCNF
    > 결정자가 후보키가 아닌 함수 종속을 제거
- 제 4 정규화
    > 다치 종속을 제거

### 과목 2 : SQL 기본 및 활용

#### 순수 관계 연산자
> `SELECT`, `PROJECT`, `JOIN`, `DIVIDE`

#### SQL의 종류
- DDL : 데이터 정의어 : `CREATE`, `ALTER`, `DROP`, `TRUNCATE`
- DML : 데이터 조작어 : `SELECT`, `INSERT`, `UPDATE`, `DELETE`
- DCL : 데이터 제어어 : `GRANT`, `REVOKE`
- TCL : 트랜잭션 제어어 : `COMMIT`, `ROLLBACK`, `SAVEPOINT`

#### 집합 연산자
- `UNION` : 합집합
- `INTERSECT` : 교집합
- `UNION ALL` : 중복 포함 합집합
- `EXCEPT` : 차집합 (MS-SQL)
- `MINUS` : 차집합 (Oracle)

#### PRIOR문
- `PRIOR 자식 = 부모` : 부모->자식 순방향 전개
- `PRIOR 부모 = 자식` : 자식->부모 역방향 전개

#### 서브쿼리의 종류
1. 일반 서브쿼리 : 하나의 변수처럼 사용
  - SingleRow Subquery
  - MultieRow Subquery
  - MultieColumn Subquery
2. 인라인 뷰 (Inline View) : 뷰 형태로써 테이블을 리턴하는 서브쿼리. FROM 또는 JOIN절에 사용한다.
3. Scalar Subquery : 하나의 칼럼처럼 사용되는 서브쿼리.
* Correlative Subquery : 메인 쿼리의 값을 사용하는 서브쿼리.
즉 메인 쿼리의 결과로 서브쿼리가 실행되고 그 결과로 메인쿼리가 또 실행되는 서로 연관된 쿼리를 의미합니다.


#### 참조 동작
- Delete(/Modify) Action : Cascade, Set Null, Set Default, Restrict (부서-사원)
    1. Cascade : Master 삭제 시 Child 같이 삭제
    2. Set Null
    3. Set Default
    4. Restrict : Child 테이블에 PK 값이 없는 경우만 Master 삭제 허용 : 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음
    5. No Action
- Insert Action : Automatic, Set Null, Set Default, Dependent (부서-사원)
    1. Automatic : Master 테이블에 PK가 없는 경우 Master PK를 생성 후 Child 입력
    2. Set Null
    3. Set Default
    4. Dependent : 참조무결성을 위반하는 입력 액션을 취하지 않음
    5. No Action

#### 트랜잭션의 특성 (ACID)
- 원자성(Atomicity) : 트랜잭션은 성공 또는 실패로 끝나야 한다.
- 일관성(Consistency) : 트랜잭션은 일관성 있는 상태로 변환한다.
- 독립성(Isolation) : 트랜잭션은 다른 트랜잭션에 영향을 미치지 않는다.
- 지속성(Durability) : 트랜잭션이 성공하면 그 결과는 영구적으로 반영된다.

#### 단일행 NULL 관련 함수
- `NVL(a, b)` : a가 NULL이면 b를 반환 (Oracle)
- `ISNULL(a, b)` : a가 NULL이면 b를 반환 (MS-SQL)
- `NULLIF(a, b)` : a와 b가 같으면 NULL, 다르면 a를 반환
- `COALESCE(a, b, c)` : 첫번째 NULL이 아닌 값을 반환

#### SELECT문의 실행 순서
> `FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY`

#### 뷰
- 정의만을 가지고 있으며, 실행시점에 재작성되어 수행한다
- 독립성 : 테이블 구조가 변경되어도 응용 프로그램은 변경하지 않아도 된다
- 편리성 : 복잡한 질의를 뷰로 생성하여 단순하게 작성할 수 있다, 자주 사용하는 질의를 뷰로 생성하여 사용할 수 있다
- 보안성 : 사용자에게 필요한 데이터만 뷰로 제공할 수 있다

#### 집계 함수
- `ROLLUP` : 소그룹 간의 합계를 계산하는 함수 (첫번째 컬럼의 합계만 계산)
- `CUBE` : 모든 소그룹 간의 합계를 계산하는 함수
- `GROUPING SETS` : 특정 소그룹 간의 합계를 계산하는 함수

#### 순위 함수
- `RANK` : 동일한 값이 있을 경우 동일한 순위를 부여, 이후 중간 순위를 건너뛰고 순위를 부여
- `DENSE_RANK` : 동일한 값이 있을 경우 동일한 순위를 부여, 이후 중간 순위를 건너뛰지 않고 순차적으로 순위를 부여
- `ROW_NUMBER` : 동일한 값이 있을 경우 고유한 순위를 부여

#### 이전행, 다음행 함수
- `LAG` : 이전 행의 데이터를 가져옴
- `LEAD` : 다음 행의 데이터를 가져옴

#### 윈도우 함수
- `OVER` : 윈도우 함수를 사용할 때 사용하는 절
- `PARTITION BY` : 윈도우 함수를 적용할 때 그룹을 나누는 기준
- `ORDER BY` : 윈도우 함수를 적용할 때 정렬 기준

#### PL/SQL의 특징
- PL/SQL은 Block 구조로 되어있어 각 기능별로 모듈화가 가능하다.
- 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환한다.
- IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 한다.
- DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다.
- PL/SQL은 Oracle에 내장되어 있으므로 Oracle과 PL/SQL을 지원하는 어떤 서버로도 프로그램을 옮길 수 있다.
- PL/SQL은 응용 프로그램의 성능을 향상시킨다.
- PL/SQL은 여러 SQL 문장을 Block으로 묶고 한 번에 Block 전부를 서버로 보내기 때문에 통신량을 줄일 수 있다.

#### 프로시저와 트리거의 차이
| 프로시저 | 트리거 |
|---|---|
| CREATE PROCEDURE | CREATE TRIGGER |
| EXECUTE 명령어로 실행 | 트리거 조건에 의해 자동 실행 |
| COMMIT, ROLLBACK 가능 | COMMIT, ROLLBACK 불가능 |
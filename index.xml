<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bong-u's TIL on bong-u's TIL</title><link>https://bong-u.github.io/til-hugo/</link><description>Recent content in Bong-u's TIL on bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 02 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://bong-u.github.io/til-hugo/index.xml" rel="self" type="application/rss+xml"/><item><title>2502 : 떡 먹는 호랑이 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2502/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2502/</guid><description>D, K = map(int, input().split()) L = [(1, 0), (0, 1)] for i in range(2, D): L.append((L[i-2][0]+L[i-1][0], L[i-2][1]+L[i-1][1])) A = 1 B = 2 while True: if A*L[D-1][0] + B*L[D-1][1] == K: break if A+1 == B: B += 1 A = 1 else: A += 1 print (A,&amp;#39;\n&amp;#39;,B, sep=&amp;#39;&amp;#39;) 해결방법 N번째날 떡 개수를 구하기 위해 첫째날 떡, 둘째날 떡을 각각 몇번 더해야하는지 리스트에 구한다 첫째, 둘째 날 떡을 하나하나 넣어보면서 브루트 포스를 수행한다</description></item><item><title>13398 : 연속합 2 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_13398/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_13398/</guid><description>N = int(input()) L = list(map(int, input().split())) res = 0 dp = [[-1000]*N for _ in range(2)] dp[0][0] = L[0] for i in range(1, N): dp[0][i] = max(dp[0][i-1]+L[i], L[i]) dp[1][i] = max(dp[1][i-1]+L[i], dp[0][i-1]) print (max(max(dp[0]), max(dp[1]))) 이번 문제에서 사용할 dp 배열의 크기는 N X 2 이다. 배열은 최솟값인 -1000으로 초기화하여야 한다</description></item><item><title>15486 : 퇴사 2 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_15486/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_15486/</guid><description>import sys input = sys.stdin.readline N = int(input()) T = [] P = [] dp = [0]*(N+1) for _ in range(N): a, b = map(int, input().split()) T.append(a) P.append(b) for i in range(N-1, -1, -1): if i+T[i] &amp;gt; N: dp[i] = dp[i+1] else: dp[i] = max(P[i]+dp[i+T[i]], dp[i+1]) print (dp[0]) dp라는 변수를 만들어야하는데 안 만들고 리스트 P만 가지고 memoization 하려다 실패했다 점화식은 잘 적었으나 조건문이 잘 못되어서 다른 풀이를 참고했다</description></item><item><title>MVC 3 : Session, Interceptor, Cookies</title><link>https://bong-u.github.io/til-hugo/spring/13_mvc_3/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/13_mvc_3/</guid><description>Session 로그인 할 때 세션에 등록 LoginController.java @PostMapping public String submit(LoginCommand loginCommand, Errors errors, HttpSession session) { new LoginCommandValidator().validate(loginCommand, errors); if (errors.hasErrors()) { return &amp;#34;login/loginForm&amp;#34;; } try { AuthInfo authInfo = authService.authenticate(loginCommand.getEmail(), loginCommand.getPassword()); session.setAttribute(&amp;#34;authInfo&amp;#34;, authInfo); return &amp;#34;login/loginSuccess&amp;#34;; } catch (WrongIdPasswordException e) { errors.reject(&amp;#34;idPasswordNotMatching&amp;#34;); return &amp;#34;login/loginForm&amp;#34;; } } 로그아웃 할때 세션에서 삭제 LogoutController.java @RequestMapping(&amp;#34;/logout&amp;#34;) public String logout(HttpSession session) { session.invalidate(); return &amp;#34;redirect:/main&amp;#34;; } 로그인 상태 여부에 따라 다르게 보여주기 &amp;lt;c:if test=&amp;#34;${ empty authInfo }&amp;#34;&amp;gt; &amp;lt;p&amp;gt;환영합니다.</description></item><item><title>2631 : 줄세우기 (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2631/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2631/</guid><description>N = int(input()) L = [] for i in range(N): L.append(int(input())) dp = [1]*N for i in range(N): for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 활용한 문제이다 풀이 유도는 잘했으나 LIS가 헷갈려서 전에 풀었던 코드를 참고하였다</description></item><item><title>1915 : 가장 큰 정사각형 (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1915/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1915/</guid><description>N, M = map(int, input().split()) L = [list(map(int, input())) for _ in range(N)] dp = [[0]*(M+1) for _ in range(N+1)] result = 0 for i in range(1, N+1): for j in range(1, M+1): dp[i][j] = L[i-1][j-1] if L[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 result = max(result, dp[i][j]) for i in dp: print (i) print (result**2) 조금 시간이 걸렸지만 혼자 힘으로 풀었다 점화식은 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1이다. 모두 0이면 0, 하나라도 1이면 1이 답이라는 것을 생각해야 한다.</description></item><item><title>9252 : LCS 2 (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_9252/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_9252/</guid><description>S1 = list(input()) S2 = list(input()) N1 = len(S1)+1 N2 = len(S2)+1 dp = [[0]*(N1) for _ in range(N2)] for i in range(1, N2): for j in range(1, N1): if S2[i-1] == S1[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) i = N2-1 j = N1-1 print (dp[i][j]) if dp[i][j] == 0: exit() result = &amp;#39;&amp;#39; while True: if i==0 or j==0: break if dp[i][j] == dp[i-1][j]: i -= 1 elif dp[i][j] == dp[i][j-1]: j -= 1 else: result = S1[j-1] + result i -= 1 j -= 1 print (result) 점화식을 잘못 세웠었다 문자가 같은 경우에 max(dp[i-1][j], dp[i][j-1])+1이 아닌 dp[i-1][j-1]+1이다.</description></item><item><title>10942 : 팰린드롬? (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_10942/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_10942/</guid><description>import sys input = sys.stdin.readline N = int(input()) L = list(map(int, input().split())) dp = [[0]*N for _ in range(N)] for i in range(N): dp[i][i] = 1 if i &amp;lt; N-1 and L[i] == L[i+1]: dp[i][i+1] = 1 for i in range(N, -1, -1): for j in range(i+1, N): if dp[i+1][j-1] and L[i] == L[j]: dp[i][j] = 1 for i in range(int(input())): S, E = map(int, input().split()) print (dp[S-1][E-1]) 인터넷을 참고했다 쉽지 않은 문제였다</description></item><item><title>Generics</title><link>https://bong-u.github.io/til-hugo/java/generics/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/java/generics/</guid><description>효과 : 타입안정성, 간결한 코드 Generic class public class Box&amp;lt;M, I&amp;gt; { private M material; private I item; ... } Box&amp;lt;Paper, String&amp;gt; box = new Box&amp;lt;Paper, String&amp;gt;(); Generic Function public class CoffeeMachine { public &amp;lt;T&amp;gt; Coffee makeCoffee(T capsule) { return new Coffee(capsule); } } CoffeeMachine coffeeMachine = new CoffeeMachine(); Colombian capsule = new Colombian(); coffeeMachine.&amp;lt;Colombian&amp;gt;makeCoffee(capsule); coffeeMachine.makeCoffee(capsule); Restrictions on Generics // BoxMaterial을 상속 받았으면서 Hard(인터페이스)를 구현한 클래스만 가능 public class Box&amp;lt;M extends BoxMaterial &amp;amp; Hard&amp;gt; // BoxMaterial의 조상 클래스만 가능 public class Box&amp;lt;T super BoxMaterial&amp;gt; Whild Card // T와 그 자손만 가능 &amp;lt;?</description></item><item><title>MVC 2 : Messages, Validate command object</title><link>https://bong-u.github.io/til-hugo/spring/12_mvc_2/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/12_mvc_2/</guid><description>Messages label.properties member.register=회원가입 &amp;lt;%@ taglib prefix=&amp;#34;spring&amp;#34; uri=&amp;#34;http://www.springframework.org/tags&amp;#34; %&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;spring:message code=&amp;#34;member.register&amp;#34; /&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; 사이트가 여러 언어를 지원해야할 때 label_ko.properties, label_en.properties와 같이 만든다고 한다 http헤더의 Accept-Launguage를 자동으로 인식한다고 하니까 편할 것 같다 Validate command object Validation RegisterRequestValidator @Override public void validate(Object target, Errors errors) { RegisterRequest regReq = (RegisterRequest) target; if(regReq.getEmail() == null | regReq.getEmail().trim().isEmpty()) { errors.rejectValue(&amp;#34;email&amp;#34;, &amp;#34;bad&amp;#34;); } else { Matcher matcher = pattern.matcher(regReq.getEmail()); if(!</description></item><item><title>5582 : 공통 부분 문자열 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_5582/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_5582/</guid><description>S1 = list(input()) S2 = list(input()) L1 = len(S1)+1 L2 = len(S2)+1 dp = [[0]*L1 for _ in range(L2)] result = 0 for i in range(1, L2): for j in range(1, L1): if S1[j-1] == S2[i-1]: dp[i][j] = dp[i-1][j-1]+1 result = max(result, dp[i][j]) print (result) 혼자 힘으로 해결! 깔끔한 풀이가 나와 기분이 좋다</description></item><item><title>5557 : 1학년 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_5557/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_5557/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [[0]*21 for _ in range(N-1)] dp[0][L[0]] = 1 for i in range(0, N-2): for j in range(21): if dp[i][j] != 0: k = L[i+1] if k != 0: if 0 &amp;lt;= j+k &amp;lt;= 20: dp[i+1][j+k] += dp[i][j] if 0 &amp;lt;= j-k &amp;lt;= 20: dp[i+1][j-k] += dp[i][j] else: dp[i+1][j] = dp[i][j]*2 print (dp[N-2][L[-1]]) 혼자 힘으로 풀었다! 이전에 비슷한 dp 문제를 풀어본 적이 있어서 쉽게 풀 수 있었다</description></item><item><title>10164 : 격자상의 경로 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_10164/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_10164/</guid><description>N, M, K = map(int, input().split()) K -= 1 ox = K % M oy = K // M def solve(sx, sy, ex, ey): dp = [[0]*M for _ in range(N)] dp[sy][sx] = 1 for i in range(sy, ey+1): for j in range(sx, ex+1): if i-1 &amp;gt;= 0: dp[i][j] += dp[i-1][j] if j-1 &amp;gt;= 0: dp[i][j] += dp[i][j-1] return dp[ey][ex] if K != -1: print (solve(0, 0, ox, oy) * solve(ox, oy, M-1, N-1)) else: print (solve(0, 0, M-1, N-1)) 혼자 힘으로 해결하였다!</description></item><item><title>2011 : 암호코드 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2011/</link><pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2011/</guid><description>L = list(input()) N = len(L) MOD = 10**6 def solution(): if L[0] == &amp;#39;0&amp;#39;: return 0 dp = [1, 1]+[0]*(N-1) for i in range(2, N+1): if L[i-1] != &amp;#39;0&amp;#39;: dp[i] = (dp[i]+dp[i-1]) % MOD if 10 &amp;lt;= int(L[i-2]+L[i-1]) &amp;lt;= 26: dp[i] = (dp[i]+dp[i-2]) % MOD return dp[N] print (solution()) 인터넷을 참고하여 풀었다</description></item><item><title>1495 : 기타리스트 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1495/</link><pubDate>Fri, 27 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1495/</guid><description>N, S, M = map(int, input().split()) P = list(map(int, input().split())) dp = [[False]*(M+1) for _ in range(N+1)] dp[0][S] = True for i in range(1, N+1): for j in range(M+1): if dp[i-1][j]: if 0 &amp;lt;= j-P[i-1] &amp;lt;= M: dp[i][j-P[i-1]] = True if 0 &amp;lt;= j+P[i-1] &amp;lt;= M: dp[i][j+P[i-1]] = True result = -1 for i in range(M+1): if dp[N][i]: result = i print (result) 인터넷에서 접근을 참고했다</description></item><item><title>16194 : 카드 구매하기 2 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_16194/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_16194/</guid><description>N = int(input()) P = list(map(int, input().split())) dp = [10000000]*(N) for i in range(N): for j in range(i): dp[i] = min(dp[i], dp[j]+P[i-j-1]) dp[i] = min(dp[i], P[i]) print (dp[N-1])</description></item><item><title>1965 : 상자넣기 (S2)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1965/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1965/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [0]*N for i in range(1, N): for j in range(i): if L[j]&amp;lt;L[i] and dp[i]&amp;lt;dp[j]+1: dp[i] = dp[j]+1 print(max(dp)+1) LIS를 구하는 문제이다</description></item><item><title>17070 : 파이프 옮기기 1 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_17070/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_17070/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 0 def dfs(x, y, direc): global result if x == N-1 and y == N-1: result += 1 return if x+1 &amp;lt; N and y+1 &amp;lt; N and L[y+1][x] == 0 and L[y][x+1] == 0 and L[y+1][x+1] == 0: dfs(x+1, y+1, 2) if (direc == 0 or direc == 2) and x+1 &amp;lt; N and L[y][x+1] == 0: dfs(x+1, y, 0) if (direc == 1 or direc == 2) and y+1 &amp;lt; N and L[y+1][x] == 0: dfs(x, y+1, 1) dfs(1, 0, 0) print(result) 별거 아닌게.</description></item><item><title>React: deploy</title><link>https://bong-u.github.io/til-hugo/javascript/react_deploy/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/javascript/react_deploy/</guid><description>build 결과물을 돌리면 빈 화면만 나오는 문제 static files 로딩에 성공했는지 확인하자 문제가 있다면 index.html의 경로를 수정하자 react-router를 사용하고 있다면 url을 확인하자 deploy할때 root url이 아니라면 router에 basename을 추가해줘야한다. &amp;lt;Router basename=&amp;#34;/index&amp;#34;&amp;gt;...&amp;lt;/Router&amp;gt;</description></item><item><title>React: environment variable</title><link>https://bong-u.github.io/til-hugo/javascript/react_env_var/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/javascript/react_env_var/</guid><description> 프로그램이 개발/배포 상황에 따라 변수를 달리해야 할 때가 있다. 이때 react에서는 .env.development , .env.production 파일을 만들어서 환경변수를 쉽게 관리할 수 있다. react는 앞에 &amp;lsquo;REACT_APP&amp;rsquo; 을 붙여야 인식이 된다고한다. 설정 .env.development REACT_APP_HOST=localhost .env.production REACT_APP_HOST=192.168.0.1 사용 ${process.env.REACT_APP_HOST}</description></item><item><title>React: useEffect</title><link>https://bong-u.github.io/til-hugo/javascript/react_useeffect/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/javascript/react_useeffect/</guid><description> component가 rendering 될 때 실행 useEffect(()=&amp;gt; { ... }); component가 mount 될 때 (처음 rendering 될 때) 실행 useEffect(()=&amp;gt; { ... }, []); component가 update 될 때 (props, states가 바뀔 때) 실행 useEffect(()=&amp;gt; { ... }, [{ props or states }]); component가 unmount 될 때 또는 update되기 직전에 실행 useEffect(()=&amp;gt; { return () =&amp;gt; { ... }; }, []);</description></item><item><title>12852 : 1로 만들기 2 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_12852/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_12852/</guid><description>N = int(input()) dp = [0, 0] + [10**6]*(N-1) bt = [0]*(N+1) for i in range(2, N+1): dp[i] = min(dp[i-1]+1, dp[i]) bt[i] = i-1 if i%3 == 0: if dp[i//3]+1 &amp;lt; dp[i]: dp[i] = dp[i//3]+1 bt[i] = i//3 if i%2 == 0: if dp[i//2]+1 &amp;lt; dp[i]: dp[i] = dp[i//2]+1 bt[i] = i//2 dp[i] = min(dp[i], dp[i//2]+1) print(dp[N]다 i = N while i != 1: print (i, end=&amp;#39; &amp;#39;) i = bt[i] print (1) dp 아직 많이 멀었다는 생각이 든다</description></item><item><title>JS: Sort</title><link>https://bong-u.github.io/til-hugo/javascript/sort/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/javascript/sort/</guid><description>Table에 있는 데이터들을 column별로 정렬해야 한다 데이터의 형식에 따라 comparator를 따로 구현하였다 const comparatorStr = (a, b, order) =&amp;gt; { if (order === Order.ASC) return a.localeCompare(b); return b.localeCompare(a); }; const comparatorInt = (a, b, order) =&amp;gt; { if (order === Order.ASC) return a &amp;gt; b ? 1 : -1; return a &amp;lt; b ? 1 : -1; }; 정렬할 키나 순서가 바뀔때 마다 정렬을 수행한다 useEffect(() =&amp;gt; { if (sortBy === Key.</description></item><item><title>MVC 1 : Request Mapping, Command Object, Redirect, Form Tag, Model</title><link>https://bong-u.github.io/til-hugo/spring/11_mvc_1/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/11_mvc_1/</guid><description>Request Mapping GetMapping/PostMapping으로 처리할 method를 지정하거나 RequestMapping을 사용할 수 있다. Access request parameter : HttpServletRequest @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2(HttpServletRequest request) { String agreeParam = request.getParameter(&amp;#34;agree&amp;#34;); if (agreeParam == null || !agreeParam.equals(&amp;#34;true&amp;#34;)) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Access request parameter : RequestParam Annotation @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2( @RequestParam(value=&amp;#34;agree&amp;#34;, defaultValue=&amp;#34;false&amp;#34;) Boolean agree) { if (!agree) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Redirect @GetMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2Get() { return &amp;#34;redirect:/register/step1&amp;#34;; Command Object Use request parameter as command object RegisterController.</description></item><item><title>2096 : 내려가기 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2096/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2096/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp1 = [L[0][i] for i in range(3)] dp2 = [L[0][i] for i in range(3)] for i in range(1, N): tmp1 = [0]*3 tmp2 = [0]*3 for j in range(3): if j == 0: tmp1[0] = L[i][j] + max(dp1[0], dp1[1]) tmp2[0] = L[i][j] + min(dp2[0], dp2[1]) elif j == 1: tmp1[1] = L[i][j] + max(dp1[0], dp1[1], dp1[2]) tmp2[1] = L[i][j] + min(dp2[0], dp2[1], dp2[2]) else: tmp1[2] = L[i][j] + max(dp1[1], dp1[2]) tmp2[2] = L[i][j] + min(dp2[1], dp2[2]) dp1 = [i for i in tmp1] dp2 = [i for i in tmp2] print (max(dp1), min(dp2)) Memoization과정이 다른 memoization 변수에 대해 종속적이라면 잘못된 결과를 초래한다 위 코드에서는 이를 방지하기 위해 tmp1, tmp2 변수를 사용한다 깊이 생각하지 않고 여러 번 제출해서 WA개수가 조금 많다;;</description></item><item><title>1890 : 점프 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1890/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1890/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp = [[0]*N for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(N): if L[i][j] == 0: continue if dp[i][j] != 0: right = j+L[i][j] bottom = i+L[i][j] if right &amp;lt; N: dp[i][right] += dp[i][j] if bottom &amp;lt; N: dp[bottom][j] += dp[i][j] print (dp[N-1][N-1]) dp에 있는 값을 더해야하는데 1을 더해서 몇 번 틀렸다 거의 혼자 힘으로 풀었다</description></item><item><title>1309 : 동물원 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1309/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1309/</guid><description>N = int(input()) dp = [1, 3] + [0]*(N-1) for i in range(2, N+1): dp[i] = (dp[i-1]*2 + dp[i-2]) % 9901 print(dp[N]) 고민 끝에 답을 찾아보긴 했다 점화식 생각해내는 놈들 머리에 뭐가 든건지 모르겠다</description></item><item><title>9655 : 돌게임 (S5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_9655/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_9655/</guid><description>N = int(input()) print (&amp;#39;CY&amp;#39; if N%2==0 else &amp;#39;SK&amp;#39;) 게임이론에서 기초 중 기초 문제이다</description></item><item><title>08_connect_DB</title><link>https://bong-u.github.io/til-hugo/spring/08_connect_db/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/08_connect_db/</guid><description>DataSource 설정 AppCtx.java @Bean(destroyMethod = &amp;#34;close&amp;#34;) public DataSource dataSource() { DataSource ds = new DataSource(); ds.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); ds.setUrl(&amp;#34;jdbc:mysql://localhost/spring5fs?&amp;#34;+ &amp;#34;enabledTLSProtocols=TLSv1.2&amp;amp;&amp;#34;+ &amp;#34;useSSL=false&amp;amp;&amp;#34;+ &amp;#34;characterEncoding=utf8&amp;#34;); ds.setUsername(&amp;#34;spring5&amp;#34;); ds.setPassword(&amp;#34;spring5&amp;#34;); ds.setInitialSize(2); ds.setMaxActive(10); ds.setTestWhileIdle(true); ds.setMinEvictableIdleTimeMillis(60000 * 3); ds.setTimeBetweenEvictionRunsMillis(10 * 1000); return ds; } Query 실행 JdbcTemplate을 이용한 select jdbcTemplate.query( &amp;#34;select * from MEMBER where EMAIL = ?&amp;#34;, new RowMapper&amp;lt;Member&amp;gt;() { @Override public Member mapRow(ResultSet rs, int rowNum) throws SQLException { Member member = new Member( rs.getString(&amp;#34;EMAIL&amp;#34;), rs.getString(&amp;#34;PASSWORD&amp;#34;), rs.</description></item><item><title>07_AOP</title><link>https://bong-u.github.io/til-hugo/spring/07_aop/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/07_aop/</guid><description>AOP (Aspect Oriented Programming) 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법 기본 개념 : 핵심 기능에 공통 기능을 삽입 이를 구현하는 3가지 방법 컴파일 시점에 코드에 공통 기능을 삽입하는 방법 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법 주요 용어 Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지 Joinpoint : Advice를 적용 가능한 지점 Pointcut : Joinpoint의 부분 집합으로서 실제 Advice가 적용되는 Joinpoint를 나타낸다 Weaving : Advice를 핵심 로직 코드에 적용하는 것 Aspect : 여러 객체에 공통으로 적용되는 기능 Spring AOP 구현 MainAspect.</description></item><item><title>1010 : 다리놓기 (S5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1010/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1010/</guid><description>import math for _ in range(int(input())): a, b = map(int, input().split()) print(math.comb(max(a,b), min(a,b)))</description></item><item><title>10844 : 쉬운 계단 수 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_10844/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_10844/</guid><description> 접근이 어려워 인터넷을 참고했다. 코드는 보지 않았다. 수의 길이가 i이면서 마지막 숫자가 j인 계단 수의 개수를 저장하는 것이 핵심이다. 점화식은 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 이다. N = int(input()) L = [[0]*12 for _ in range(100)] L[0] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] for i in range(1, N): for j in range(1, 11): L[i][j] = L[i-1][j-1]+L[i-1][j+1] print (sum(L[N-1])%1000000000)</description></item><item><title>11048 : 이동하기 (S2)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_11048/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_11048/</guid><description>N, M = map(int, input().split()) dp = [list(map(int, input().split())) for _ in range(N)] for i in range(1, N): dp[i][0] = dp[i][0]+dp[i-1][0] for i in range(1, M): dp[0][i] = dp[0][i]+dp[0][i-1] for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i][j]+max(dp[i-1][j], dp[i][j-1]) print (dp[N-1][M-1])</description></item><item><title>11051 : 이항계수2 (S2)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_11051/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_11051/</guid><description> 내장 함수 사용
import math N, K = map(int, input().split()) print (math.comb(N, K)%10007 파스칼의 사각형? dp 구현
N, K = map(int, input().split()) if K == 0: print(1) exit() dp = [[0]*N for _ in range(K)] for i in range(N): dp[0][i] = i+1 for i in range(1, K): for j in range(i, N): dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % 10007 print (dp[K-1][N-1])</description></item><item><title>11052 : 카드 구매하기 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_11052/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_11052/</guid><description>N = int(input()) P = list(map(int, input().split())) D = [P[0]]+[0]*(N-1) for i in range(1, N): for j in range(1, i+1): D[i] = max(D[i-j]+P[j-1], D[i]) D[i] = max(P[i], D[i]) print (D[N-1]</description></item><item><title>11057 : 오르막 수 (S1)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_11057/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_11057/</guid><description>N = int(input()) dp = [[1]+[0]*9 for _ in range(N+1)] for i in range(1, N+1): for j in range(1, 10): dp[i][j] = dp[i-1][j]+dp[i][j-1] print (sum(dp[N])%10007)</description></item><item><title>14891 : 톱니바퀴 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_14891/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_14891/</guid><description>from collections import deque wheels = [deque(map(int, list(input()))) for _ in range(4)] def rotate(wheel, direction): if direction == 1: wheel.appendleft(wheel.pop()) else: wheel.append(wheel.popleft()) return wheel K = int(input()) vd = [1, -1] res = 0 for _ in range(K): N, D = map(int, input().split()) q = deque() q.append((N-1, D)) visited = [False] * 4 tmp = [] while q: cur, curD = q.popleft() tmp.append((cur, curD)) visited[cur] = True for v in vd: nxt = cur+v if 0 &amp;lt;= nxt &amp;lt; 4 and not visited[nxt]: if (v == -1 and wheels[cur][6] !</description></item><item><title>15683 : 감시 (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_15683/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_15683/</guid><description>import copy, sys N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] cctv = [] direction = [[[(0, 1)], [(0, -1)], [(1, 0)], [(-1, 0)]], [[(-1, 0), (1, 0)], [(0, -1), (0, 1)]], [[(-1, 0), (0, -1)], [(0, -1), (1, 0)], [(1, 0), (0, 1)], [(0, 1), (-1, 0)]], [[(-1, 0), (0, -1), (1, 0)], [(0, -1), (1, 0), (0, 1)], [(1, 0), (0, 1), (-1, 0)], [(0, 1), (-1, 0), (0, -1)]], [[(-1, 0), (0, -1), (1, 0), (0, 1)]]] res = sys.</description></item><item><title>1699 : 제곱수의 합 (S2)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_1699/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_1699/</guid><description>N = int(input()) dp = [100000]*(N+1) tmp = 1 for i in range(1, N+1): if i**(1/2) % 1 == 0: dp[i] = 1 tmp += 1 else: for j in range(1, tmp): dp[i] = min(dp[i], dp[i-(j**2)]+1) print (dp[N])</description></item><item><title>17404 : RGB거리 2 (G4)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_17404/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_17404/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 100000 for i in range(3): dp = [[0, 0, 0] for _ in range(N)] dp[0] = [10000]*3 dp[0][i] = L[0][i] for j in range(1, N): dp[j][0] = min(dp[j-1][1], dp[j-1][2])+L[j][0] dp[j][1] = min(dp[j-1][0], dp[j-1][2])+L[j][1] dp[j][2] = min(dp[j-1][0], dp[j-1][1])+L[j][2] dp[N-1][i] = 100000 result = min([result]+dp[N-1]) print (result) 인터넷을 참고하여 풀었다
첫째집 3가지 X 마지막집 3가지 = 9가지 이지만</description></item><item><title>2193 : 이친수 (S3)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2193/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2193/</guid><description>N = int(input()) dp = [1]*N for i in range(2, N): dp[i] = dp[i-2]+dp[i-1] print (dp[N-1]) 피보나치였다</description></item><item><title>221207 SYSP</title><link>https://bong-u.github.io/til-hugo/school/sysp_09_11/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/school/sysp_09_11/</guid><description>목차 09 - process 1 10 - process 2 11 - signal 09-process1 예외적인 제어 흐름 하위 매커니즘 예외 (Exception) 상위 매커니즘 프로세스 컨텍스트 전환 OS 소프트웨어와 하드웨어 타이머로 구현 시그널 OS 소프트웨어로 구현 nolocal 점프 예외 테이블 (Exception Tables) 각 이벤트 타입은 예외번호 k를 갖는다 비동기형 예외 (Interrupt) 입출력 인터럽트 (ctrl + c)</description></item><item><title>221208 SYSP</title><link>https://bong-u.github.io/til-hugo/school/sysp_12_13/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/school/sysp_12_13/</guid><description>목차 12 - memory 1 13 - memory 2 12-memory-1 메모리에 관한 불편한 진실 메모리는 무한의 자원이 아니다 동적 메모리 할당 직접(explicit) vs 간접(implicit) 메모리 할당기 직접 할당 : 응용프로그램이 할당하고, 반환한다 ex) malloc, free 간접 할당 : 응용프로그램이 할당하지만, 반환하지는 않는다 ex) java의 garbage collector 프로세스의 메모리 이미지 스택은 아래로, 힙은 위로 성장한다 sbrk 함수가 추가적인 힙 메모리를 운영체제로부터 요청한다 (brk 포인터 이동) Malloc package #include &amp;lt;stdlib.</description></item><item><title>2225 - 합분해 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2225/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2225/</guid><description>N, K = map(int, input().split()) dp = [[0]*(N+1) for _ in range(K+1)] for i in range(1, K+1): dp[i][0] = 1 for i in range(1, K+1): for j in range(1, N+1): dp[i][j] = (dp[i-1][j] + dp[i][j-1])%1000000000 print (dp[K][N]) 내 힘으로 풀었다!</description></item><item><title>2294 : 동전 2 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2294/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2294/</guid><description>N, K = map(int, input().split()) V = [] for _ in range(N): V.append(int(input())) dp = [[0]+([10001]*K) for _ in range(N+1)] for i in range(1, N+1): for j in range(1, K+1): if j &amp;gt;= V[i-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-V[i-1]]+1) else: dp[i][j] = dp[i-1][j] res = dp[N][K] print (res if res != 10001 else -1) dp를 많이 풀어보자</description></item><item><title>2565 : 전깃줄 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2565/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2565/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] L = [i[1] for i in sorted(L)] dp = [0]*N for i in range(N): dp[i] = 1 for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 이용하는 문제</description></item><item><title>2573 : 빙산 (G5)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2573/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2573/</guid><description>import copy from collections import deque N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] L[0][0] = 0 L[N-1][M-1] = 0 vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def melt(L): L_ = copy.deepcopy(L) for i in range(M): for j in range(N): if L[j][i] != 0: for k in range(4): nx = j + vx[k] ny = i + vy[k] if not 0 &amp;lt;= nx &amp;lt; N or not 0 &amp;lt;= ny &amp;lt; M: continue if L[nx][ny] == 0 and L_[j][i] !</description></item><item><title>2748 : 피보나치 수2 (B2)</title><link>https://bong-u.github.io/til-hugo/algorithm/boj_2748/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/algorithm/boj_2748/</guid><description> &amp;ldquo;알고리즘 분류-DP&amp;quot;에서 안 푼 문제이길래 한 번 풀어봤다. N = int(input()) L = [0, 1] + [0]*89 for i in range(2, N+1): L[i] = L[i-1]+L[i-2] print (L[N])</description></item><item><title>객체지향설계</title><link>https://bong-u.github.io/til-hugo/school/ood/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/school/ood/</guid><description>Dynamic dispatch and Multiple inheritance Polymorphism Function overloading using compile time types of arguments Function overriding using runtime types of receiver objects virtual function for dynamic dispatch dynamic dispatch를 사용하기 위한 조건
함수가 virtual keyword로 정의되어 있어야 한다.
receiver object가 포인터(*), 참조(&amp;amp;)를 통해 refer되어야 한다
// from parent class : Employee virtual std::string GetInfo() { return &amp;#34;Employee: &amp;#34; + name_ ; } // from child class : Developer std::string GetInfo() { return &amp;#34;Developer: &amp;#34; + name_; } override keyword override 키워드를 사용하는 이유 직관적인 코드</description></item><item><title>현대인의 생활문화</title><link>https://bong-u.github.io/til-hugo/school/mplc/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/school/mplc/</guid><description>목차 1. 글로벌 매너 2. 소개와 인사1 3. 소개와 인사2 4. 세계 각 국의 인사법 5. 명함매너 6. 사교매너 방문 접대 임신 출산 7. 경조사 생일 결혼 8. 경조사 장례 9. 경조사 제례 10. 청탁금지법 11. 저작권법 12. 직장매너 13. 20대 자산형성 14. 재무목표 설정 방법 15. 블랙 컨슈머 16. 사회적 기업 17. 커뮤니케이션 매너 18. 음주매너1 19. 음주매너2 20. 흡연매너 21. 한국음식 22. 글로벌전통음식 : 브라질, 중국 23. 글로벌전통음국 : 프랑스 글로벌 매너 매너 인간관계를 맺는데 있어 중요한 요소</description></item><item><title>03_DI</title><link>https://bong-u.github.io/til-hugo/spring/03_di/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/03_di/</guid><description>의존 주입 (DI : Dependency Injection)을 하는 방법 Assembler라는 별도의 클래스 생성
public class Assembler { private MemberDao memberDao; private MemberRegisterService regSvc; public Assembler() { memberDao = new MemberDao(); regSvc = new MemberRegisterService(memberDao); } public MemberDao getMemberDao() { return memberDao; } public MemberRegisterService getMemberRegisterService() { return regSvc; } } Spring에서 지원하는 DI 사용
@Configuration public class AppCtx { @Bean public MemberDao memberDao() { return new MemberDao(); } @Bean public MemberRegisterService memberRegSvc() { return new MemberRegisterService(memberDao()); } } DI방식 Constructor 방식 @Bean public MemberListPrinter listPrinter() { return new MemberListPrinter(memberDao(), memberPrinter()); } Setter method 방식 @Bean public MemberInfoPrinter infoPrinter() { MemberInfoPrinter infoPrinter = new MemberInfoPrinter(); infoPrinter.</description></item><item><title>04_DI_automatic</title><link>https://bong-u.github.io/til-hugo/spring/04_di_automatic/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/04_di_automatic/</guid><description>Maven project 만들기 복습 pom.xml을 만든다. 프로젝트 구조를 만든다 구조는 프로젝트폴더/src/main/java/패키지/클래스 이다. eclipse에서 import maven project로 Maven dependencies를 인식시킨다 @Autowired를 이용한 자동 객체 주입 방법1 : Field에 적용
public class MemberListPrinter { @Autowired private MemberDao memberDao; @Autowired private MemberPrinter printer; public MemberListPrinter() {} public void printAll() { Collection&amp;lt;Member&amp;gt; members = memberDao.selectAll(); members.forEach(m -&amp;gt; printer.print(m)); } } 방법2 : Method에 적용
public class MemberListPrinter { private MemberDao memberDao; private MemberPrinter printer; public MemberListPrinter() {} @Autowired public void setMemberDao(MemberDao memberDao) { this.</description></item><item><title>05_bean_lifecycle_scope</title><link>https://bong-u.github.io/til-hugo/spring/06_bean_lifecycle_scope/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/06_bean_lifecycle_scope/</guid><description>빈 객체의 lifecycle InitializingBean, DisposableBean 상속받기 public class Client implements InitializingBean, DisposableBean { @Override public void afterPropertiesSet() throws Exception {...} @Override public void destroy() throws Exception {...} } 두 인터페이스 구현을 통해 빈 객체의 생성과 소멸에 원하는 일을 수행할 수 있다 Custom Method @Bean(initMethod = &amp;#34;connect&amp;#34;, destroyMethod=&amp;#34;close&amp;#34;) public class Client2{ public void connect() {...} public void close() {...} } 인터페이스 구현하기 싫거나 외부에서 제공받은 클래스를 사용할 때 위와 같이 구현한다 빈 객체의 Scope 기본적으로 빈 객체는 Singleton scope를 갖는다 하지만 임의로 Prototype scope를 갖게 할 수 있다.</description></item><item><title>05_Component_scan</title><link>https://bong-u.github.io/til-hugo/spring/05_component_scan/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/05_component_scan/</guid><description>@Component scan Component Scan은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다
AppCtx.java
@Configuration @ComponentScan(basePackages = {&amp;#34;spring&amp;#34;}) public class AppCtx {...} MemberInfoPrinter.java @Component(&amp;#34;infoPrinter&amp;#34;) public class MemberInfoPrinter {...} 효과 // before MemberInfoPrinter infoPrinter = ctx.getBean(&amp;#34;infoPrinter&amp;#34;, MemberInfoPrinter.class); // after MemberInfoPrinter infoPrinter = ctx.getBean(MemberInfoPrinter.class);</description></item><item><title>09_spring_MVC</title><link>https://bong-u.github.io/til-hugo/spring/09_spring_mvc/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til-hugo/spring/09_spring_mvc/</guid><description>Spring MVC 시작하기 프로젝트 생성 앞에서 만들었던 자바 애플리케이션과는 좀 다른점이 있었다 jar이 아닌 war을 사용하는 등 여러가지 많았는데 일일이 적지는 않을 것이다 Controller @Controller public class HelloController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(Model model, @RequestParam(value=&amp;#34;name&amp;#34;, required=false) String name) { model.addAttribute(&amp;#34;greeting&amp;#34;, &amp;#34;안녕하세요&amp;#34; + name); return &amp;#34;hello&amp;#34;; } } JSP &amp;lt;%@ page contentType=&amp;#34;text/html; charset=utf-8&amp;#34; %&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 인사말 : ${greeting} &amp;lt;/body&amp;gt; &amp;lt;/html URL접속해도 해당 jsp파일이 나오지 않는 문제 vscode에서 community server connector라는 extension을 통해 tomcat을 띄워서 할려고 한다 특정 jsp를 감지했는지, serving하는지에 대한 로그가 없어 되는건지 알 수가 없다 web.</description></item></channel></rss>
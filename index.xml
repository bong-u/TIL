<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bong-u's TIL</title><link>https://bong-u.github.io/til/</link><description>Recent content on Bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 02 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://bong-u.github.io/til/index.xml" rel="self" type="application/rss+xml"/><item><title>Method reference (메소드 참조)</title><link>https://bong-u.github.io/til/java/method_reference/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/method_reference/</guid><description>메소드 참조 메소드 참조는 Java 8부터 도입되었다 lambda와 같이 사용하면 간결한 코드를 만들 수 있다 정적 메소드 참조의 문법 // lambda 식 (str) -&amp;gt; String.toString(str); // 정적 메소드 참조 String::toString 인스턴스 메소드 참조의 문법 Person person; // lambda 식 (age) -&amp;gt; person.setAge(); // 인스턴스 메소드 참조 person::setAge 활용 // lambda식 getItems.forEach(item -&amp;gt; System.out.println(item)); // 메소드 참조 getItems.forEach(System.out::println);</description></item><item><title>프로그래머스 - 귤 고르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>def solution(k, tangerine): D = {} for i in tangerine: if i in D: D[i] += 1 else: D[i] = 1 D = sorted(D.items(), key=lambda x: -x[1]) answer = 0 for _, num in D: k -= num answer += 1 if k &amp;lt;= 0: break return answer 문제 귤의 개수 k와 귤의 개수를 담은 배열 tangerine이 주어진다 귤 k개를 고를 때, 크기가 서로 다른 종류의 수의 최소값을 구하라 TC input k: 6, tangerine: [1, 3, 2, 5, 4, 5, 2, 3]</description></item><item><title>Spring - ResponseEntity 정리</title><link>https://bong-u.github.io/til/spring/responseentity/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/responseentity/</guid><description>ResponseEntity Spring에서 HttpEntity라는 클래스를 지원한다 HttpEntity를 상속받는 두 클래스가 RequestEntity와 ResponseEntity이다 RequestEntity는 http요청을 보낼때 사용하고 ResponseEntity는 http응답을 할때 사용한다 정의 body, header, status를 인자로 넘길 수 있다 public class ResponseEntity&amp;lt;T&amp;gt; extends HttpEntity&amp;lt;T&amp;gt; { public ResponseEntity(HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, HttpStatusCode status) {...} public ResponseEntity(MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, @Nullable MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, @Nullable MultiValueMap&amp;lt;String, String&amp;gt; headers, int rawStatus) {.</description></item><item><title>프로그래머스 - 점 찍기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</guid><description>import math def solution(k, d): answer = 0 for x in range(0, d+1, k): a = math.floor((d**2-x**2)**0.5) // k + 1 answer += a return answer 문제 2차원 좌표 평면에서 (xk (x=0,1,2,3&amp;hellip;), yk (y=0,1,2,3&amp;hellip;)) 지점에 점을 찍는다 원점과의 거리가 d가 넘으면 점을 찍지 않는다 k와 d가 주어질 때, 점이 총 몇 개 찍히는지 구하라 TC input k:2, d:4
ouput 6
해결방법 반지름이 d인 원안에 (k의 배수, k의 배수)점을 몇 개 찍을 수 있는지 구했다</description></item><item><title>[모각코] 04 : 결과</title><link>https://bong-u.github.io/til/mogako23/mogako04/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako04/</guid><description>1. 프로그래머스 한 문제 풀기 🧠 프로그래머스 - 디펜스 게임 (L2) 2023-07-26 Algorithm
import heapq def solution(n, k, enemy): heap = [] cnt = 0 for i in enemy: n -= i heapq.heappush(heap, -i) while n &amp;amp;lt; 0: k -= 1 if not heap or k &amp;amp;lt; 0: return cnt tmp = -heapq.heappop(heap) n &amp;#43;= tmp cnt &amp;#43;= 1 return cnt 문제 n: 가지고 있는 병사 수 k: 사용할 수 있는 무적권 스킬 수 enemy: 라운드마다 존재하는 적 수의 배열 라운드마다 enemy[i 2.</description></item><item><title>[모각코] 04 : 계획</title><link>https://bong-u.github.io/til/mogako23/mogako04_plan/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako04_plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 @RestController 정리</description></item><item><title>Spring - @RestController 정리</title><link>https://bong-u.github.io/til/spring/restcontroller/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/restcontroller/</guid><description>@RestController @Controller와 @ResponseBody를 합친 Annotation이다 @Controller는 ViewName을 반환해서 DispatcherServlet이 ViewResolver을 사용한다 @RestController는 객체를 반환해서 HttpMessageConverter가 객체를 Json으로 변환한다 @Controller와의 코드 비교 @Controller @GetMapping(&amp;#34;&amp;#34;) public @ResponseBody List&amp;lt;Voucher&amp;gt; getVouchers() { return voucherRepository.list(); } @RestController @GetMapping(&amp;#34;&amp;#34;) public List&amp;lt;Voucher&amp;gt; getVouchers() { return voucherRepository.list(); } @RestControllerAdvice @ControllerAdvice와 같이 @Controller에서 발생한 예외를 전역적으로 처리하는 Annotation이다 @ControllerAdvice와 @RestControllerAdvice의 차이는 @Controller와 @RestController의 차이와 같다 예제 - @RestControllerAdvice 구현 필자는 Controller에서 발생한 IllegalArgumentException을 400 Bad Request로 처리하였다 @RestControllerAdvice public class ControllerExceptionHandler { @ExceptionHandler(IllegalArgumentException.</description></item><item><title>프로그래머스 - 디펜스 게임 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</guid><description>import heapq def solution(n, k, enemy): heap = [] cnt = 0 for i in enemy: n -= i heapq.heappush(heap, -i) while n &amp;lt; 0: k -= 1 if not heap or k &amp;lt; 0: return cnt tmp = -heapq.heappop(heap) n += tmp cnt += 1 return cnt 문제 n: 가지고 있는 병사 수 k: 사용할 수 있는 무적권 스킬 수 enemy: 라운드마다 존재하는 적 수의 배열 라운드마다 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있다 무적권을 적절히 사용하여 버틸 수 있는 최대 라운드 수를 구하라 TC input n: 7, k: 3, enemy: [4, 2, 4, 5, 3, 3, 1]</description></item><item><title>Spring 개념 - POJO, DAO, DTO, VO, Entity</title><link>https://bong-u.github.io/til/spring/object/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/object/</guid><description>Spring의 여러 객체들 여기저기서 들어봤지만 개념이 머리에 정리되지 않아 기술한다 POJO (Plain Old Java Object) 특정 기술에 종속되지 않는 순수한 자바 객체
기본 생성자를 가진다 아무것도 상속받거나, 구현하지 않아야 한다 getter랑 setter만 존재 해야한다 public class Person { private String name; private int age; public Person() { } public String getName() { return name; } public int getAge() { return age; } public void setName(String name) { this.</description></item><item><title>프로그래머스 - 테이블 해시 함수 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</guid><description>def solution(data, col, row_begin, row_end): answer = 0 data.sort(key=lambda x: (x[col-1], -x[0])) s = [] for i in range(row_begin-1, row_end): s.append(sum(map(lambda x: x%(i+1), data[i]))) for i in s: answer ^= i return answer 문제 해시 함수는 col, row_begin, row_end을 입력으로 받는다 테이블의 튜플을 col번째 컬럼의 값을 기준으로 오름차순 정렬을 하되, 만약 그 값이 동일하면 기본키인 첫 번째 컬럼의 값을 기준으로 내림차순 정렬한다 정렬된 데이터에서 S_i를 i 번째 행의 튜플에 대해 각 컬럼의 값을 i 로 나눈 나머지들의 합으로 정의한다 row_begin ≤ i ≤ row_end 인 모든 S_i를 누적하여 bitwise XOR 한 값을 해시 값으로서 반환하라 TC input data: [[2,2,6],[1,5,10],[4,2,9],[3,8,3]]</description></item><item><title>프로그래머스 - 마법의 엘리베이터 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</link><pubDate>Mon, 24 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</guid><description>첫번째 BFS 풀이 from collections import deque def solution(storey): answer = 0 q = deque() q.append((storey, 0)) visited = [False] * (10**8+1) while q: cur, cnt = q.popleft() visited[cur] = True while cur != 0 and cur%10 == 0: cur = cur // 10 if cur == 0: answer = cnt break for j in [-1, 1]: dest = cur + j if 0 &amp;lt;= dest &amp;lt;= 10**8 and not visited[dest]: q.</description></item><item><title>프로그래머스 - 이모티콘 할인행사 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</guid><description>result = [] def dfs(size, percent, users, emoticons): global result if len(percent) == size: temp = [0] * len(users) for i in range(size): for j in range(len(users)): if percent[i]*100 &amp;gt;= users[j][0]: temp[j] += emoticons[i]*(1-percent[i]) serviceNum = 0 income = 0 for i in range(len(users)): if temp[i] &amp;gt;= users[i][1]: serviceNum += 1 else: income += temp[i] result.append ((serviceNum, income)) return for i in [0.1, 0.2, 0.3, 0.4]: dfs(size, percent+[i], users, emoticons) def solution(users, emoticons): dfs(len(emoticons), [], users, emoticons) result.</description></item><item><title>Spring 개념 - MVC 패턴, Servlet (서블릿)</title><link>https://bong-u.github.io/til/spring/mvc_servlet/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/mvc_servlet/</guid><description>Servlet 개념 클라이언트의 요청을 처리하고, 그 결과를 반환하는 자바 웹 프로그래밍 기술
웹페이지를 동적으로 생성하는 역할을 수행한다 Servlet Conainer의 역할 Servlet의 생명주기를 관리한다 웹서버와의 통신지원 멀티쓰레드 지원, 관리 선언적인 보안 관리 예제 - Servlet 구현 public class TestServlet extends HttpServlet { private static final Logger logger = LoggerFactory.getLogger(TestServlet.class); @Override public void init() throws ServletException {} } doGet, doPost 등의 메소드를 구현해서 http 요청을 처리할 수 있다 Servlet Context를 등록하는 방법 web.</description></item><item><title>프로그래머스 - 택배 배달과 수거하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</guid><description>def solution(cap, n, deliveries, pickups): answer = 0 tempD = 0 tempP = 0 for i in range(n-1, -1, -1): tempD += deliveries[i] tempP += pickups[i] while tempD &amp;gt; 0 or tempP &amp;gt; 0: tempD -= cap tempP -= cap answer += (i+1)*2 return answer 문제 트럭에 실을 수 있는 재활용 택배 상자의 최대개수 cap, 배달할 집의 개수 n 택배 상자의 개수를 담은 deliveries, 재활용 택배 상자의 개수를 담은 pickups가 주어진다 트럭하나로 모든 배달과 수거를 마치고 돌아올 수 있는 최소 이동 거리를 구하라 TC input (cap, n, deliveries, pickups) 4, 5, [1, 0, 3, 1, 2], [0, 3, 0, 4, 0]</description></item><item><title>Spring 개념 - Transaction (트랜잭션)</title><link>https://bong-u.github.io/til/spring/transaction/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/transaction/</guid><description>상황 소비자가 판매자의 물건을 구매하는 함수를 구현 중이라고 하자 물건을 샀을때, 물건의 가격만큼 판매자의 돈은 증가시키고, 소비자의 돈은 감소시켜야한다 판매자의 돈은 증가시켰는데, 소비자의 돈을 감소시키는 중 오류가 났다 오류가 난 경우, 판매자의 돈을 증가시키기 이전으로 Rollback 해야 한다 위의 두가지 연산은 하나의 Transaction으로 묶여서 한번에 처리되어야 한다 Transaction 관리의 종류 Programmatic transaction management (프로그래밍적 트랜잭션 관리)
Transaction 관련 코드를 직접 작성 예제 - TransactionManager 사용 // Bean 등록 @Bean public PlatformTransactionManager platformTransactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } // 사용할 때 // 새로운 트랜잭션을 시작한다 var transaction = transactionManager.</description></item><item><title>프로그래머스 - 시소 짝꿍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</guid><description>def solution(weights): answer = 0 wdict = {} weights.sort(reverse=True) for i in weights: if i in wdict: answer += wdict[i] if i*3/2 in wdict: answer += wdict[i*3/2] if i*2 in wdict: answer += wdict[i*2] if i*4/3 in wdict: answer += wdict[i*4/3] wdict[i] = wdict[i]+1 if i in wdict else 1 return answer 문제 시소에는 중심으로부터 2m, 3m, 4m 떨어진 거리에 좌석이 존재한다 양쪽의 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 같아서 시소가 평행을 이룬다면 그 둘을 시소 짝꿍이라고 할 수 있다 사람들의 몸무게 배열이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하라 TC input [100,180,360,100,270]</description></item><item><title>[모각코] 03 : 결과</title><link>https://bong-u.github.io/til/mogako23/mogako03/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako03/</guid><description>1. 프로그래머스 한 문제 풀기 🧠 프로그래머스 - 숫자 변환하기 (L2) 2023-07-19 Algorithm
from collections import deque def solution(x, y, n): q = deque() visited = [False] * 1000001 q.append((x, 0)) while q: cx, cnt = q.popleft() if cx == y: return cnt if cx &amp;#43; n &amp;amp;lt;= y and not visited[cx&amp;#43;n]: q.append((cx&amp;#43;n, cnt&amp;#43;1)) visited[cx&amp;#43;n] = True if cx * 2 &amp;amp;lt;= y and not visited[cx*2]: q.</description></item><item><title>[모각코] 03 : 계획</title><link>https://bong-u.github.io/til/mogako23/mogako03_plan/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako03_plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 JDBC 정리</description></item><item><title>Java - 이중 중괄호와 Anti-Pattern</title><link>https://bong-u.github.io/til/java/double_brace_initialization/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/double_brace_initialization/</guid><description>기존 코드 Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); map.put(&amp;#34;name&amp;#34;, customer.getName()); map.put(&amp;#34;email&amp;#34;, customer.getEmail()); map.put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); return map; Double Brace Initialization 적용 후 return new HashMap&amp;lt;&amp;gt;() {{ put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); put(&amp;#34;name&amp;#34;, customer.getName()); put(&amp;#34;email&amp;#34;, customer.getEmail()); put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); }}; 효과 장점 코드가 가독성이 좋아진다 단점 추가로 익명 클래스를 사용한다 -&amp;gt; 메모리 추가 사용
인스터스 및 개체에 대한 숨겨진 참조를 가진다 -&amp;gt; Memory Leak 유발 가능</description></item><item><title>Spring 개념 - JDBC, DBCP, JdbcTemplate</title><link>https://bong-u.github.io/til/spring/jdbc/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/jdbc/</guid><description>JDBC 자바 프로그램을 DB와 연결해주는 API
JDBC 드라이버 DBMS와 통신을 담당하는 자바 클래스
JDBC 드라이버는 4가지 종류가 있다 (Type 1~4) Mysql은 Type 4를 지원한다 예제 - Connection을 직접 연결 public List&amp;lt;UUID&amp;gt; findAllIds() { List&amp;lt;UUID&amp;gt; uuids = new ArrayList&amp;lt;&amp;gt;(); try ( var connection = DriverManager.getConnection(url, username, password); var statement = connection.createStatement(); var resultSet = statement.executeQuery(SELECT_ALL_SQL); ) { while (resultSet.next()) { var customerName = resultSet.getString(&amp;#34;name&amp;#34;); var customerId = toUUID(resultSet.</description></item><item><title>프로그래머스 - 숫자 변환하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</guid><description>from collections import deque def solution(x, y, n): q = deque() visited = [False] * 1000001 q.append((x, 0)) while q: cx, cnt = q.popleft() if cx == y: return cnt if cx + n &amp;lt;= y and not visited[cx+n]: q.append((cx+n, cnt+1)) visited[cx+n] = True if cx * 2 &amp;lt;= y and not visited[cx*2]: q.append((cx*2, cnt+1)) visited[cx*2] = True if cx * 3 &amp;lt;= y and not visited[cx*3]: q.append((cx*3, cnt+1)) visited[cx*3] = True return -1 문제 자연수 x를 y로 변환시킬려고 한다 할 수 있는 연산은 3가지 (x에 n을 곱한다, x에 2를 곱한다, x에 3을 곱한다) 필요한 최소 연산 횟수를 구하여라 TC input 10(x), 40(y), 5(n)</description></item><item><title>프로그래머스 - 뒤에 있는 큰 수 찾기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</link><pubDate>Tue, 18 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</guid><description>def solution(numbers): stack = [] answer = [-1] * len(numbers) for i in range(len(numbers)): while stack and stack[-1][1] &amp;lt; numbers[i]: answer[stack[-1][0]] = numbers[i] stack.pop() stack.append((i, numbers[i])) print(stack) return answer 문제 정수로 이루어진 배열 numbers가 주어진다 자신 보다 뒤에 있는 숫자 중 가장 크면서 가까운 수를 뒷 큰수라고 한다 모든 원소에 대해서 뒷 큰수를 구하여라 (존재하지 않으면 -1) TC input [2, 3, 3, 5]
ouput [3, 5, 5, -1]</description></item><item><title>프로그래머스 - 무인도 여행 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</guid><description>from collections import deque vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def solution(maps): N = len(maps) M = len(maps[0]) answer = [] visited = [[False]*M for _ in range(N)] for i in range(N): for j in range(M): if maps[i][j] != &amp;#39;X&amp;#39; and not visited[i][j]: cnt = 0 q = deque() q.append((j, i)) visited[i][j] = True while q: cx, cy = q.popleft() cnt += int(maps[cy][cx]) for k in range(4): nx = cx + vx[k] ny = cy + vy[k] if 0 &amp;lt;= nx &amp;lt; M and 0 &amp;lt;= ny &amp;lt; N and maps[ny][nx] !</description></item><item><title>프로그래머스 - 호텔 대실 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</guid><description>import heapq def time_calc(time): time_split = time.split(&amp;#39;:&amp;#39;) return int(time_split[0])*60 + int(time_split[1]) def solution(book_time): time = [] q = [] for start, end in book_time: time.append((time_calc(start), time_calc(end))) time.sort(key=lambda x: x[0]) print (time) for start, end in time: if q: top = heapq.heappop(q) if top &amp;gt; start: heapq.heappush(q, top) heapq.heappush(q, end+10) else: heapq.heappush(q, end+10) return len(q) 문제 호텔의 예약시간이 담긴 2차원 배열이 주어진다 ex) [[&amp;ldquo;12:00&amp;rdquo;, &amp;ldquo;12:30&amp;rdquo;], [&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;16:00&amp;rdquo;]] 퇴실 시간 10분 이후에 다음 손님이 입실 할 수 있다 최소 객실의 개수를 구하여라 TC input [[&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;17:00&amp;rdquo;], [&amp;ldquo;16:40&amp;rdquo;, &amp;ldquo;18:20&amp;rdquo;], [&amp;ldquo;14:20&amp;rdquo;, &amp;ldquo;15:20&amp;rdquo;], [&amp;ldquo;14:10&amp;rdquo;, &amp;ldquo;19:20&amp;rdquo;], [&amp;ldquo;18:20&amp;rdquo;, &amp;ldquo;21:20&amp;rdquo;]]</description></item><item><title>프로그래머스 - 미로 탈출 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</link><pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</guid><description>from collections import deque vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def bfs(maps, N, M, p1, p2): visited = [[False]*M for _ in range(N)] q = deque() q.append(list(p1)+[0]) while q: curY, curX, cnt = q.popleft() if p2 == (curY, curX): return cnt for i in range(4): x = curX + vx[i] y = curY + vy[i] if 0 &amp;lt;= x &amp;lt; M and 0 &amp;lt;= y &amp;lt; N and not visited[y][x] and maps[y][x] !</description></item><item><title>Try with resources로 간결하게 반납하기</title><link>https://bong-u.github.io/til/java/try_with_resources/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/try_with_resources/</guid><description>기존 코드 - try-catch-finally 사용 Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { connection = DriverManager.getConnection(/* SECRET */); statement = connection.createStatement(); resultSet = statement.executeQuery(&amp;#34;select * from customers&amp;#34;); while (resultSet.next()) { var name = resultSet.getString(&amp;#34;name&amp;#34;); var customerId = UUID.nameUUIDFromBytes(resultSet.getBytes(&amp;#34;customer_id&amp;#34;)); logger.info(&amp;#34;Customer id:{}, name: {}&amp;#34;, customerId, name); } } catch (SQLException e) { logger.error(&amp;#34;Error while connecting to DB&amp;#34;, e); throw e; } finally { try { if (connection !</description></item><item><title>프로그래머스 - 혼자서 하는 틱택토 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</guid><description>V = [[(-1, 0), (1, 0)], [(0, -1), (0, 1)], [(-1, -1), (1, 1)], [(-1, 1), (1, -1)]] P = [[(1, 0), (1, 1), (1, 2)], [(0, 1), (1, 1), (2, 1)], [(1, 1)], [(1, 1)]] def solution(board): answer = -1 o_line = 0 x_line = 0 for i, p_list in enumerate(P): for p in p_list: if board[p[0]][p[1]] != &amp;#39;.&amp;#39; and board[p[0]][p[1]]== board[p[0]+V[i][0][0]][p[1]+V[i][0][1]] == board[p[0]+V[i][1][0]][p[1]+V[i][1][1]]: if board[p[0]][p[1]] == &amp;#39;O&amp;#39;: o_line += 1 elif board[p[0]][p[1]] == &amp;#39;X&amp;#39;: x_line += 1 o_cnt = 0 x_cnt = 0 for i in &amp;#39;&amp;#39;.</description></item><item><title>[모각코] 02 : 결과</title><link>https://bong-u.github.io/til/mogako23/mogako02/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako02/</guid><description>1. 프로그래머스 한 문제 풀기 🧠 프로그래머스 - 당구 연습 (L2) 2023-07-12 Algorithm
def solution(m, n, startX, startY, balls): answer = [] for bx, by in balls: tmp = [] for x, y in [(-1*startX, startY), (startX, -1*startY), (startX, 2*n-startY), (2*m-startX, startY)]: if bx==x and (y &amp;amp;lt; 0 &amp;amp;lt; by &amp;amp;lt; startY or startY &amp;amp;lt; by &amp;amp;lt; n &amp;amp;lt; y): continue if by==y and (x &amp;amp;lt; 0 &amp;amp;lt; b 2.</description></item><item><title>[모각코] 02 : 계획</title><link>https://bong-u.github.io/til/mogako23/mogako02_plan/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako02_plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 Springboot Testing 공부하기</description></item><item><title>프로그래머스 - 당구 연습 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</guid><description>def solution(m, n, startX, startY, balls): answer = [] for bx, by in balls: tmp = [] for x, y in [(-1*startX, startY), (startX, -1*startY), (startX, 2*n-startY), (2*m-startX, startY)]: if bx==x and (y &amp;lt; 0 &amp;lt; by &amp;lt; startY or startY &amp;lt; by &amp;lt; n &amp;lt; y): continue if by==y and (x &amp;lt; 0 &amp;lt; bx &amp;lt; startX or startX &amp;lt; bx &amp;lt; m &amp;lt; x): continue tmp.append ((x-bx)**2+(y-by)**2) answer.append(min(tmp)) return answer 문제 수구와 적구의 좌표가 주어진다 원쿠션으로 적구를 맞히는데 필요한 최소한의 거리를 구하라 TC input 10, 10, 3, 7, [[7, 7], [2, 7], [7, 3]]</description></item><item><title>Issue - Jar 실행환경에서 ClassPathResource를 가져오지 못하는 문제</title><link>https://bong-u.github.io/til/spring/class_resource_issue/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/class_resource_issue/</guid><description>상황 개발 환경에서는 ClassPathResource를 문제없이 불러온다
jar로 package해서 실행했을 때 오류가 발생한다
Caused by: java.lang.RuntimeException: Cannot read blacklist file at org.academy.springorder.blacklist.BlacklistRepository.list(BlacklistRepository.java:25) at org.academy.springorder.blacklist.BlacklistService.list(BlacklistService.java:16) at org.academy.springorder.CommandLineApplication.main(CommandLineApplication.java:66) ... 8 more 문제의 코드
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); try { list = Files.readAllLines(blacklist.getFile().toPath()); } catch (IOException e) { throw new RuntimeException(&amp;#34;Cannot read blacklist file&amp;#34;); } 해결 readAllLines를 사용하지 않고 InputStreamReader와 BufferedRearder를 사용하여 해결하였다.</description></item><item><title>프로그래머스 - 리코쳇 로봇 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</guid><description>from collections import deque visited = [] vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def bfs(board, N, M, sp): global visited q = deque() q.append(sp+[1]) while q: cy, cx, cnt = q.popleft() visited[cy][cx] = True for i in range(4): x = cx y = cy while True: x += vx[i] y += vy[i] if not (0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; M) or board[y][x] == &amp;#39;D&amp;#39;: x -= vx[i] y -= vy[i] break if board[y][x] == &amp;#39;G&amp;#39;: return cnt if not visited[y][x]: q.</description></item><item><title>Spring 개념 - Profile</title><link>https://bong-u.github.io/til/spring/profile/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/profile/</guid><description>Profile 프로그램을 개발, 테스트, 배포 환경으로 나눠서 실행해야할때가 있다 환경 설정을 위해 spring boot에서는 profile을 사용할 수 있다. 환경 변수 application.yml spring.config.activate.on-profile: dev env: version: &amp;#34;v1.0.0 dev&amp;#34; --- spring.config.activate.on-profile: local env: version: &amp;#34;v1.0.0 local&amp;#34; --- yml 파일에서는 &amp;mdash;를 이용해 파일 분할이 가능하다 spring.config.active.on-profile을 설정해서 특정 프로필에 적용하고 싶은 환경변수를 설정 할 수 있다. application-&amp;lt;profile&amp;gt;.properties .properties파일에서는 여러 파일로 분할하여 설정한다 예를 들어 &amp;ldquo;dev&amp;quot;프로파일에서 적용될 파일은 &amp;ldquo;application-dev.properties&amp;quot;이다. @Profile 프로파일마다 Bean객체를 다르게 등록할 수 있다.</description></item><item><title>프로그래머스 - 광물 캐기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</guid><description>def solution(picks, minerals): bundles = [] tmp = [0, 0, 0] DATA = [[1, 1, 1], [5, 1, 1], [25, 5, 1]] answer = 0 for i in range(len(minerals)): if minerals[i] == &amp;#34;diamond&amp;#34;: for j in range(3): tmp[j] += DATA[j][0] elif minerals[i] == &amp;#34;iron&amp;#34;: for j in range(3): tmp[j] += DATA[j][1] elif minerals[i] == &amp;#34;stone&amp;#34;: for j in range(3): tmp[j] += DATA[j][2] if (i+1) % 5 == 0 or i == len(minerals)-1: bundles.</description></item><item><title>Spring 개념 - Environment</title><link>https://bong-u.github.io/til/spring/environment/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/environment/</guid><description>application.properties 환경변수 설정 application.properties 파일을 작성한다 파일 위치 : reousrces/application.properties 파일 내용 예시 : key = value 형태 app.name = spring Configuration에 설정한다 @Configuration @PropertySource(&amp;#34;application.properties&amp;#34;) public class AppConfiguration {...} 환경변수 가져오기 ApplicationContext 활용하는 방법 var environment = applicationContext.getEnvironment(); var property = environment.getProperty(&amp;#34;app.name&amp;#34;) @Value Annotation 활용 @Value(&amp;#34;${app.name}&amp;#34;) private String name; 별도의 클래스 정의 클래스 정의
@Component @PropertySource(&amp;#34;version.properties&amp;#34;) public class VersionProvider { private final String version; public VersionProvider(@Value(&amp;#34;${version:v0.</description></item><item><title>프로그래머스 - 과제 진행하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</guid><description>내 답안 def solution(plans): q = [] answer = [] for plan in plans: h, m = map(int, plan[1].split(&amp;#39;:&amp;#39;)) plan[1] = h*60 + m plan[2] = int(plan[2]) plans.sort(key = lambda x: x[1]) for plan in plans: if q: free_time = plan[1] - q[-1][1] while q: q[-1][2] -= free_time free_time = -1 * q[-1][2] print (free_time, q[-1][2]) if free_time &amp;lt; 0: break if q[-1][2] &amp;lt;= 0: answer.append(q.pop()[0]) q.append(plan) while q: answer.append(q.pop()[0]) return answer 다른 사람 답안 def solution(plans): plans = sorted(map(lambda x: [x[0], int(x[1][:2]) * 60 + int(x[1][3:]), int(x[2])], plans), key=lambda x: -x[1]) q = [] while plans: cur = plans.</description></item><item><title>Spring 개념 - IoC (Inversion of Control)</title><link>https://bong-u.github.io/til/spring/ioc/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/ioc/</guid><description>IoC (Inversion of Control) 제어의 역전 메소드나 객체의 호출 작업이, 개발자가 아니라, 외부에서 결정되는 것 객체 간 결합도를 줄이고 유연한 코드를 작성하게 한다 IoC Container IoC가 일어나는 곳, IoC를 수행하는 대상 IoC 클래스 예제 public class OrderContext { public OrderRepository orderRepository() { return new OrderRepository(); } public OrderService orderService() { return new OrderService(voucherService(), orderRepository()); } } 위 예제에서 OrderContext 클래스가 IoC 컨테이너 역할을 하고 있다 BeanFactory Spring container의 최상위 interface Bean을 생성하고 의존관계를 설정하는 기능을 담당하는 가장 기본적인 IoC 컨테이너 Lazy-loading 방식 사용 : Bean을 사용할때 loading -&amp;gt; 경량 컨테이너 ApplicationContext BeanFactroy의 구현체 Eager-loading 방식 : Runtime에 Bean을 loading &amp;lt;-&amp;gt; Lazy-loading AnnotationConfigApplicationContext ApplicationContext의 구현체 Annotation 기반으로 설정하는 방식 &amp;lt;-&amp;gt; XML방식</description></item><item><title>Spring 개념 - Logging</title><link>https://bong-u.github.io/til/spring/logging/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/logging/</guid><description>Java Logging Framework java.util.logging Apache Commons logging Log4J Logback SLF4J SLF4J (Simple Loggin Facade for Java) Loggin Framework들을 추상화시켜 놓은 것 Facade Pattern을 이용한 Logging framework Log Level trace - debug - info - warn - error
Logger Logger 만들기 private static final Logger logger = LoggerFactory.getLogger(OrderTester.class); Logger 이름은 보통 FQCN (상위 패키지 + 클래스)으로 사용한다 Logger 사용 logger.info(&amp;#34;version -&amp;gt; {}&amp;#34;, logger.getName()); logback logback 설정파일 우선순위 logback-test.</description></item><item><title>프로그래머스 - 연속된 부분 수열의 합 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</guid><description>def solution(sequence, k): answer = [] e = len(sequence)-1 s = len(sequence) cur = 0 while s &amp;gt;= 0: if cur &amp;lt; k: s -= 1 cur += sequence[s] elif cur &amp;gt; k: cur -= sequence[e] e -= 1 else: answer.append((s, e)) s -= 1 cur += sequence[s] answer.sort(key=lambda x: (x[1]-x[0], x[0])) return answer[0] 문제 수열과 k가 주어진다 수열의 부분합이 k가 되게 하는 시작인덱스와 끝인덱스를 구하라 이때, 길이가 짧은 수열을 찾는다, 길이가 같은것이 여러가지라면 시작인덱스가 작은 것을 찾는다 TC input [1, 2, 3, 4, 5], 7</description></item><item><title>[모각코] 01 : 결과</title><link>https://bong-u.github.io/til/mogako23/mogako01/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako01/</guid><description>1. 프로그래머스 한 문제 풀기 🧠 프로그래머스 - 두 원 사이의 정수 쌍 (L2) 2023-07-05 Algorithm
import math def calc1(r): result = 0 for i in range(1, r): result &amp;#43;= math.floor(math.sqrt(r**2 - i**2)) return result*4 &amp;#43; r*4 &amp;#43; 1 def calc2(r): result = 0 for i in range(1, r): a = math.sqrt(r**2 - i**2) result &amp;#43;= math.floor(a) if a % 1 == 0: result -= 1 return result*4 &amp;#43; r*4 &amp;#43; 1 def solution(r1, r2 2.</description></item><item><title>[모각코] 01 : 계획</title><link>https://bong-u.github.io/til/mogako23/mogako01_plan/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako01_plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 Java의 record 개념 정리하기</description></item><item><title>Record</title><link>https://bong-u.github.io/til/java/record/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/record/</guid><description>레코드란 불변(immutable) 데이터 객체를 쉽게 생성할 수 있도록 하는 새로운 유형의 클래스 JDK16부터 지원 예제 Record 적용 전
public class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } Record 적용 후
public record Person(String name, int age) {} Record에서 지원하는 것 Constructor, Getter, equals(), hashcode(), toString() Record의 제약 사항 다른 클래스를 상속 받을 수 없다, 구현(implements)는 가능 static field만 선언 가능하다 (instance field 불가능) 각 field는 private final로 정의된다 Record에서 할 수 있는 것 컴팩트 생성자 : 매개변수가 없는 생성자, validate 사용시 적합 public record Person(String name, int age) { public Person { Objects.</description></item><item><title>프로그래머스 - 두 원 사이의 정수 쌍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</guid><description>import math def calc1(r): result = 0 for i in range(1, r): result += math.floor(math.sqrt(r**2 - i**2)) return result*4 + r*4 + 1 def calc2(r): result = 0 for i in range(1, r): a = math.sqrt(r**2 - i**2) result += math.floor(a) if a % 1 == 0: result -= 1 return result*4 + r*4 + 1 def solution(r1, r2): return calc1(r2)-calc2(r1)+4 문제 두 원의 반지름 r1, r2가 주어진다. 두 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 구하라 이때, 각 원 위의 점도 포함하여 센다.</description></item><item><title>Database</title><link>https://bong-u.github.io/til/sql/database/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/sql/database/</guid><description>RDBMS 대표적인 관계형 데이터 베이스 Production Database (ex: MySQL, PostgreSQL, Oracle&amp;hellip;) OLTP (OnLine Transaction Processing) 빠른 속도에 집중 Data Warehouse (ex: Redshift, Snowflake, BigQuery, Hive &amp;hellip;) OLAP (OnLine Analytical Processing) 처리 데이터 크기에 집중 보통 Production DB를 복사해서 Data Warehouse에 저장 SQL SQL 종류 DML (데이터 조작어) : SELECT, INSERT, UPDATE, DELETE DDL (데이터 정의어) : CREATE, ALTER, DROP, RENAME, TRUNCATE DCL (데이터 제어어) : GRANT, REVOKE TCL (트랜잭션 제어어) : COMMIT, ROLLBACK, SAVEPOINT</description></item><item><title>Spring 개념 - Maven</title><link>https://bong-u.github.io/til/spring/maven/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/maven/</guid><description>Maven coordinates groupId : 회사나 단체명 ex) org.springframework, org.prgms artifactId : 프로젝트 명 ex) spring-context, order-api version : 프로젝트 버전 ex) 5.2.15-RELEASE, 1.0-SNAPSHOT Build lifecycle validate, compile, test, package, verify, install, deploy Trnsitive Dependencies A ├── B │ └─ C └── D C는 A의 transitive 의존성 Dependency Scope (&amp;lt;scope&amp;gt;) compile(default) : 컴파일, 테스트, 실행에 라이브러리가 필요할때 provided : JDK 또는 컨테이너가 해당 라이브러리를 제공할때 (JSP, servlet) runtime : 실행과 테스트에만 사용될때 (JDBC driver) test : 테스트 컴파일 및 실행에만 필요할때 (easymock, junit) system: provided와 비슷하지만, 사용자가 jar파일의 위치를 지정 example &amp;lt;project xmlns=&amp;#34;http://maven.</description></item><item><title>프로그래머스 - 요격 시스템 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</guid><description>def solution(targets): answer = 0 targets.sort(key=lambda x:x[1]) cur = 0 for i in targets: if i[0] &amp;gt;= cur: answer += 1 cur = i[1] return answer 문제 개구간 (s, e)의 리스트가 주어진다. 이때, 모든 개구간을 포함하는 최소 숫자의 수를 구하여라 TC input [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]]
ouput 3
해결방법 개구간을 (s, e)에서 e를 정렬하여 해결하였다. s 기준으로 정렬해도 해결할 수 있다는데 나는 e로 정렬하는게 편했다</description></item><item><title>Stream, Optional</title><link>https://bong-u.github.io/til/java/stream/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/stream/</guid><description>Lambda 표현식 매개변수 화살표(-&amp;gt;) 함수몸체로 이용하여 사용할 수 있습니다. 함수 몸체가 단일 실행문이면 괄호{}를 생략할 수 있습니다. 함수 몸체가 return문으로만 구성되어 있으면 괄호{}을 생략할 수 있습니다. (int x) -&amp;gt; x+1; (int x, int y) -&amp;gt; x+y; (Thread lamT) -&amp;gt; { lamT.start(); } Stream 특징 원본 데이터를 변경하지 않습니다. 요청되었을때만 데이터를 처리한다. parallelStream()을 이용하여 병렬처리가 가능하다. 예제1 List&amp;lt;String&amp;gt; highCaloriesFoodName = foodList.stream() .filter(food -&amp;gt; { System.out.println(&amp;#34;filter : &amp;#34; + food.</description></item><item><title>11000 : 강의실 배정 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_11000/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11000/</guid><description>import heapq N = int(input()) L = [] for _ in range(N): L.append(tuple(map(int, input().split()))) L.sort() q = [] heapq.heappush(q, L[0][1]) for i in L[1:]: if q[0] &amp;gt; i[0]: heapq.heappush(q, i[1]) else: heapq.heappop(q) heapq.heappush(q, i[1]) print (len(q)) 문제 강의 개수와 강의 당 시작시간, 종료시간이 주어진다 필요한 강의실 개수를 구하라 (연강 가능)) TC
input 3 1 3 2 4 3 5
output 4</description></item><item><title>2638 : 치즈 (G3)</title><link>https://bong-u.github.io/til/algorithm/boj_2638/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2638/</guid><description>from collections import deque dx = [0, 0, -1, 1] dy = [-1, 1, 0, 0] N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] def check(): q = deque() q.append((0, 0)) visited = [[0]*M for _ in range(N)] visited[0][0] = 1 while q: curX, curY = q.popleft() for i in range(4): nX = curX + dx[i] nY = curY + dy[i] if 0 &amp;lt;= nX &amp;lt; N and 0 &amp;lt;= nY &amp;lt; M: if L[nX][nY] == 0 and visited[nX][nY] == 0: q.</description></item><item><title>[모각코] 00 : 목표</title><link>https://bong-u.github.io/til/mogako23/mogako00/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/mogako23/mogako00/</guid><description>나의 목표 1. 성실한 포스팅으로 1일 1커밋을 향해 노력하겠다. 2. SW Academy에서 배운 Spring boot 기술을 상세하게 정리할 것이다. 2. 현재 기술 블로그의 디자인을 개선시킬 것이다. SW Academy 교육과정 - Backend 프레임워크를 위환 Java 심화 실리콘밸리에서 날아온 DataBase Spring Boot Basic 1 Spring Boot Basic 2 Spring Boot Basic 3 Spring Data Security 1 Spring Data Security 2</description></item><item><title>운영체제 - 기말범위</title><link>https://bong-u.github.io/til/school/operatingsystem2/</link><pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem2/</guid><description>06-File-Management Directory File Directory Directory도 일종의 파일이다 해당 파일 FCB의 식별자만 저장한다 inode (index node) Unix에서는 FCB와 inode가 같다 모든 파일, 폴더가 Unique한 값을 가진다. (root는 2로 고정) File Systems 파티션의 구조 boot block, super block, FCB list, data blocks Partition Control block (Super block) blocks 개수, free data blocks 개수, free data blocks list 저장 inode table, free inode 개수, free inode list 저장 File Control Block (FCB) UNIX에서 128byte의 크기를 가진다 파일 이름, 파일 크기, uid, gid, 파일 주소 등등 저장 Management of Data Blocks Contiguous Allocation 각각의 파일을 연속적으로 저장 Direct Access File grow problem 존재 External fragmentation, Internal fragmentation 발생 Chained Allocation Direct acess File grow problem X External fragmentation X Poor data safety (앞 블록에 문제가 생기면 뒤 블록도 사용 불가능) Indexed Allocation (현대에 사용) Direct access File grow problem X External fragmentation X Medium level data safety (index block만 괜찮으면 된다) Index block이 추가로 필요하다 Free-Space Management Counting N-M&amp;hellip; N번부터 M개의 블록이 비어있다.</description></item><item><title>11444 : 피보나치 수 6 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_11444/</link><pubDate>Tue, 09 May 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11444/</guid><description>def multiply(m1, m2): result = [0, 0, 0, 0] result[0] = (m1[0]*m2[0] + m1[1]*m2[2]) % 1000000007 result[1] = (m1[0]*m2[1] + m1[1]*m2[3]) % 1000000007 result[2] = (m1[2]*m2[0] + m1[3]*m2[2]) % 1000000007 result[3] = (m1[2]*m2[1] + m1[3]*m2[3]) % 1000000007 return result def power(m, n): if (n &amp;gt; 1): m = power (m, n//2) m = multiply (m, m) if n % 2 == 1: m = multiply(m, [1,1,1,0]) return m N = int(input()) mat = power ([1,1,1,0], N) print (mat[1]%1000000007) 문제 n이 주어질 때 n번째 피보나치 수를 구하여라.</description></item><item><title>1976 : 여행 가자 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1976/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1976/</guid><description>N = int(input()) M = int(input()) parent = [i for i in range(N)] def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(a, b): a = find(a) b = find(b) if a &amp;lt; b: parent[b] = a else: parent[a] = b for i in range(N): for j, item in enumerate(map(int, input().split())): if item: union(i, j) path = list(map(int, input().split())) start = parent[path[0]-1] for i in range(1, M): if parent[path[i]-1] !</description></item><item><title>JS - Arguments object 관련 이슈</title><link>https://bong-u.github.io/til/javascript/js_arguments_object_issue/</link><pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/javascript/js_arguments_object_issue/</guid><description>상황 나의 기술 블로그와 Google Analytics를 연결하기 위해 tag를 삽입하는 작업 중 이었다. 구글에서 제공하는 태그 소스 중 일부이다. function gtag() { dataLayer.push(arguments); } 나는 function 키워드를 사용한게 마음에 들지 않아. 아래와 같이 화살표 함수로 바꾸어 작업하였다. const gtag = (...args) =&amp;gt; { dataLayer.push(args); }; 하지만 내 코드는 정상적으로 동작하지 않았고 구글의 코드 그대로 적용해야만 google analytics가 동작하였다. 이유는 두 방식의 차이점에 있었는데, 어떤 점이 다른건지 알아보게 되었다.</description></item><item><title>11003 : 최솟값 찾기 (P5)</title><link>https://bong-u.github.io/til/algorithm/boj_11003/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11003/</guid><description>from collections import deque N, L = map(int, input().split()) A = list(map(int, input().split())) Q = deque([(A[0], 0)]) result = [A[0]] for i in range(1, N): if Q[0][1] == i-L: Q.popleft() while Q and Q[-1][0] &amp;gt;= A[i]: Q.pop() Q.append((A[i], i)) result.append(Q[0][0]) print(*result) 문제 N개의 수 A1, A2, &amp;hellip;, AN 과 L이 주어진다. Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. TC input 12 3</description></item><item><title>Spring Boot Framework - KAKAO 김가연 선배님</title><link>https://bong-u.github.io/til/lecture/spring_boot/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/lecture/spring_boot/</guid><description>REST API REprensentational State Transfer 웹의 장점을 최대한 활용할 수 있는 아키텍처 Layered Architecture Presentation Layer 비즈니스 로직과 UI를 분리 @Controller가 붙은 클래스가 이에 해당 Service Layer 비즈니스 로직 구현 @Service가 붙은 클래스가 이에 해당 Data Access Layer 데이터를 조회, 등록, 수정, 삭제 @Repository가 붙은 클래스가 이에 해당 IoC Inversion of Control : 제어의 역전 모든 객체에 대한 제어권이 바뀌었음을 의미 객체의 주인이 개발자가 아닌 Spring application DI Constructor Injection</description></item><item><title>데이터통신</title><link>https://bong-u.github.io/til/school/datacommunication/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/datacommunication/</guid><description>메시지(패킷, 프레임), 계층 OSI 7 Model Physical Data Link Network Transport Session Presentation Application TCP/IP 계층 계층 이름 메시지 형태 내용 1 Phisical Bits Bits 2 Data Link Ethernet Frame Ethernet 주소 3 Network IP packet, Datagram IP 주소 4 Transport TCP Segment, UDP Datagram Port 번호 5 Application HTTP 메시지, Email 메시지 URL, Email 주소 Protocol Suite HTTP - TCP - IP - ARP 아날로그 신호 - 사인 함수 $$ y(t) = A sin(2\pi ft + \varphi) $$</description></item><item><title>Git 특강 - 네이버 정다현 선배님</title><link>https://bong-u.github.io/til/lecture/git/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/lecture/git/</guid><description>버전 관리 시스템 중앙집중식 버전 관리(CVCS) Centralized Version Control System
CVCS의 종류 : SVN, Perforce, CVS
문제
중앙 서버의 부하가 큼 오프라인에서는 사용이 불가능 분산 버전 관리 시스템 (DVCS) Decentralized Version Control System DVCS의 종류 : Git, Mercurial, Bazaar Git command gst : git status git log &amp;ndash;oneline : commit을 한줄로 출력 git log &amp;ndash;all &amp;ndash;graph : 그래프로 출력 merge의 3가지 종류 merge : 모든 commit들이 merge commit과 함께 merge squash and merge : 모든 commit들을 하나의 새로운 commit으로 요약하여 merge rebase and merge : 분기가 발생한 기준이 되는 base를 변경 특정 commit으로 롤백하는 방법 reset : commit 이력을 남기지 않고 되돌리기 revert : commit 이력을 남기고 되돌린다 현업에서는 revert를 주로 사용 reset git reset HEAD~ 옵션 &amp;ndash;soft : HEAD 위치 변경, 파일 변화 없음, commit 직전의 상황 &amp;ndash;mixed (default) : add하기 전으로 되돌려 준다, unstaged로 되돌려준다 &amp;ndash;hard : 변경 내용이 모두 사라짐 &amp;ndash;merge : merge 후에 되돌리기 위해서 사용 revert git revert HEAD cherry-pick git cherry pick &amp;lt;commit id&amp;gt; 다른 브랜치의 특정 commit 만을 가져 올 때 사용 Markdown 글자 하이라이트 *글자 기울이기* **굵은 글씨** ~~취소 선~~ 수평선 ---</description></item><item><title>230315 기프랩 Design Thinking 방법론 - 김재정 교수님</title><link>https://bong-u.github.io/til/school/basicprojectlab_design_thinking/</link><pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/basicprojectlab_design_thinking/</guid><description>디자인 씽킹이란 공감의 과정을 통해 문제점을 찾아내고, 아이디어를 발산하고, 프로토타입을 만들어 검증 과정을 거치는, 반복적 프로세스에 대한 방법론 및 사고방식 디자인 씽킹 프로세스 공감 - 문제 정의 - 아이디어 도출 - 프로토타이핑 - 테스팅 1. 공감 공감 프로세스 면담하기 관찰하기 경험하기 면담지 준비하기 순차적 경험 질문 : 어떤 순서로 행동하고 경험하는지 물어보자 감정 질문 이유 질문 : 행동 또는 감정에 대한 이유를 물어보자 또 질문 : &amp;ldquo;또&amp;hellip;&amp;ldquo;라는 질문을 많이 하자 구체화 질문 관찰하기 | 모니터링 현장 중심 관찰 : 세상을 넓고 깊게 바라보기 관찰하기 | 쉐도잉 사람의 체험이나 행동을 그자리에서 관찰하기 관찰하기 | 맥락 질의법 현장에서 관찰 및 면담을 통해 대상자에 대한 이해를 하는 방법</description></item><item><title>협업프로세스 - LINE 나도희 선배님</title><link>https://bong-u.github.io/til/lecture/collaborative_process/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/lecture/collaborative_process/</guid><description>IT 업계의 조직 구성 목적 조직 프로젝트 A : 기획, 개발자, 디자이너 프로젝트 B : 기획, 개발자, 디자이너 &amp;hellip; 프로젝트가 커지면 관리가 힘듦
기능 조직 기획 : 기획자, 기획자, 기획자 클라이언트 : 개발자, 개발자, 개발자 서버 : 개발자, 개발자, 개발자 부서내 개발자마다 하는 프로젝트가 다름
개발 방법론 Waterfall 개발 방법론 명확한 요구사항을 가지고 프로젝트를 진행 장점 대략적인 일정 산출이 가능함 프로젝트의 시작과 끝이 명확함 단점 피드백 처리가 느리다 중간에 수정이 어렵다 Agile 개발 방법론 짧은 개발 주기를 가지고 피드백을 계속 반영하면서 진행 단점 프로젝트의 시작과 끝이 명확하지 않다 프로젝트 관리가 상대적으로 어려움이 있음 Kanban : 프로젝트 관리 도구 카드를 이용해서 &amp;ldquo;할일&amp;rdquo;, &amp;ldquo;진행 중&amp;rdquo;, &amp;ldquo;완료&amp;rdquo; 항목을 나누어서 각 테스크의 상태를 관리하는 보드</description></item><item><title>17144 : 미세먼지 안녕! (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17144/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17144/</guid><description>R, C, T = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(R)] dx = [0, 1, 0, -1] dy = [-1, 0, 1, 0] dx2 = [0, 1, 0, -1] dy2 = [1, 0, -1, 0] pur_a = (0, 0) pur_b = (0, 0) for i in range(R): if L[i][0] == -1: pur_a = (i, 0) pur_b = (i+1, 0) break def diffuse(L): L_ = [[0]*C for _ in range(R)] for i in range(R): for j in range(C): if L[i][j] &amp;gt; 0: cnt = 0 for k in range(4): px = j+dx[k] py = i+dy[k] if 0 &amp;lt;= px &amp;lt; C and 0 &amp;lt;= py &amp;lt; R and L[py][px] !</description></item><item><title>12851 : 숨바꼭질 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_12851/</link><pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12851/</guid><description>from collections import deque position_a, position_b = map(int, input().split()) q = deque() visited = [False]*100001 result = 0 cnt = 1 q.append((0, position_a)) while q: time, cur = q.popleft(); visited[cur] = True if cur == position_b: result = time for i in q: if i == (time, cur): cnt += 1 break if cur-1 &amp;gt;= 0 and not visited[cur-1]: q.append((time+1, cur-1)) if cur+1 &amp;lt;= 100000 and not visited[cur+1]: q.append((time+1, cur+1)) if cur*2 &amp;lt;= 100000 and not visited[cur*2]: q.</description></item><item><title>2448 : 별 찍기 - 11 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2448/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2448/</guid><description>import math N = int(input()) K = int(math.log2(N//3)) arr = [[&amp;#39; &amp;#39;] * (2*N-1) for _ in range(N)] def solve(depth, bx, by): if depth == 0: for i in range(3): for j in range(i*2+1): arr[by+i][bx+(2-i)+j] = &amp;#39;*&amp;#39; arr[by+1][bx+2] = &amp;#39; &amp;#39; else: px = 2**(depth)*3 py = 2**(depth-1)*3 solve(depth-1, bx+px//2, by) solve(depth-1, bx, by+py) solve(depth-1, bx+px, by+py) solve(K, 0, 0) for i in arr: print (&amp;#39;&amp;#39;.join(i)) 혼자 풀었다 별이 찍혀져있는 모습을 보고 규칙을 찾아내서 구현하는 문제였다 N이 3*(2^N)으로만 주어진다는 것을 토대로 재귀를 이용하여 풀었다</description></item><item><title>운영체제 - 중간범위</title><link>https://bong-u.github.io/til/school/operatingsystem1/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem1/</guid><description>운영체제 개요 운영체제의 역할 Program execution Access to computer resources (I/O device, Data&amp;hellip;) Error detection and response Accounting (ex: task manager) 운영체제의 발전 Serial Processing : No OS, No Job scheduling
Simple batch system
OS가 job을 할당 Controlled by monitor Uni-programming
다 실행될때까지 기다림 bad utilization Multiprogramming
The processor can switch to the other job better utilization, needs more memory Time sharing</description></item><item><title>프로그래머로 산다는 것 (리더의 생각) - 쏘카 류석문 CTO님</title><link>https://bong-u.github.io/til/lecture/socar_cto/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/lecture/socar_cto/</guid><description>개발자는 항상 변화하면서 성장해야 한다
개발자의 지속적인 성장 방법 깔끔한 코드 적절한 논리력 (= 문제 해결 능력) 개발이 완료 됐는지 검증하는 방법 ATDD (Acceptance Test Driven Development) : 고객, 개발자, 테스터 간의 커뮤니케이션을 기반으로 하는 개발 방법론 사용하는 코드만 만들기 (Celler Create) 리팩토링 (Refactoring) 코드 읽기 (Code Review) 알고리즘과 데이터 구조 (Don&amp;rsquo;t Reinvent The Wheel) 단순한 디자인 (Simple Design) 진화적 디자인 (Evolutionary Design) 협업 (Cooperative Design Design Review) 기술 벤치마킹 (Benchmarking) 이력서에 git repo 제출할 때, 꾸준히 개선하기 위해 고민하고 관리한 repo를 제출하자</description></item><item><title>1043 : 거짓말 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1043/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1043/</guid><description>N, M = map(int, input().split()) T = list(map(int, input().split())) T = set(T[1:]) member = [set() for _ in range(N)] party = [] visit = [False]*M def explore(n): for i in member[n]: if not visit[i]: visit[i] = True for j in party[i]: explore(j-1) for i in range(M): lst = list(map(int, input().split())) lst = lst[1:] for j in lst: member[j-1].add(i) party.append(set(lst)) for i in T: explore(i-1) cnt = 0 for i in visit: if not i: cnt += 1 print (cnt) 내방식대로 푸는데 오래걸렸다 유니온 파인드로 푸는 사람도 있었다</description></item><item><title>5639 : 이진 검색 트리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5639/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5639/</guid><description>풀이방법 1 : 직접 구현 import sys sys.setrecursionlimit(10**6) class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self, root): self.root = root def insert(self, value): cur_node = self.root while True: if value &amp;lt; cur_node.value: if cur_node.left != None: cur_node = cur_node.left else: cur_node.left = Node(value) break else: if cur_node.right != None: cur_node = cur_node.right else: cur_node.right = Node(value) break def traverse(self, node): if node.</description></item><item><title>자료구조</title><link>https://bong-u.github.io/til/school/datastructure/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/datastructure/</guid><description>제 1장 : 자료구조를 배우기 위한 준비 (230302) 배열 배열(Array): 동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 있는 기초적인 자료구조 추상데이터 타입 추상데이터타입(ADT:Abstract Data Type) : 데이터와 그 데이터에 대한 추상적인 연산들로써 구성 ADT =~ 자바의 interface, 자료구조 =~ 자바의 class 자료구조는 추상데이터타입을 구체적으로 구현한 것 1-2 수행시간의 분석 알고리즘의 성능: 수행시간을 나타내는 **시간복잡도(Time Complexity)**와 알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기를 나타내는 **공간복잡도(Space Complexity)**에 기반하여 분석 시간 복잡도</description></item><item><title>확률과 통계</title><link>https://bong-u.github.io/til/school/probabilityandstatistics/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/probabilityandstatistics/</guid><description>자료의 정리와 요약 통계 자료의 구분
양적자료(quantitative data) 또는 수치형자료(numerical data) 이산자료(자녀 수), 연속자료(키) 질적자료(qualitative data) 또는 범주형자료(categorical data) 명목자료(혈액형, 성별), 순서자료(학점, 부서평가) 변수의 종류
all variables ├── numerical │ ├-─ continuous (리터 수) │ └-─ discrete (나라 수) └─── categorical ├-─ Nominal (성별) └-─ Ordinal (근무 한 시간 : 12-2) 도수분포표 자료의 특성을 기준으로 일정한 계급으로 나누고, 각 계급에 도수를 대응하여 작성한 표</description></item><item><title>쿠버네티스 및 MSA 특강 4일차 : MSA란 무엇인가</title><link>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-4%EC%9D%BC%EC%B0%A8/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-4%EC%9D%BC%EC%B0%A8/</guid><description>MSA란 무엇인가 마이크로서비스 개념 마이크로서비스(microservice)는 애플리케이션을 느슨하게 결합된 서비스의 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법이다 마이크로서비스 아키텍처에서 서비스들은 섬세(fine-grained)하고 프로토콜은 가벼운 편이다. 마이크로서비스 특징 자율성 : 각 구성 요소 서비스는 다른 서비스의 기능에 영향을 주지 않으면서 개발, 배포, 운영하고 확장 가능 전문성 : 각 서비스는 일련의 기능을 위해 설계되며 특정 문제를 해결하는 데 중점을 둔다 마이크로서비스의 기술적 특징 각각의 서비스는 그 크기가 작을 뿐, 서비스 자체는 하나의 모노리식 아키텍처와 유사한 구조를 갖는다 각각의 서비스는 독립적으로 배포가 가능해야 한다 각각의 서비스는 다른 서비스에 대한 의존성이 작아야 한다 각 서비스는 개별 프로세스로 구동되며, REST API와 같은 가벼운 방식으로 통신되어야 한다 마이크로서비스 이점 민첩성 : 소규모 컨텍스트 내에서 활동하며 더 독립적이면서 신속하게 업무를 수행할 수 있다 유연한 확장성 : 서비스가 지원하는 애플리케이션을 기능의 수요를 충족하도록 해당 서비스를 독립적으로 확장할 수 있다 손쉬운 배포 마이크로서비스를 위한 조건 비용 개발 생산성 운영 인프라 배포 주기</description></item><item><title>쿠버네티스 및 MSA 특강 3일차 : 모니터링 시스템 구축 실습 (ELK), kubernetes</title><link>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-3%EC%9D%BC%EC%B0%A8/</link><pubDate>Wed, 22 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-3%EC%9D%BC%EC%B0%A8/</guid><description>모니터링 시스템 구축 실습 (ELK) ELK란 ELK는 Elasticsearch, Logstash 및 Kibana : 오픈 소스 프로젝트 세 개의 머리글
Elasticserach는 검색 및 분석 엔진 Logstash는 여러 소스에서 동시에 데이터를 수집하여 변환한 후 Elasticsearch 같은 &amp;ldquo;stash&amp;quot;로 전송하는 서버 사이드 데이터 처리 파이프라인 Kibana는 사용자가 Elasticsearch에서 차트와 그래프를 이용해 데이터를 시각화 Kibana Elasticsearch에 있는 데이터를 시각화할 수 있도록 하는 웹 브라우저 기반의 시각화 플랫폼
Elasticsearch에 있는 인덱스의 패턴을 찾아서, 데이터를 확인하거나, 시각화할 수 있도록 한다 Logstash 서버 데이터를 수집, 변환, 전송하는 데이터 처리 파이프라인으로, Jruby(JVM 기반 Ruby)로 개발되었다</description></item><item><title>쿠버네티스 및 MSA 특강 2일차 : Docker 실습</title><link>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-2%EC%9D%BC%EC%B0%A8/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-2%EC%9D%BC%EC%B0%A8/</guid><description>Docker 실습 Docker란 무엇인가 Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼
Docker를 사용하는 이유 개선되고 완벽한 이식성 경량의 중량, 미세한 업데이트 자동화된 컨테이너 작성 컨테이너 버전화 컨테이너 재사용 공유 컨테이너 라이브러리 Docker 오케스트레이션 - Kubernetes Kubernetes는 Google에서 내부용으로 개발된 프로젝트에서 파생된 오픈소스 컨테이너 오케스트레이션 플랫폼 Docker에 자체 오케스트레이션 툴 (Docker Swarm)이 포함되어 있지만, 대부분의 개발자는 그 대신 Kubernetes를 선택한다 Kubernetes는 컨테이너 배치, 업데이트, 서비스감지, 스토리지 프로비저닝, 로드 밸런싱, 상태 모니터링 등을 포함하여 컨테이너 기반 아키텍처의 관리에 필수적인 태스크를 스케줄링하고 자동화한다</description></item><item><title>쿠버네티스 및 MSA 특강 1일차 : 클라우드 컴퓨팅 개념 및 역사</title><link>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-1%EC%9D%BC%EC%B0%A8/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/kubernetes/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-1%EC%9D%BC%EC%B0%A8/</guid><description>클라우드 제대로 이해하기 클라우드란 개인이 가진 단말기를 통해서는 주로 입/출력 작업만 이루어지고, 정보분석 및 처리, 저장, 관리 유통 등의 작업은 클라우드라고 불리는 제3의 공간에서 이루어지는 컴퓨팅 시스템 형태
클라우드 컴퓨팅이 필요한 이유 비용절감 속도향상 확장성 생산성 클라우드 컴퓨팅 서비스모델 Infrastructure as a Service (IaaS) : IT리소스에 대한 유연성과 관리 제어 기능을 제공 GCE, AWS, Azure Platform as a Service (Paas) : 빌드 및 배포를 위한 환경이 사용자에게 제공 Openshift, Github, docker, kubernetes Software as a a Service (Saas) : 완전한 제품 제공 GShift 비교 On-site &amp;lt; Iaas &amp;lt; Paas &amp;lt; Saas</description></item><item><title>14938 : 서강그라운드 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_14938/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14938/</guid><description>N, M, R = map(int, input().split()) item = list(map(int, input().split())) G = [[] for _ in range(N)] for _ in range(R): a, b, c = map(int, input().split()) G[a-1].append((b-1, c)) G[b-1].append((a-1, c)) def dfs(node, dist): global result if dist &amp;gt; M: return if not visit[node]: result += item[node] visit[node] = True for n_node, n_dist in G[node]: dfs(n_node, dist+n_dist) max_result = 0 for i in range(N): result = 0 visit = [False]*N dfs(i, 0) max_result = max(max_result, result) print (max_result) 분류에 다익스트라, 플로이드-워셜로 되어있지만 DFS로 풀었다 풀이 방법 여기서는 재방문 했다고 해서 탐색을 하지 않으면 안된다 재방문했을때 전에 방문했을 때보다 더 짧은 통로로 들어왔다면 더 많은 아이템을 얻을 수 있기 때문이다 다만, 아이템은 방문할 때마다 얻을 수 있는 것이 아니기 때문에 주의하여야 한다 위의 내용을 질문게시판을 보다가 깨닫고 풀 수 있었다</description></item><item><title>1167 : 트리의 지름 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1167/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1167/</guid><description>import sys sys.setrecursionlimit(10**6) input = sys.stdin.readline V = int(input()) G = [[] for _ in range(V)] for _ in range(V): token = list(map(int, input().split()))[:-1] for i in range(1, len(token), 2): G[token[0]-1].append((token[i]-1, token[i+1])) def dfs(node, dist): global max_node, max_dist visited[node] = True if dist &amp;gt; max_dist: max_node = node max_dist = dist for n_node, n_dist in G[node]: if not visited[n_node]: dfs(n_node, dist+n_dist) max_node = 0 max_dist = 0 visited = [False]*V dfs(0, 0) max_dist = 0 visited = [False]*V dfs(max_node, 0) print (max_dist) 최근에 푼 &amp;ldquo;1967: 트리의 지름&amp;rdquo; 덕분에 쉽게 해결할 수 있었다 기억하자 트리의 지름 = (어떤 한 정점에서 가장 먼 점 P)에서 가장 먼 점 사이의 거리</description></item><item><title>1967 : 트리의 지름(G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1967/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1967/</guid><description>import sys sys.setrecursionlimit(10**6) M = int(input()) G = [[] for _ in range(M)] for _ in range(M-1): a, b, c = map(int, input().split()) G[a-1].append((b-1, c)) G[b-1].append((a-1, c)) n1 = 0 tmp = 0 def dfs(node, length): global n1, tmp visit[node] = True if length &amp;gt; tmp: tmp = length n1 = node for child, v in G[node]: if not visit[child]: dfs(child, length+v) visit = [False]*M dfs(0, 0) tmp = 0 visit = [False]*M dfs(n1, 0) print (tmp) 인터넷에서 접근 방법을 참고했다 해결 방법 아무 정점에서 가장 먼 어떤 정점을 N이라고 하자 정점 N에서 가장 먼 정점 사이의 거리가 트리의 지름과 같다 느낀 점 루트를 구할 필요가 없다는 것을 깨달았다</description></item><item><title>15681 : 트리와 쿼리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15681/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15681/</guid><description>import sys sys.setrecursionlimit(10**6) input = sys.stdin.readline N, R, Q = map(int, input().split()) G = [[] for _ in range(N)] cnt = [1]*N visited = [False]*N for _ in range(N-1): a, b = map(int, input().split()) G[a-1].append(b-1) G[b-1].append(a-1) def dfs(node): visited[node] = True for i in G[node]: if not visited[i]: cnt[node] += dfs(i) return cnt[node] dfs(R-1) for _ in range(Q): print (cnt[int(input())-1]) 혼자 풀었다!
서브트리에 속한 정점의 수를 memoization해놓고 쿼리마다 index의 값을 출력하면 된다</description></item><item><title>2502 : 떡 먹는 호랑이 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_2502/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2502/</guid><description>D, K = map(int, input().split()) L = [(1, 0), (0, 1)] for i in range(2, D): L.append((L[i-2][0]+L[i-1][0], L[i-2][1]+L[i-1][1])) A = 1 B = 2 while True: if A*L[D-1][0] + B*L[D-1][1] == K: break if A+1 == B: B += 1 A = 1 else: A += 1 print (A,&amp;#39;\n&amp;#39;,B, sep=&amp;#39;&amp;#39;) 해결방법 N번째날 떡 개수를 구하기 위해 첫째날 떡, 둘째날 떡을 각각 몇번 더해야하는지 리스트에 구한다 첫째, 둘째 날 떡을 하나하나 넣어보면서 브루트 포스를 수행한다</description></item><item><title>13398 : 연속합 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_13398/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_13398/</guid><description>N = int(input()) L = list(map(int, input().split())) res = 0 dp = [[-1000]*N for _ in range(2)] dp[0][0] = L[0] for i in range(1, N): dp[0][i] = max(dp[0][i-1]+L[i], L[i]) dp[1][i] = max(dp[1][i-1]+L[i], dp[0][i-1]) print (max(max(dp[0]), max(dp[1]))) 이번 문제에서 사용할 dp 배열의 크기는 N X 2 이다. 배열은 최솟값인 -1000으로 초기화하여야 한다</description></item><item><title>15486 : 퇴사 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15486/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15486/</guid><description>import sys input = sys.stdin.readline N = int(input()) T = [] P = [] dp = [0]*(N+1) for _ in range(N): a, b = map(int, input().split()) T.append(a) P.append(b) for i in range(N-1, -1, -1): if i+T[i] &amp;gt; N: dp[i] = dp[i+1] else: dp[i] = max(P[i]+dp[i+T[i]], dp[i+1]) print (dp[0]) dp라는 변수를 만들어야하는데 안 만들고 리스트 P만 가지고 memoization 하려다 실패했다 점화식은 잘 적었으나 조건문이 잘 못되어서 다른 풀이를 참고했다</description></item><item><title>MVC 3 : Session, Interceptor, Cookies</title><link>https://bong-u.github.io/til/spring/13_mvc_3/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/13_mvc_3/</guid><description>Session 로그인 할 때 세션에 등록 LoginController.java @PostMapping public String submit(LoginCommand loginCommand, Errors errors, HttpSession session) { new LoginCommandValidator().validate(loginCommand, errors); if (errors.hasErrors()) { return &amp;#34;login/loginForm&amp;#34;; } try { AuthInfo authInfo = authService.authenticate(loginCommand.getEmail(), loginCommand.getPassword()); session.setAttribute(&amp;#34;authInfo&amp;#34;, authInfo); return &amp;#34;login/loginSuccess&amp;#34;; } catch (WrongIdPasswordException e) { errors.reject(&amp;#34;idPasswordNotMatching&amp;#34;); return &amp;#34;login/loginForm&amp;#34;; } } 로그아웃 할때 세션에서 삭제 LogoutController.java @RequestMapping(&amp;#34;/logout&amp;#34;) public String logout(HttpSession session) { session.invalidate(); return &amp;#34;redirect:/main&amp;#34;; } 로그인 상태 여부에 따라 다르게 보여주기 &amp;lt;c:if test=&amp;#34;${ empty authInfo }&amp;#34;&amp;gt; &amp;lt;p&amp;gt;환영합니다.</description></item><item><title>2631 : 줄세우기 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2631/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2631/</guid><description>N = int(input()) L = [] for i in range(N): L.append(int(input())) dp = [1]*N for i in range(N): for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 활용한 문제이다 풀이 유도는 잘했으나 LIS가 헷갈려서 전에 풀었던 코드를 참고하였다</description></item><item><title>1915 : 가장 큰 정사각형 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1915/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1915/</guid><description>N, M = map(int, input().split()) L = [list(map(int, input())) for _ in range(N)] dp = [[0]*(M+1) for _ in range(N+1)] result = 0 for i in range(1, N+1): for j in range(1, M+1): dp[i][j] = L[i-1][j-1] if L[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 result = max(result, dp[i][j]) for i in dp: print (i) print (result**2) 조금 시간이 걸렸지만 혼자 힘으로 풀었다 점화식은 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1이다. 모두 0이면 0, 하나라도 1이면 1이 답이라는 것을 생각해야 한다.</description></item><item><title>1918 : 후위 표기식 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1918/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1918/</guid><description>string = list(input()) priority = {&amp;#39;(&amp;#39;:0, &amp;#39;)&amp;#39;:0, &amp;#39;+&amp;#39;:1, &amp;#39;-&amp;#39;:1, &amp;#39;*&amp;#39;:2, &amp;#39;/&amp;#39;:2} operator = [] result = &amp;#39;&amp;#39; for c in string: if c.isalpha(): result += c elif c == &amp;#39;(&amp;#39;: operator.append(c) elif c == &amp;#39;)&amp;#39;: while operator: op = operator.pop() if op == &amp;#39;(&amp;#39;: break result += op else: if operator: if priority[operator[-1]] &amp;lt; priority[c]: operator.append(c) else: while operator and priority[operator[-1]] &amp;gt;= priority[c]: result += operator.pop() operator.append(c) else: operator.append(c) while operator: result += operator.</description></item><item><title>9252 : LCS 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_9252/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9252/</guid><description>S1 = list(input()) S2 = list(input()) N1 = len(S1)+1 N2 = len(S2)+1 dp = [[0]*(N1) for _ in range(N2)] for i in range(1, N2): for j in range(1, N1): if S2[i-1] == S1[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) i = N2-1 j = N1-1 print (dp[i][j]) if dp[i][j] == 0: exit() result = &amp;#39;&amp;#39; while True: if i==0 or j==0: break if dp[i][j] == dp[i-1][j]: i -= 1 elif dp[i][j] == dp[i][j-1]: j -= 1 else: result = S1[j-1] + result i -= 1 j -= 1 print (result) 점화식을 잘못 세웠었다 문자가 같은 경우에 max(dp[i-1][j], dp[i][j-1])+1이 아닌 dp[i-1][j-1]+1이다.</description></item><item><title>10942 : 팰린드롬? (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_10942/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10942/</guid><description>import sys input = sys.stdin.readline N = int(input()) L = list(map(int, input().split())) dp = [[0]*N for _ in range(N)] for i in range(N): dp[i][i] = 1 if i &amp;lt; N-1 and L[i] == L[i+1]: dp[i][i+1] = 1 for i in range(N, -1, -1): for j in range(i+1, N): if dp[i+1][j-1] and L[i] == L[j]: dp[i][j] = 1 for i in range(int(input())): S, E = map(int, input().split()) print (dp[S-1][E-1]) 인터넷을 참고했다 쉽지 않은 문제였다</description></item><item><title>Generics</title><link>https://bong-u.github.io/til/java/generics/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/generics/</guid><description>효과 : 타입안정성, 간결한 코드 Generic class public class Box&amp;lt;M, I&amp;gt; { private M material; private I item; ... } Box&amp;lt;Paper, String&amp;gt; box = new Box&amp;lt;Paper, String&amp;gt;(); Generic Function public class CoffeeMachine { public &amp;lt;T&amp;gt; Coffee makeCoffee(T capsule) { return new Coffee(capsule); } } CoffeeMachine coffeeMachine = new CoffeeMachine(); Colombian capsule = new Colombian(); coffeeMachine.&amp;lt;Colombian&amp;gt;makeCoffee(capsule); coffeeMachine.makeCoffee(capsule); Restrictions on Generics // BoxMaterial을 상속 받았으면서 Hard(인터페이스)를 구현한 클래스만 가능 public class Box&amp;lt;M extends BoxMaterial &amp;amp; Hard&amp;gt; // BoxMaterial의 조상 클래스만 가능 public class Box&amp;lt;T super BoxMaterial&amp;gt; Whild Card // T와 그 자손만 가능 &amp;lt;?</description></item><item><title>MVC 2 : Messages, Validate command object</title><link>https://bong-u.github.io/til/spring/12_mvc_2/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/12_mvc_2/</guid><description>Messages label.properties member.register=회원가입 &amp;lt;%@ taglib prefix=&amp;#34;spring&amp;#34; uri=&amp;#34;http://www.springframework.org/tags&amp;#34; %&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;spring:message code=&amp;#34;member.register&amp;#34; /&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; 사이트가 여러 언어를 지원해야할 때 label_ko.properties, label_en.properties와 같이 만든다고 한다 http헤더의 Accept-Launguage를 자동으로 인식한다고 하니까 편할 것 같다 Validate command object Validation RegisterRequestValidator @Override public void validate(Object target, Errors errors) { RegisterRequest regReq = (RegisterRequest) target; if(regReq.getEmail() == null | regReq.getEmail().trim().isEmpty()) { errors.rejectValue(&amp;#34;email&amp;#34;, &amp;#34;bad&amp;#34;); } else { Matcher matcher = pattern.matcher(regReq.getEmail()); if(!</description></item><item><title>5582 : 공통 부분 문자열 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5582/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5582/</guid><description>S1 = list(input()) S2 = list(input()) L1 = len(S1)+1 L2 = len(S2)+1 dp = [[0]*L1 for _ in range(L2)] result = 0 for i in range(1, L2): for j in range(1, L1): if S1[j-1] == S2[i-1]: dp[i][j] = dp[i-1][j-1]+1 result = max(result, dp[i][j]) print (result) 혼자 힘으로 해결! 깔끔한 풀이가 나와 기분이 좋다</description></item><item><title>5557 : 1학년 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5557/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5557/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [[0]*21 for _ in range(N-1)] dp[0][L[0]] = 1 for i in range(0, N-2): for j in range(21): if dp[i][j] != 0: k = L[i+1] if k != 0: if 0 &amp;lt;= j+k &amp;lt;= 20: dp[i+1][j+k] += dp[i][j] if 0 &amp;lt;= j-k &amp;lt;= 20: dp[i+1][j-k] += dp[i][j] else: dp[i+1][j] = dp[i][j]*2 print (dp[N-2][L[-1]]) 혼자 힘으로 풀었다! 이전에 비슷한 dp 문제를 풀어본 적이 있어서 쉽게 풀 수 있었다</description></item><item><title>10164 : 격자상의 경로 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10164/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10164/</guid><description>N, M, K = map(int, input().split()) K -= 1 ox = K % M oy = K // M def solve(sx, sy, ex, ey): dp = [[0]*M for _ in range(N)] dp[sy][sx] = 1 for i in range(sy, ey+1): for j in range(sx, ex+1): if i-1 &amp;gt;= 0: dp[i][j] += dp[i-1][j] if j-1 &amp;gt;= 0: dp[i][j] += dp[i][j-1] return dp[ey][ex] if K != -1: print (solve(0, 0, ox, oy) * solve(ox, oy, M-1, N-1)) else: print (solve(0, 0, M-1, N-1)) 혼자 힘으로 해결하였다!</description></item><item><title>2011 : 암호코드 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2011/</link><pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2011/</guid><description>L = list(input()) N = len(L) MOD = 10**6 def solution(): if L[0] == &amp;#39;0&amp;#39;: return 0 dp = [1, 1]+[0]*(N-1) for i in range(2, N+1): if L[i-1] != &amp;#39;0&amp;#39;: dp[i] = (dp[i]+dp[i-1]) % MOD if 10 &amp;lt;= int(L[i-2]+L[i-1]) &amp;lt;= 26: dp[i] = (dp[i]+dp[i-2]) % MOD return dp[N] print (solution()) 인터넷을 참고하여 풀었다</description></item><item><title>1495 : 기타리스트 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1495/</link><pubDate>Fri, 27 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1495/</guid><description>N, S, M = map(int, input().split()) P = list(map(int, input().split())) dp = [[False]*(M+1) for _ in range(N+1)] dp[0][S] = True for i in range(1, N+1): for j in range(M+1): if dp[i-1][j]: if 0 &amp;lt;= j-P[i-1] &amp;lt;= M: dp[i][j-P[i-1]] = True if 0 &amp;lt;= j+P[i-1] &amp;lt;= M: dp[i][j+P[i-1]] = True result = -1 for i in range(M+1): if dp[N][i]: result = i print (result) 인터넷에서 접근을 참고했다</description></item><item><title>16194 : 카드 구매하기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_16194/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_16194/</guid><description>N = int(input()) P = list(map(int, input().split())) dp = [10000000]*(N) for i in range(N): for j in range(i): dp[i] = min(dp[i], dp[j]+P[i-j-1]) dp[i] = min(dp[i], P[i]) print (dp[N-1])</description></item><item><title>1965 : 상자넣기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1965/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1965/</guid><description>N = int(input()) L = list(map(int, input().split())) dp = [0]*N for i in range(1, N): for j in range(i): if L[j]&amp;lt;L[i] and dp[i]&amp;lt;dp[j]+1: dp[i] = dp[j]+1 print(max(dp)+1) LIS를 구하는 문제이다</description></item><item><title>17070 : 파이프 옮기기 1 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_17070/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17070/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 0 def dfs(x, y, direc): global result if x == N-1 and y == N-1: result += 1 return if x+1 &amp;lt; N and y+1 &amp;lt; N and L[y+1][x] == 0 and L[y][x+1] == 0 and L[y+1][x+1] == 0: dfs(x+1, y+1, 2) if (direc == 0 or direc == 2) and x+1 &amp;lt; N and L[y][x+1] == 0: dfs(x+1, y, 0) if (direc == 1 or direc == 2) and y+1 &amp;lt; N and L[y+1][x] == 0: dfs(x, y+1, 1) dfs(1, 0, 0) print(result) 별거 아닌게.</description></item><item><title>React - build 이후 빈 화면만 나오는 문제</title><link>https://bong-u.github.io/til/javascript/react_deploy_issue/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/javascript/react_deploy_issue/</guid><description>build 결과물을 돌리면 빈 화면만 나오는 문제 static files 로딩에 성공했는지 확인하자 문제가 있다면 index.html의 경로를 수정하자 react-router를 사용하고 있다면 url을 확인하자 deploy할때 root url이 아니라면 router에 basename을 추가해줘야한다. &amp;lt;Router basename=&amp;#34;/index&amp;#34;&amp;gt;...&amp;lt;/Router&amp;gt;</description></item><item><title>React - environment variable 설정하기</title><link>https://bong-u.github.io/til/javascript/react_env_var/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/javascript/react_env_var/</guid><description> 프로그램이 개발/배포 상황에 따라 변수를 달리해야 할 때가 있다. 이때 react에서는 .env.development , .env.production 파일을 만들어서 환경변수를 쉽게 관리할 수 있다. react는 앞에 &amp;lsquo;REACT_APP&amp;rsquo; 을 붙여야 인식이 된다고한다. 설정 .env.development REACT_APP_HOST=localhost .env.production REACT_APP_HOST=192.168.0.1 사용 ${process.env.REACT_APP_HOST}</description></item><item><title>React - useEffect 사용법</title><link>https://bong-u.github.io/til/javascript/react_useeffect/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/javascript/react_useeffect/</guid><description> component가 rendering 될 때 실행 useEffect(()=&amp;gt; { ... }); component가 mount 될 때 (처음 rendering 될 때) 실행 useEffect(()=&amp;gt; { ... }, []); component가 update 될 때 (props, states가 바뀔 때) 실행 useEffect(()=&amp;gt; { ... }, [{ props or states }]); component가 unmount 될 때 또는 update되기 직전에 실행 useEffect(()=&amp;gt; { return () =&amp;gt; { ... }; }, []);</description></item><item><title>12852 : 1로 만들기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_12852/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12852/</guid><description>N = int(input()) dp = [0, 0] + [10**6]*(N-1) bt = [0]*(N+1) for i in range(2, N+1): dp[i] = min(dp[i-1]+1, dp[i]) bt[i] = i-1 if i%3 == 0: if dp[i//3]+1 &amp;lt; dp[i]: dp[i] = dp[i//3]+1 bt[i] = i//3 if i%2 == 0: if dp[i//2]+1 &amp;lt; dp[i]: dp[i] = dp[i//2]+1 bt[i] = i//2 dp[i] = min(dp[i], dp[i//2]+1) print(dp[N]다 i = N while i != 1: print (i, end=&amp;#39; &amp;#39;) i = bt[i] print (1) dp 아직 많이 멀었다는 생각이 든다</description></item><item><title>MVC 1 : Request Mapping, Command Object, Redirect, Form Tag, Model</title><link>https://bong-u.github.io/til/spring/11_mvc_1/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/11_mvc_1/</guid><description>Request Mapping GetMapping/PostMapping으로 처리할 method를 지정하거나 RequestMapping을 사용할 수 있다. Access request parameter : HttpServletRequest @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2(HttpServletRequest request) { String agreeParam = request.getParameter(&amp;#34;agree&amp;#34;); if (agreeParam == null || !agreeParam.equals(&amp;#34;true&amp;#34;)) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Access request parameter : RequestParam Annotation @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2( @RequestParam(value=&amp;#34;agree&amp;#34;, defaultValue=&amp;#34;false&amp;#34;) Boolean agree) { if (!agree) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Redirect @GetMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2Get() { return &amp;#34;redirect:/register/step1&amp;#34;; Command Object Use request parameter as command object RegisterController.</description></item><item><title>React - column을 기준으로 정렬하기</title><link>https://bong-u.github.io/til/javascript/react_table_sort/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/javascript/react_table_sort/</guid><description>Table에 있는 데이터들을 column별로 정렬해야 한다 데이터의 형식에 따라 comparator를 따로 구현하였다 const comparatorStr = (a, b, order) =&amp;gt; { if (order === Order.ASC) return a.localeCompare(b); return b.localeCompare(a); }; const comparatorInt = (a, b, order) =&amp;gt; { if (order === Order.ASC) return a &amp;gt; b ? 1 : -1; return a &amp;lt; b ? 1 : -1; }; 정렬할 키나 순서가 바뀔때 마다 정렬을 수행한다 useEffect(() =&amp;gt; { if (sortBy === Key.</description></item><item><title>2096 : 내려가기 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2096/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2096/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp1 = [L[0][i] for i in range(3)] dp2 = [L[0][i] for i in range(3)] for i in range(1, N): tmp1 = [0]*3 tmp2 = [0]*3 for j in range(3): if j == 0: tmp1[0] = L[i][j] + max(dp1[0], dp1[1]) tmp2[0] = L[i][j] + min(dp2[0], dp2[1]) elif j == 1: tmp1[1] = L[i][j] + max(dp1[0], dp1[1], dp1[2]) tmp2[1] = L[i][j] + min(dp2[0], dp2[1], dp2[2]) else: tmp1[2] = L[i][j] + max(dp1[1], dp1[2]) tmp2[2] = L[i][j] + min(dp2[1], dp2[2]) dp1 = [i for i in tmp1] dp2 = [i for i in tmp2] print (max(dp1), min(dp2)) Memoization과정이 다른 memoization 변수에 대해 종속적이라면 잘못된 결과를 초래한다 위 코드에서는 이를 방지하기 위해 tmp1, tmp2 변수를 사용한다 깊이 생각하지 않고 여러 번 제출해서 WA개수가 조금 많다;;</description></item><item><title>1890 : 점프 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1890/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1890/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] dp = [[0]*N for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(N): if L[i][j] == 0: continue if dp[i][j] != 0: right = j+L[i][j] bottom = i+L[i][j] if right &amp;lt; N: dp[i][right] += dp[i][j] if bottom &amp;lt; N: dp[bottom][j] += dp[i][j] print (dp[N-1][N-1]) dp에 있는 값을 더해야하는데 1을 더해서 몇 번 틀렸다 거의 혼자 힘으로 풀었다</description></item><item><title>1309 : 동물원 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1309/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1309/</guid><description>N = int(input()) dp = [1, 3] + [0]*(N-1) for i in range(2, N+1): dp[i] = (dp[i-1]*2 + dp[i-2]) % 9901 print(dp[N]) 고민 끝에 답을 찾아보긴 했다 점화식 생각해내는 놈들 머리에 뭐가 든건지 모르겠다</description></item><item><title>9655 : 돌게임 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_9655/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9655/</guid><description>N = int(input()) print (&amp;#39;CY&amp;#39; if N%2==0 else &amp;#39;SK&amp;#39;) 게임이론에서 기초 중 기초 문제이다</description></item><item><title>08_connect_DB</title><link>https://bong-u.github.io/til/spring/08_connect_db/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/08_connect_db/</guid><description>DataSource 설정 AppCtx.java @Bean(destroyMethod = &amp;#34;close&amp;#34;) public DataSource dataSource() { DataSource ds = new DataSource(); ds.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); ds.setUrl(&amp;#34;jdbc:mysql://localhost/spring5fs?&amp;#34;+ &amp;#34;enabledTLSProtocols=TLSv1.2&amp;amp;&amp;#34;+ &amp;#34;useSSL=false&amp;amp;&amp;#34;+ &amp;#34;characterEncoding=utf8&amp;#34;); ds.setUsername(&amp;#34;spring5&amp;#34;); ds.setPassword(&amp;#34;spring5&amp;#34;); ds.setInitialSize(2); ds.setMaxActive(10); ds.setTestWhileIdle(true); ds.setMinEvictableIdleTimeMillis(60000 * 3); ds.setTimeBetweenEvictionRunsMillis(10 * 1000); return ds; } Query 실행 JdbcTemplate을 이용한 select jdbcTemplate.query( &amp;#34;select * from MEMBER where EMAIL = ?&amp;#34;, new RowMapper&amp;lt;Member&amp;gt;() { @Override public Member mapRow(ResultSet rs, int rowNum) throws SQLException { Member member = new Member( rs.getString(&amp;#34;EMAIL&amp;#34;), rs.getString(&amp;#34;PASSWORD&amp;#34;), rs.</description></item><item><title>1010 : 다리놓기 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_1010/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1010/</guid><description>import math for _ in range(int(input())): a, b = map(int, input().split()) print(math.comb(max(a,b), min(a,b)))</description></item><item><title>10844 : 쉬운 계단 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10844/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10844/</guid><description> 접근이 어려워 인터넷을 참고했다. 코드는 보지 않았다. 수의 길이가 i이면서 마지막 숫자가 j인 계단 수의 개수를 저장하는 것이 핵심이다. 점화식은 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 이다. N = int(input()) L = [[0]*12 for _ in range(100)] L[0] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] for i in range(1, N): for j in range(1, 11): L[i][j] = L[i-1][j-1]+L[i-1][j+1] print (sum(L[N-1])%1000000000)</description></item><item><title>11048 : 이동하기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11048/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11048/</guid><description>N, M = map(int, input().split()) dp = [list(map(int, input().split())) for _ in range(N)] for i in range(1, N): dp[i][0] = dp[i][0]+dp[i-1][0] for i in range(1, M): dp[0][i] = dp[0][i]+dp[0][i-1] for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i][j]+max(dp[i-1][j], dp[i][j-1]) print (dp[N-1][M-1])</description></item><item><title>11051 : 이항계수2 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11051/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11051/</guid><description> 내장 함수 사용
import math N, K = map(int, input().split()) print (math.comb(N, K)%10007 파스칼의 사각형? dp 구현
N, K = map(int, input().split()) if K == 0: print(1) exit() dp = [[0]*N for _ in range(K)] for i in range(N): dp[0][i] = i+1 for i in range(1, K): for j in range(i, N): dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % 10007 print (dp[K-1][N-1])</description></item><item><title>11052 : 카드 구매하기 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11052/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11052/</guid><description>N = int(input()) P = list(map(int, input().split())) D = [P[0]]+[0]*(N-1) for i in range(1, N): for j in range(1, i+1): D[i] = max(D[i-j]+P[j-1], D[i]) D[i] = max(P[i], D[i]) print (D[N-1]</description></item><item><title>11057 : 오르막 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11057/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11057/</guid><description>N = int(input()) dp = [[1]+[0]*9 for _ in range(N+1)] for i in range(1, N+1): for j in range(1, 10): dp[i][j] = dp[i-1][j]+dp[i][j-1] print (sum(dp[N])%10007)</description></item><item><title>14891 : 톱니바퀴 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_14891/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14891/</guid><description>from collections import deque wheels = [deque(map(int, list(input()))) for _ in range(4)] def rotate(wheel, direction): if direction == 1: wheel.appendleft(wheel.pop()) else: wheel.append(wheel.popleft()) return wheel K = int(input()) vd = [1, -1] res = 0 for _ in range(K): N, D = map(int, input().split()) q = deque() q.append((N-1, D)) visited = [False] * 4 tmp = [] while q: cur, curD = q.popleft() tmp.append((cur, curD)) visited[cur] = True for v in vd: nxt = cur+v if 0 &amp;lt;= nxt &amp;lt; 4 and not visited[nxt]: if (v == -1 and wheels[cur][6] !</description></item><item><title>15683 : 감시 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_15683/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15683/</guid><description>import copy, sys N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] cctv = [] direction = [[[(0, 1)], [(0, -1)], [(1, 0)], [(-1, 0)]], [[(-1, 0), (1, 0)], [(0, -1), (0, 1)]], [[(-1, 0), (0, -1)], [(0, -1), (1, 0)], [(1, 0), (0, 1)], [(0, 1), (-1, 0)]], [[(-1, 0), (0, -1), (1, 0)], [(0, -1), (1, 0), (0, 1)], [(1, 0), (0, 1), (-1, 0)], [(0, 1), (-1, 0), (0, -1)]], [[(-1, 0), (0, -1), (1, 0), (0, 1)]]] res = sys.</description></item><item><title>1699 : 제곱수의 합 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1699/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1699/</guid><description>N = int(input()) dp = [100000]*(N+1) tmp = 1 for i in range(1, N+1): if i**(1/2) % 1 == 0: dp[i] = 1 tmp += 1 else: for j in range(1, tmp): dp[i] = min(dp[i], dp[i-(j**2)]+1) print (dp[N])</description></item><item><title>17404 : RGB거리 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17404/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17404/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] result = 100000 for i in range(3): dp = [[0, 0, 0] for _ in range(N)] dp[0] = [10000]*3 dp[0][i] = L[0][i] for j in range(1, N): dp[j][0] = min(dp[j-1][1], dp[j-1][2])+L[j][0] dp[j][1] = min(dp[j-1][0], dp[j-1][2])+L[j][1] dp[j][2] = min(dp[j-1][0], dp[j-1][1])+L[j][2] dp[N-1][i] = 100000 result = min([result]+dp[N-1]) print (result) 인터넷을 참고하여 풀었다
첫째집 3가지 X 마지막집 3가지 = 9가지 이지만</description></item><item><title>2193 : 이친수 (S3)</title><link>https://bong-u.github.io/til/algorithm/boj_2193/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2193/</guid><description>N = int(input()) dp = [1]*N for i in range(2, N): dp[i] = dp[i-2]+dp[i-1] print (dp[N-1]) 피보나치였다</description></item><item><title>221207 SYSP</title><link>https://bong-u.github.io/til/school/sysp_09_11/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/sysp_09_11/</guid><description>09-process1 예외적인 제어 흐름 하위 매커니즘 예외 (Exception) 상위 매커니즘 프로세스 컨텍스트 전환 OS 소프트웨어와 하드웨어 타이머로 구현 시그널 OS 소프트웨어로 구현 nolocal 점프 예외 테이블 (Exception Tables) 각 이벤트 타입은 예외번호 k를 갖는다 비동기형 예외 (Interrupt) 입출력 인터럽트 (ctrl + c)
하드 리셋 인터러트
소프트 리셋 인터럽트</description></item><item><title>221208 SYSP</title><link>https://bong-u.github.io/til/school/sysp_12_13/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/sysp_12_13/</guid><description>12-memory-1 메모리에 관한 불편한 진실 메모리는 무한의 자원이 아니다 동적 메모리 할당 직접(explicit) vs 간접(implicit) 메모리 할당기 직접 할당 : 응용프로그램이 할당하고, 반환한다 ex) malloc, free 간접 할당 : 응용프로그램이 할당하지만, 반환하지는 않는다 ex) java의 garbage collector 프로세스의 메모리 이미지 스택은 아래로, 힙은 위로 성장한다 sbrk 함수가 추가적인 힙 메모리를 운영체제로부터 요청한다 (brk 포인터 이동) Malloc package #include &amp;lt;stdlib.</description></item><item><title>2225 - 합분해 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2225/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2225/</guid><description>N, K = map(int, input().split()) dp = [[0]*(N+1) for _ in range(K+1)] for i in range(1, K+1): dp[i][0] = 1 for i in range(1, K+1): for j in range(1, N+1): dp[i][j] = (dp[i-1][j] + dp[i][j-1])%1000000000 print (dp[K][N]) 내 힘으로 풀었다!</description></item><item><title>2294 : 동전 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2294/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2294/</guid><description>N, K = map(int, input().split()) V = [] for _ in range(N): V.append(int(input())) dp = [[0]+([10001]*K) for _ in range(N+1)] for i in range(1, N+1): for j in range(1, K+1): if j &amp;gt;= V[i-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-V[i-1]]+1) else: dp[i][j] = dp[i-1][j] res = dp[N][K] print (res if res != 10001 else -1) dp를 많이 풀어보자</description></item><item><title>2565 : 전깃줄 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2565/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2565/</guid><description>N = int(input()) L = [list(map(int, input().split())) for _ in range(N)] L = [i[1] for i in sorted(L)] dp = [0]*N for i in range(N): dp[i] = 1 for j in range(i): if L[j] &amp;lt; L[i]: dp[i] = max(dp[i], dp[j]+1) print (N-max(dp)) LIS를 이용하는 문제</description></item><item><title>2573 : 빙산 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2573/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2573/</guid><description>import copy from collections import deque N, M = map(int, input().split()) L = [list(map(int, input().split())) for _ in range(N)] L[0][0] = 0 L[N-1][M-1] = 0 vx = [0, 0, -1, 1] vy = [-1, 1, 0, 0] def melt(L): L_ = copy.deepcopy(L) for i in range(M): for j in range(N): if L[j][i] != 0: for k in range(4): nx = j + vx[k] ny = i + vy[k] if not 0 &amp;lt;= nx &amp;lt; N or not 0 &amp;lt;= ny &amp;lt; M: continue if L[nx][ny] == 0 and L_[j][i] !</description></item><item><title>2748 : 피보나치 수2 (B2)</title><link>https://bong-u.github.io/til/algorithm/boj_2748/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2748/</guid><description> &amp;ldquo;알고리즘 분류-DP&amp;quot;에서 안 푼 문제이길래 한 번 풀어봤다. N = int(input()) L = [0, 1] + [0]*89 for i in range(2, N+1): L[i] = L[i-1]+L[i-2] print (L[N])</description></item><item><title>Spring 개념 - AOP (Aspect Oriented Programming)</title><link>https://bong-u.github.io/til/spring/aop/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/aop/</guid><description>AOP (Aspect Oriented Programming) 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법 기본 개념 : 핵심 기능에 공통 기능을 삽입 구현하는 3가지 방법 컴파일 시점에 코드에 공통 기능을 삽입하는 방법 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법 AOP 주요 용어 Target 부가 기능을 부여할 대상
Advice 부가기능을 담고 있는 모듈</description></item><item><title>객체지향설계</title><link>https://bong-u.github.io/til/school/ood/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/ood/</guid><description>Dynamic dispatch and Multiple inheritance Polymorphism Function overloading using compile time types of arguments Function overriding using runtime types of receiver objects virtual function for dynamic dispatch dynamic dispatch를 사용하기 위한 조건
함수가 virtual keyword로 정의되어 있어야 한다.
receiver object가 포인터(*), 참조(&amp;amp;)를 통해 refer되어야 한다
// from parent class : Employee virtual std::string GetInfo() { return &amp;#34;Employee: &amp;#34; + name_ ; } // from child class : Developer std::string GetInfo() { return &amp;#34;Developer: &amp;#34; + name_; } override keyword override 키워드를 사용하는 이유 직관적인 코드</description></item><item><title>현대인의 생활문화</title><link>https://bong-u.github.io/til/school/mplc/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/school/mplc/</guid><description>글로벌 매너 매너 인간관계를 맺는데 있어 중요한 요소
어원 : Manus(손, 행동, 습관) + Arius(방법, 방식)
매너의 기본(1)
다른 사람의 인격을 존중하고, 배려하는 마음을 가지고, 편안하게 해주거나 기쁘게 만들려는 행동방식
매너의 기본(2)
역지사지 (易地思之)
매너의 기본(3)
형식에 치우치지 말고, 배려하는 마음을 전달하는 것
매너와 에티켓의 차이 매너(예의) : 상황에 따라 다르게 표현 가능 에티켓(범절) : 형식과 절차를 중요시 함 동양의 매너 5덕</description></item><item><title>09_spring_MVC</title><link>https://bong-u.github.io/til/spring/09_spring_mvc/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/09_spring_mvc/</guid><description>Spring MVC 시작하기 프로젝트 생성 앞에서 만들었던 자바 애플리케이션과는 좀 다른점이 있었다 jar이 아닌 war을 사용하는 등 여러가지 많았는데 일일이 적지는 않을 것이다 Controller @Controller public class HelloController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(Model model, @RequestParam(value=&amp;#34;name&amp;#34;, required=false) String name) { model.addAttribute(&amp;#34;greeting&amp;#34;, &amp;#34;안녕하세요&amp;#34; + name); return &amp;#34;hello&amp;#34;; } } JSP &amp;lt;%@ page contentType=&amp;#34;text/html; charset=utf-8&amp;#34; %&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 인사말 : ${greeting} &amp;lt;/body&amp;gt; &amp;lt;/html URL접속해도 해당 jsp파일이 나오지 않는 문제 vscode에서 community server connector라는 extension을 통해 tomcat을 띄워서 할려고 한다 특정 jsp를 감지했는지, serving하는지에 대한 로그가 없어 되는건지 알 수가 없다 web.</description></item><item><title>Spring 개념 - Autowired</title><link>https://bong-u.github.io/til/spring/autowired/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/autowired/</guid><description>@Autowired를 이용한 자동 객체 주입 방법1 : Field에 적용
public class MemberListPrinter { @Autowired private MemberDao memberDao; @Autowired private MemberPrinter printer; public MemberListPrinter() {} public void printAll() { Collection&amp;lt;Member&amp;gt; members = memberDao.selectAll(); members.forEach(m -&amp;gt; printer.print(m)); } } 방법2 : Method에 적용
public class MemberListPrinter { private MemberDao memberDao; private MemberPrinter printer; public MemberListPrinter() {} @Autowired public void setMemberDao(MemberDao memberDao) { this.memberDao = meberDao; } @Autowired public void setMemberPrinter(MemberPrinter memberPrinter) { this.</description></item><item><title>Spring 개념 - Bean Lifecycle &amp; Scope</title><link>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</guid><description>Bean 객체의 Lifecycle Bean 객체가 생성 또는 소멸될때 특정 코드를 실행하게 할 수 있다. @PostConstruct, @PreDestroy Annotation 사용
// Bean 객체 생성될 때 실행 @PostConstruct public void postConstruct() {...} // Bean 객체 소멸될 때 실행 @PreDestroy public void preDestroy() {...} InitializingBean, DisposableBean 구현
public class Client implements InitializingBean, DisposableBean { // Bean 객체 생성될 때 실행 @Override public void afterPropertiesSet() throws Exception {...} // Bean 객체 소멸될 때 실행 @Override public void destroy() throws Exception {.</description></item><item><title>Spring 개념 - Component Scan</title><link>https://bong-u.github.io/til/spring/component_scan/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/component_scan/</guid><description>개념 Component Scan은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다 xml 또는 annotation을 통해 사용 가능하다 @ComponentScan basePacakges : 패키지 이름을 통해 스캔할 범위를 지정한다
@ComponentScan(basePackages=&amp;#34;org.academy.order&amp;#34;) @ComponentScan(basePackages={&amp;#34;org.academy.order&amp;#34;, &amp;#34;org.academy.voucher&amp;#34;}) basePackageClasses : 해당 클래스가 들어있는 패키지를 범위로 지정한다
@ComponentScan(basePackageClasses=&amp;#34;Order.class&amp;#34;) @ComponentScan(basePackages={&amp;#34;Order.class&amp;#34;, &amp;#34;Voucher.class&amp;#34;}) 예제 AppCtx.java
@Configuration @ComponentScan(basePackages = {&amp;#34;spring&amp;#34;}) public class AppCtx {...} MemberInfoPrinter.java
@Component(&amp;#34;infoPrinter&amp;#34;) public class MemberInfoPrinter {...} 효과</description></item><item><title>Spring 개념 - DI (Dependency Injection)</title><link>https://bong-u.github.io/til/spring/di/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/di/</guid><description>의존 주입 (DI : Dependency Injection)을 하는 방법 Assembler라는 별도의 클래스 생성
public class Assembler { private MemberDao memberDao; private MemberRegisterService regSvc; public Assembler() { memberDao = new MemberDao(); regSvc = new MemberRegisterService(memberDao); } public MemberDao getMemberDao() { return memberDao; } public MemberRegisterService getMemberRegisterService() { return regSvc; } } Spring에서 지원하는 DI 사용
@Configuration public class AppCtx { @Bean public MemberDao memberDao() { return new MemberDao(); } @Bean public MemberRegisterService memberRegSvc() { return new MemberRegisterService(memberDao()); } } DI 방식 Constructor 방식 @Bean public MemberListPrinter listPrinter() { return new MemberListPrinter(memberDao(), memberPrinter()); } Setter method 방식 @Bean public MemberInfoPrinter infoPrinter() { MemberInfoPrinter infoPrinter = new MemberInfoPrinter(); infoPrinter.</description></item><item><title>Spring 개념 - Testing</title><link>https://bong-u.github.io/til/spring/testing/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/testing/</guid><description>Unit Test (단위 테스트) 가장 작은 단위 (클래스 또는 메소드)를 고립시켜서 테스트하는 방식
관련 용어 SUT (Sytem Under Test) 테스트하고자하는 주요 대상이 되는 Unit
DOC (Depended On Component) SUT가 의존하는 객체
Test double DOC를 대신해 줄 수 있는 객체
Test double의 종류 : Mock, Stub Mock 행위 검증 (객체가 특정 동작을 수행하는지 검증) 사용 test framework : Mockito, JMock, EasyMock Stub 상태 검증 (객체의 상태를 확인하여 검정) 사용 Integration Test (통합 테스트) 여러 개의 Unit을 통합해서 테스트하는 방식</description></item></channel></rss>
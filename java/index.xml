<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>♨|Java on Bong-u's TIL</title><link>https://bong-u.github.io/til/java/</link><description>Recent content in ♨|Java on Bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://bong-u.github.io/til/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Method reference (메소드 참조)</title><link>https://bong-u.github.io/til/java/method_reference/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/method_reference/</guid><description>메소드 참조 메소드 참조는 Java 8부터 도입되었다 lambda와 같이 사용하면 간결한 코드를 만들 수 있다 정적 메소드 참조의 문법 1// lambda 식 2(str) -&amp;gt; String.toString(str); 3// 정적 메소드 참조 4String::toString 인스턴스 메소드 참조의 문법 1Person person; 2// lambda 식 3(age) -&amp;gt; person.setAge(); 4// 인스턴스 메소드 참조 5person::setAge 활용 1// lambda식 2getItems.forEach(item -&amp;gt; System.out.println(item)); 3// 메소드 참조 4getItems.forEach(System.out::println);</description></item><item><title>Java - 이중 중괄호와 Anti-Pattern</title><link>https://bong-u.github.io/til/java/double_brace_initialization/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/double_brace_initialization/</guid><description>기존 코드 1Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 2map.put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); 3map.put(&amp;#34;name&amp;#34;, customer.getName()); 4map.put(&amp;#34;email&amp;#34;, customer.getEmail()); 5map.put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); 6return map; Double Brace Initialization 적용 후 1return new HashMap&amp;lt;&amp;gt;() {{ 2 put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); 3 put(&amp;#34;name&amp;#34;, customer.getName()); 4 put(&amp;#34;email&amp;#34;, customer.getEmail()); 5 put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); 6}}; 효과 장점 코드가 가독성이 좋아진다 단점 추가로 익명 클래스를 사용한다 -&amp;gt; 메모리 추가 사용
인스터스 및 개체에 대한 숨겨진 참조를 가진다 -&amp;gt; Memory Leak 유발 가능</description></item><item><title>Try with resources로 간결하게 반납하기</title><link>https://bong-u.github.io/til/java/try_with_resources/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/try_with_resources/</guid><description>기존 코드 - try-catch-finally 사용 1Connection connection = null; 2Statement statement = null; 3ResultSet resultSet = null; 4 5try { 6 connection = DriverManager.getConnection(/* SECRET */); 7 statement = connection.createStatement(); 8 9 resultSet = statement.executeQuery(&amp;#34;select * from customers&amp;#34;); 10 11 while (resultSet.next()) { 12 var name = resultSet.getString(&amp;#34;name&amp;#34;); 13 var customerId = UUID.nameUUIDFromBytes(resultSet.getBytes(&amp;#34;customer_id&amp;#34;)); 14 logger.info(&amp;#34;Customer id:{}, name: {}&amp;#34;, customerId, name); 15 } 16} catch (SQLException e) { 17 logger.error(&amp;#34;Error while connecting to DB&amp;#34;, e); 18 throw e; 19} 20finally { 21 try { 22 if (connection !</description></item><item><title>Record</title><link>https://bong-u.github.io/til/java/record/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/record/</guid><description>레코드란 불변(immutable) 데이터 객체를 쉽게 생성할 수 있도록 하는 새로운 유형의 클래스 JDK16부터 지원 예제 Record 적용 전
1public class Person { 2 private final String name; 3 private final int age; 4 5 public Person(String name, int age) { 6 this.name = name; 7 this.age = age; 8 } 9 10 public String getName() { 11 return name; 12 } 13 14 public int getAge() { 15 return age; 16 } 17} Record 적용 후</description></item><item><title>Stream, Optional</title><link>https://bong-u.github.io/til/java/stream/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/stream/</guid><description>Lambda 표현식 매개변수 화살표(-&amp;gt;) 함수몸체로 이용하여 사용할 수 있습니다. 함수 몸체가 단일 실행문이면 괄호{}를 생략할 수 있습니다. 함수 몸체가 return문으로만 구성되어 있으면 괄호{}을 생략할 수 있습니다. 1(int x) -&amp;gt; x+1; 2(int x, int y) -&amp;gt; x+y; 3(Thread lamT) -&amp;gt; { lamT.start(); } Stream 특징 원본 데이터를 변경하지 않습니다. 요청되었을때만 데이터를 처리한다. parallelStream()을 이용하여 병렬처리가 가능하다. 예제1 1List&amp;lt;String&amp;gt; highCaloriesFoodName = foodList.stream() 2 .filter(food -&amp;gt; { 3 System.out.println(&amp;#34;filter : &amp;#34; + food.</description></item><item><title>Generics</title><link>https://bong-u.github.io/til/java/generics/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/java/generics/</guid><description>효과 : 타입안정성, 간결한 코드 Generic class 1public class Box&amp;lt;M, I&amp;gt; { 2 private M material; 3 private I item; 4 ... 5} 6 7Box&amp;lt;Paper, String&amp;gt; box = new Box&amp;lt;Paper, String&amp;gt;(); Generic Function 1public class CoffeeMachine { 2 public &amp;lt;T&amp;gt; Coffee makeCoffee(T capsule) { 3 return new Coffee(capsule); 4 } 5} 6CoffeeMachine coffeeMachine = new CoffeeMachine(); 7Colombian capsule = new Colombian(); 8coffeeMachine.&amp;lt;Colombian&amp;gt;makeCoffee(capsule); 9coffeeMachine.makeCoffee(capsule); Restrictions on Generics 1// BoxMaterial을 상속 받았으면서 Hard(인터페이스)를 구현한 클래스만 가능 2public class Box&amp;lt;M extends BoxMaterial &amp;amp; Hard&amp;gt; 3// BoxMaterial의 조상 클래스만 가능 4public class Box&amp;lt;T super BoxMaterial&amp;gt; Whild Card 1// T와 그 자손만 가능 2&amp;lt;?</description></item></channel></rss>
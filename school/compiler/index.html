<!doctype html><html>
<head>
<title>컴파일러개론</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:title" content="컴파일러개론">
<meta property="og:description" content="개요 컴퓨터와 인간이 소통하는 방법 어셈블리어  어셈블리어의 번역기는 어셈블러(Assembler)라고 한다 cpu칩셋이 바뀔때마다 어셈블리어가 바뀐다  고급언어  고급언어의 번역기 …">
<meta property="og:type" content="blog">
<meta property="og:url" content="https://github.com/bong-u/til-hugo">
<meta property="og:image" content="https://bong-u.github.io/til/asset/profile.jpg">
<script type=text/javascript src=https://bong-u.github.io/til/script/base.js></script>
<link rel=icon href=https://bong-u.github.io/til/favicon16.png sizes=16x16>
<link rel=icon href=https://bong-u.github.io/til/favicon32.png sizes=32x32>
<link id=twCSS rel=stylesheet href=https://bong-u.github.io/til/css/style.css>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script>
<script>MathJax={tex:{inlineMath:[['$','$']]}}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HE9FQR1ML7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-HE9FQR1ML7')</script>
</head>
<body class=custom-scroll>
<header class="flex block md:fixed w-full justify-center md:justify-end p-4 text-3xl z-10">
<div class="flex gap-3">
<a class=hover-bigger href=https://bong-u.github.io/til/>
🏠
</a>
<a class=hover-bigger href=https://github.com/bong-u/til>
🐈
</a>
<label id=toggleButton class="cursor-pointer hover-bigger" for=toggleDarkMode>
☀️
</label>
<a id=scrollButton onclick=scrollToTop() class="cursor-pointer hover-bigger">
🔽
</a>
</div>
</header>
<input type=checkbox id=toggleDarkMode onchange=toggleDarkModeHandler() hidden>
<div class="flex w-full">
<nav class="sticky hidden absolute top-0 xl:block h-screen w-1/6 top-0 py-16 px-7 sidebar-gradient">
<div id=sidebar class="flex flex-col gap-3 px-2 overflow-y-scroll overflow-x-hidden h-full">
<a class="flex py-3 hover-bold hover-bigger" href=/til/mogako23/>
<span class="text-xl mr-3">👨‍💻</span>
<span>23-모각코 (13)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/algorithm/>
<span class="text-xl mr-3">🧠</span>
<span>Algorithm (102)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/java/>
<span class="text-xl mr-3">☕</span>
<span>Java (6)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/javascript/>
<span class="text-xl mr-3">🍌</span>
<span>Javascript (7)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/kubernetes/>
<span class="text-xl mr-3">☸</span>
<span>Kubernetes (4)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/open_source/>
<span class="text-xl mr-3">🐮</span>
<span>OpenSource (1)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/spring/>
<span class="text-xl mr-3">🍃</span>
<span>Spring (29)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/sql/>
<span class="text-xl mr-3">🥞</span>
<span>SQL (1)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/issues/>
<span class="text-xl mr-3">🧐</span>
<span>기타 Issues (1)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/lecture/>
<span class="text-xl mr-3">👨‍🏫</span>
<span>특강 (4)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/school/>
<span class="text-xl mr-3">🏫</span>
<span>학과 공부 (14)</span>
</a>
</div>
</nav>
<script type=text/javascript src=https://bong-u.github.io/til/script/single.js></script>
<script type=text/javascript src=https://bong-u.github.io/til/script/toc.js></script>
<main class="w-full lg:w-5/6 px-3 sm:px-12">
<aside class="fixed top-0 right-0 my-24 w-1/6 gap-3 px-9 hidden xl:flex text-sm overflow-hidden">
<nav id=TableOfContents>
<ul>
<li><a href=#개요>개요</a>
<ul>
<li><a href=#컴퓨터와-인간이-소통하는-방법>컴퓨터와 인간이 소통하는 방법</a></li>
<li><a href=#프로그램-처리과정>프로그램 처리과정</a></li>
<li><a href=#컴파일러의-처리-과정>컴파일러의 처리 과정</a></li>
</ul>
</li>
<li><a href=#lexical-analysis-어휘-분석>Lexical analysis (어휘 분석)</a>
<ul>
<li><a href=#fsa-finite-state-automata-유한-상태-오토마타>FSA (Finite State Automata, 유한 상태 오토마타)</a></li>
<li><a href=#dfa-deterministic-finite-automata>DFA (Deterministic Finite Automata)</a></li>
<li><a href=#분석한-토큰을-표현하는-방법>분석한 토큰을 표현하는 방법</a></li>
</ul>
</li>
<li><a href=#syntax-analysis-구문-분석>Syntax analysis (구문 분석)</a>
<ul>
<li><a href=#cfg-context-free-grammer>CFG (Context Free Grammer)</a></li>
<li><a href=#여러가지-cfg-표현법>여러가지 CFG 표현법</a></li>
<li><a href=#유도-derivation>유도 (derivation)</a></li>
<li><a href=#모호성-ambiguity>모호성 (ambiguity)</a></li>
<li><a href=#구문-분석의-2가지-방식>구문 분석의 2가지 방식</a></li>
</ul>
</li>
<li><a href=#top-down-parsing>Top-down parsing</a>
<ul>
<li><a href=#top-down-방식>Top-down 방식</a></li>
<li><a href=#bottom-up-방식>Bottom-up 방식</a></li>
<li><a href=#ll-파싱>LL 파싱</a></li>
<li><a href=#사용된-정의>사용된 정의</a></li>
<li><a href=#ll조건>LL조건</a></li>
<li><a href=#ll1-문법>LL(1) 문법</a></li>
<li><a href=#lookahead>LOOKAHEAD</a></li>
<li><a href=#strong-ll1>Strong LL(1)</a></li>
<li><a href=#ll1-파서-구현-방법>LL(1) 파서 구현 방법</a></li>
</ul>
</li>
<li><a href=#bottom-up-parsing>Bottom-up parsing</a>
<ul>
<li></li>
<li><a href=#shift와-reduce로-parsing-하기>Shift와 Reduce로 Parsing 하기</a></li>
<li><a href=#yacc>YACC</a></li>
<li><a href=#lr0-파싱-테이블-만들기>LR(0) 파싱 테이블 만들기</a></li>
<li><a href=#slr-파싱-테이블-만들기>SLR 파싱 테이블 만들기</a></li>
<li><a href=#lalr-parsing>LALR Parsing</a></li>
</ul>
</li>
<li><a href=#sdd-ast>SDD, AST</a>
<ul>
<li><a href=#sdd-syntax-directed-definition>SDD (Syntax Directed Definition)</a></li>
<li><a href=#ast-abstract-syntax-tree>AST (Abstract Syntax Tree)</a></li>
</ul>
</li>
<li><a href=#ir-intermediate-representation>IR (Intermediate Representation)</a>
<ul>
<li><a href=#ir이란>IR이란?</a></li>
<li><a href=#high-level-ir>High Level IR</a></li>
<li><a href=#low-level-ir>Low Level IR</a></li>
<li><a href=#ir-예시>IR 예시</a></li>
</ul>
</li>
<li><a href=#ir-generation>IR generation</a>
<ul>
<li><a href=#3-address-translation-규칙>3-address Translation 규칙</a></li>
<li><a href=#statement-expression>Statement Expression</a></li>
<li><a href=#nested-expressions>Nested Expressions</a></li>
<li><a href=#storage-management>Storage Management</a></li>
<li><a href=#stack-management>Stack Management</a></li>
<li><a href=#stack-pointers>Stack pointers</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
<section class="mt-6 xl:w-5/6">
<div class="flex flex-col">
<h4 id=date>마지막 수정 : 2023-11-27</h4>
</div>
<div class="mb-10 whitespace-nowrap">
<div class="flex justify-between items-baseline my-4 gap-8">
<h1 id=title class="overflow-ellipsis-bundle text-3xl font-bold p-1">
컴파일러개론
</h1>
</div>
</div>
<article id=content class="bg-inherit markdown-body flex flex-col">
<h2 id=개요>개요</h2>
<h3 id=컴퓨터와-인간이-소통하는-방법>컴퓨터와 인간이 소통하는 방법</h3>
<h4 id=어셈블리어>어셈블리어</h4>
<ul>
<li>어셈블리어의 번역기는 어셈블러(Assembler)라고 한다</li>
<li>cpu칩셋이 바뀔때마다 어셈블리어가 바뀐다</li>
</ul>
<h4 id=고급언어>고급언어</h4>
<ul>
<li>고급언어의 번역기는 컴파일러(Compiler)라고 한다</li>
</ul>
<h4 id=컴파일러의-정확한-정의>컴파일러의 정확한 정의</h4>
<blockquote>
<p>어떤 언어로 쓰여진 프로그램을 같은 역할의 다른 언어로 바꿔주는 프로그램</p>
</blockquote>
<ul>
<li>1952년 그레이스 호퍼(Grace Hopper)가 UNIVAC용 프로그래밍언어 A-0 컴파일러를 제작</li>
</ul>
<h4 id=컴파일러-vs-인터프리터>컴파일러 vs 인터프리터</h4>
<h3 id=프로그램-처리과정>프로그램 처리과정</h3>
<p><img src=/static/image/program_process.png alt=program_process></p>
<h3 id=컴파일러의-처리-과정>컴파일러의 처리 과정</h3>
<p><img src=/static/image/compile_process.png alt=compile_process></p>
<ul>
<li>Lexical analysis (어휘 분석)
<ul>
<li>token을 생성하는일, token은 어휘의 최소 단위</li>
</ul>
</li>
<li>Syntax analysis (구문 분석)
<ul>
<li>token을 읽어서 오류를 검색, 구문 구조를 만든다 (주로 트리형태)</li>
</ul>
</li>
<li>Semantic analysis (의미 분석)
<ul>
<li>type checking</li>
</ul>
</li>
<li>Intermediate code generation (중간 코드 생성)
<ul>
<li>중간 코드로 변환</li>
</ul>
</li>
<li>Code optimization (코드 최적화)
<ul>
<li>중간 코드를 더 효율적으로 변환</li>
</ul>
</li>
<li>Code generation (코드 생성)
<ul>
<li>목적 코드 생성</li>
</ul>
</li>
</ul>
<h2 id=lexical-analysis-어휘-분석>Lexical analysis (어휘 분석)</h2>
<ul>
<li>token : 문법적으로 의미있는 최소 단위</li>
</ul>
<h3 id=fsa-finite-state-automata-유한-상태-오토마타>FSA (Finite State Automata, 유한 상태 오토마타)</h3>
<p><img src=/static/image/fsa_integer.png alt=fsa_integer></p>
<ul>
<li>token을 인식하는 방법</li>
<li>시작 상태 한 개와 끝 상태 여러 개를 가짐</li>
</ul>
<h3 id=dfa-deterministic-finite-automata>DFA (Deterministic Finite Automata)</h3>
<p><img src=/static/image/dfa_example.png alt=dfa_example></p>
<ul>
<li>FSA의 한 종류</li>
<li>각 상태에서 뻗어나가는 edge가 하나씩만 존재</li>
<li>ε가 붙은 edge 없음</li>
</ul>
<h3 id=분석한-토큰을-표현하는-방법>분석한 토큰을 표현하는 방법</h3>
<blockquote>
<p>Lexeme = &lt;토큰번호, 토큰 값></p>
</blockquote>
<ul>
<li>예시
<ul>
<li>if X &lt; Y &mldr;</li>
<li>(29, 0) (1, X) (18, 0) (1, Y) &mldr;</li>
<li>식별자의 토큰번호는 1번, 상수는 2번 등으로 고정</li>
</ul>
</li>
</ul>
<h2 id=syntax-analysis-구문-분석>Syntax analysis (구문 분석)</h2>
<ul>
<li>token을 읽어서 오류를 검색, parse tree를 만든다</li>
</ul>
<h3 id=cfg-context-free-grammer>CFG (Context Free Grammer)</h3>
<ul>
<li>구문을 표현하는 방법</li>
<li>G = (N, T, P, S)
<ul>
<li>N = nonterminal symbol
<ul>
<li>알파벳 대문자로 표현</li>
</ul>
</li>
<li>T = terminal symbol (token)
<ul>
<li>알파벳 소문자+숫자, 연산자, 구분자, 키워드 등</li>
</ul>
</li>
<li>P = production rule
<ul>
<li>예) S -> T+T, T -> &lsquo;0&rsquo;|&lsquo;1&rsquo;|&lsquo;2&rsquo;</li>
</ul>
</li>
<li>S = start symbol</li>
</ul>
</li>
<li>L(G) : 이 문법으로 생성되는 언어</li>
</ul>
<h3 id=여러가지-cfg-표현법>여러가지 CFG 표현법</h3>
<ul>
<li>BNF (Backus-Naur Form)</li>
<li>EBNF (Extended BNF)</li>
</ul>
<h3 id=유도-derivation>유도 (derivation)</h3>
<ul>
<li>생성 규칙를 적용하여 문장을 생성하는 과정</li>
<li>유도를 하는 과정에서 하나씩 골라서 바꿈</li>
<li>유도 트리 : 유도 경로를 추상화 시켜 표현한 것</li>
<li>좌측 유도(leftmost derivation)
<ul>
<li>가장 왼쪽에 있는 nonterminal을 먼저 대치</li>
</ul>
</li>
<li>우측 유도(rightmost derivation)
<ul>
<li>가장 오른쪽에 있는 nonterminal을 먼저 대치</li>
</ul>
</li>
</ul>
<h3 id=모호성-ambiguity>모호성 (ambiguity)</h3>
<ul>
<li>문법 G에 의해 생성되는 어떤 문장이 두개 이상의 유도트리를 갖는다면 문법 G는 모호하다고 한다</li>
<li>모호하지 않은 문법은 좌측 유도와 우측 유도가 같다</li>
<li>모호성 해결
<ol>
<li><strong>연산자 우선순위 도입</strong></li>
<li><strong>결합 법칙 도입</strong></li>
</ol>
<ul>
<li>Left Recursion은 좌측 결합에 사용
<ul>
<li>ex) A -> A+a | a</li>
</ul>
</li>
<li>Right Recursion은 우측 결합에 사용
<ul>
<li>ex) A -> a+A | a</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=구문-분석의-2가지-방식>구문 분석의 2가지 방식</h3>
<ul>
<li>top-down, bottom-up</li>
</ul>
<h2 id=top-down-parsing>Top-down parsing</h2>
<h3 id=top-down-방식>Top-down 방식</h3>
<ul>
<li>좌측 유도와 같은 순선의 생성 규칙 적용</li>
<li>backtracking : 유도된 문자열과 입력 문자열이 같지 않으면 다른 생성규칙 적용</li>
</ul>
<h3 id=bottom-up-방식>Bottom-up 방식</h3>
<ul>
<li>우측 유도의 역순의 생성 규칙 적용</li>
</ul>
<h3 id=ll-파싱>LL 파싱</h3>
<ul>
<li>왼쪽->오른쪽으로 읽어서 좌파스 생성</li>
<li>backtracking X, 빠르다</li>
<li><strong>결정적으로</strong> 파싱</li>
</ul>
<h3 id=사용된-정의>사용된 정의</h3>
<ol>
<li>
<p>ε-생성규칙</p>
<ul>
<li>Nonterminal A가 ε를 유도할 수 있으면 A를 nullable하다고 부른다</li>
</ul>
</li>
<li>
<p>lhs, rhs</p>
<ul>
<li>A->XXX에서 lhs는 A, rhs는 XXX</li>
</ul>
</li>
<li>
<p>⊕ (Ring Sum)</p>
<ul>
<li>A에 ε가 있으면, A⊕B = (A에서 ε빼고 A 합집합 B)</li>
<li>A에 ε가 없으면, A⊕B = A</li>
</ul>
</li>
</ol>
<h4 id=first>First</h4>
<ul>
<li>nonterminal A로 부터 유도되어 첫번째로 나타날 수 있는 terminal의 집합</li>
<li>X->Y1Y2Y3일때,
<blockquote>
<p>FIRST(X) = FIRST(X) U FIRST(Y1) ⊕ FIRST(Y2) ⊕ FIRST(Y3)</p>
</blockquote>
</li>
</ul>
<h4 id=follow>Follow</h4>
<ul>
<li>A 다음에 나오는 terminal의 집합</li>
<li>A->αBβ, β != ε 일때,
<blockquote>
<p>FOLLOW(B) = FOLLOW(B) U (FIRST(β)-{ε})</p>
</blockquote>
</li>
<li>A->αB 또는 A->αBβ, FIRST(β)에 ε가 속할 때,
<blockquote>
<p>FOLLOW(B) = FOLLOW(B) U FOLLOW(A)</p>
</blockquote>
</li>
</ul>
<h3 id=ll조건>LL조건</h3>
<ul>
<li>FIRST(α)와 FIRST(β)가 겹치면 안된다</li>
<li>FIRST(α)에 ε가 있으면, FOLLOW(α)와 FIRST(β)가 겹치면 안된다</li>
<li>LL 조건을 만족하는 문법 = LL 파싱 되는 문법</li>
</ul>
<h3 id=ll1-문법>LL(1) 문법</h3>
<ul>
<li>임의의 문법에 대하여 LL 조건을 만족하는 CFG</li>
<li>1 : LOOKAHEAD가 1개라는 의미</li>
<li>다음과 같은 경우 LL(1)문법이 되지 않는다
<ol>
<li>모호한 문법</li>
</ol>
<ul>
<li>우선순위 주기, 결합법칙 반영으로 해결</li>
</ul>
<ol start=2>
<li>left-factoring이 되는 경우</li>
</ol>
<ul>
<li>공통 앞부분을 새로운 nonterminal로 만들어 해결</li>
</ul>
<ol start=3>
<li>left-recursive한 경우</li>
</ol>
<ul>
<li>직접 recursion : A -> Aε 인경우</li>
<li>간접 recursion : A -> B, B -> A 인경우</li>
</ul>
</li>
</ul>
<h3 id=lookahead>LOOKAHEAD</h3>
<ul>
<li>어떤 규칙이 적용되었을때 맨 처음 나올 수 있는 terminal 집합</li>
<li>A->X1X2X3일때,
<blockquote>
<p>LOOKAHEAD(A) = FIRST(X1) ⊕ FIRST(X2) &mldr; ⊕ FOLLOW(A)</p>
</blockquote>
</li>
</ul>
<h3 id=strong-ll1>Strong LL(1)</h3>
<ul>
<li><strong>LL(1)과 항상 동일</strong> (1이 아닐때는 다름)</li>
<li>LOOKAHEAD(A->α)와 LOOKAHEAD(A->β)가 겹치지 않는 문법</li>
</ul>
<h3 id=ll1-파서-구현-방법>LL(1) 파서 구현 방법</h3>
<h4 id=recursive-descent-parser>Recursive descent parser</h4>
<ul>
<li>장점 : 직관적 쉽다</li>
<li>단점 : 생성 규칙이 바뀌면 구문 분석기를 고쳐야 한다</li>
</ul>
<h4 id=predictive-parser>Predictive parser</h4>
<ul>
<li>
<p>PDA(PushDown Automata)에 기반</p>
</li>
<li>
<p>생성 규칙이 바뀌면 파싱 테이블만 수정</p>
</li>
<li>
<p>파싱테이블 예시 (?에는 규칙번호가 들어간다)</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>A</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>파싱테이블에 두개 이상의 생성 규칙이 들어가는 경우 -> NOT LL(1)</p>
</li>
<li>
<p>Stack의 예시
<img src=/static/image/topdown_stack.png alt=topdown_stack></p>
</li>
</ul>
<h2 id=bottom-up-parsing>Bottom-up parsing</h2>
<ul>
<li>left-recursive 문법도 파싱 가능</li>
</ul>
<h4 id=llk>LL(k)</h4>
<ul>
<li>좌측유도 기반</li>
<li>k개의 symbol을 lookahead</li>
<li>Top-down parsing, recursive descent parsing, predictive parsing, LL parser</li>
<li>파스트리를 pre-roder로 순회 및 생성</li>
</ul>
<h4 id=lrk>LR(k)</h4>
<ul>
<li>우측유도 기반</li>
<li>k개의 symbol을 lookahead</li>
<li>Bottom-up parsing, shift-reduce parsing, LR parser</li>
<li>파스트리를 post-order로 순회 및 생성</li>
</ul>
<h4 id=reduce>Reduce</h4>
<ul>
<li>S=>αβω이고 A->β이면 β를 A로 대치하는 것 : S=>αAω</li>
<li>시작 symbol이 나올 때까지 reduce 한다</li>
</ul>
<h4 id=handle>Handle</h4>
<ul>
<li>S=>αβω이고 A->β이면 β를 αβω의 handle이라고 한다</li>
<li>두 개 이상의 handle이 존재할때 -> 모호하다</li>
</ul>
<h3 id=shift와-reduce로-parsing-하기>Shift와 Reduce로 Parsing 하기</h3>
<h4 id=stack의-예시>Stack의 예시</h4>
<p><img src=/static/image/bottomup_stack.png alt=bottomup_stack></p>
<h4 id=issue>Issue</h4>
<ol>
<li>Shift와 Reduce 중 어느 것을 할까?</li>
<li>Stack의 top에서 얼마만큼을 handle로 볼 것인가?</li>
</ol>
<ul>
<li>해결방법: LR Parsing Table</li>
</ul>
<h3 id=yacc>YACC</h3>
<ul>
<li>LALR 파서 생성기</li>
<li>foo.y &ndash;(yacc)&ndash;> y.tab.c &ndash;(gcc)&ndash;> a.out</li>
<li>*.y 파일 구조
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#f92672>&lt;</span>선언부<span style=color:#f92672>&gt;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#f92672>...</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#f92672>%%</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#f92672>...</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>exp <span style=color:#f92672>:</span> exp <span style=color:#e6db74>&#39;+&#39;</span> term<span style=color:#f92672>;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>factor <span style=color:#f92672>:</span> ident<span style=color:#f92672>;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span style=color:#f92672>...</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span style=color:#f92672>%%</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span style=color:#f92672>&lt;</span>여러 함수<span style=color:#f92672>&gt;</span>
</code></pre></div></li>
<li>모호한 문법으로 LR Conflict 발생 시 선언부에서 우선순위 지정하여 해결</li>
</ul>
<h4 id=lr-parsing-table>LR Parsing Table</h4>
<ul>
<li>Action table : Action + Parser 상태</li>
<li>Goto table : Parser 상태</li>
</ul>
<h3 id=lr0-파싱-테이블-만들기>LR(0) 파싱 테이블 만들기</h3>
<h4 id=lr0-아이템>LR(0) 아이템</h4>
<ul>
<li>rhs에 점('.') symbol을 가진 생성 규칙</li>
<li>ex) A->α.β, A->.</li>
</ul>
<h4 id=closure>closure</h4>
<ul>
<li>점('.')뒤에 non-terminal이 오면 재귀적으로 추가</li>
<li>S' -> S, S -> (L)|id, L -> S | L,S
<ul>
<li>closure({[S'->.S]}) = {[S'->.S], [S->.(L)], [S->.id]}</li>
</ul>
</li>
</ul>
<h4 id=goto>goto</h4>
<ul>
<li>goto(I, X)이면 점을 X뒤로 옮기고 closure를 취한다</li>
<li>X가 없으면 넣지 않는다</li>
<li>I={[G->E=E], [E->E.+T]} 일때,
<ul>
<li>goto(I, +) = closure({E->E+.T}) : 점을 +뒤로 옮김</li>
</ul>
</li>
</ul>
<h4 id=c0>C0</h4>
<ul>
<li>
<p>생성규칙 S'->S에서부터 차례로 closure와 goto를 적용하여 얻은 모든 타당한 LR(0)의 아이템 집합들</p>
</li>
<li>
<p>Item의 종류</p>
<ul>
<li>[A->X.Y] : X!=ε일때 kernel item</li>
<li>[A->.X] : closure item</li>
<li>[A->X.] : reduce item</li>
</ul>
</li>
</ul>
<h3 id=slr-파싱-테이블-만들기>SLR 파싱 테이블 만들기</h3>
<ul>
<li>reduce Item이 [X->α.]일때, FOLLOW(X)의 모든 terminal에만 reduce action을 넣는다</li>
<li>나머지는 LR(0)과 똑같다</li>
<li>LR(0)보다 conflict가 적어, 더 정교하다고 할 수 있다.</li>
</ul>
<h3 id=lalr-parsing>LALR Parsing</h3>
<ul>
<li>정교한 순서
<blockquote>
<p>LR(0) &lt; SLR &lt; LALR(1) &lt; LR(1)</p>
</blockquote>
</li>
<li>파서 상태의 개수
<blockquote>
<p>SLR = LALR &#171; LR(1)</p>
</blockquote>
</li>
</ul>
<h2 id=sdd-ast>SDD, AST</h2>
<h3 id=sdd-syntax-directed-definition>SDD (Syntax Directed Definition)</h3>
<ul>
<li>SDD : semnatic action을 정의하는 추상적인 명세서</li>
<li>Semnatic Actions : 규칙에 대한 Action</li>
</ul>
<h3 id=ast-abstract-syntax-tree>AST (Abstract Syntax Tree)</h3>
<ul>
<li>파스트리에서 불필요한 정보를 제거한 형태</li>
<li>AST를 만드는 방법
<ul>
<li>파싱단계에서 만들기 : LL, LR</li>
<li>파스트리를 순회하면서 만들기 : SDD 사용 (Yacc etc.)</li>
</ul>
</li>
<li>evaluation : 노드를 방문하면서 작업하는 행위</li>
<li>On-the-fly evaluation
<ul>
<li>S-attributed SDD: synthesized attribute만 가지고 있는 SDD</li>
<li>L-attributed SDD: synthesized attribute만 가지는 경우 + 값이 왼쪽에서 오른쪽으로 흘러 계산이 이루어지는 경우</li>
</ul>
</li>
</ul>
<h2 id=ir-intermediate-representation>IR (Intermediate Representation)</h2>
<h3 id=ir이란>IR이란?</h3>
<ul>
<li>Tree나 Instruction list 형태</li>
<li>instruction(node)가 적어야 최적화/번역에 좋음</li>
</ul>
<h3 id=high-level-ir>High Level IR</h3>
<ul>
<li>High와 Low는 상대적인 개념</li>
<li>High level IR: 여기서는 AST의 변형만 생각</li>
<li>종류 : AST, TCOL</li>
</ul>
<h3 id=low-level-ir>Low Level IR</h3>
<ul>
<li>단순한 instruction으로 구성</li>
<li>가상기계(주로 RISC)를 emulate</li>
</ul>
<h4 id=n-tuple-표기법-3-address-code>N-tuple 표기법 (3-address code)</h4>
<blockquote>
<p>a = b OP c</p>
</blockquote>
<ul>
<li>일반적으로 기계어가 가지는 피연산자 개수 &lt;= 3</li>
<li>quadruple : (연산자, 피연산자1, 피연산자2, 결과)</li>
</ul>
<h4 id=stack-machine-code>Stack machine code</h4>
<ul>
<li>Java byte code, U-code : AST로부터 생성이 용이</li>
</ul>
<h4 id=tree-표현>Tree 표현</h4>
<ul>
<li>기계어 생성 용이</li>
</ul>
<h3 id=ir-예시>IR 예시</h3>
<h4 id=gcc---gimple-3-address-code>GCC - GIMPLE (3-address code)</h4>
<ul>
<li>GCC의 중간코드 : GENERIC -> <strong>GIMPLE</strong> -> RTL</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>D<span style=color:#ae81ff>.1954</span> <span style=color:#f92672>=</span> x<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#75715e>// D.1954는 임시변수
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#75715e></span>gimple_assign <span style=color:#f92672>&lt;</span>mult_exprt, D<span style=color:#ae81ff>.1954</span>, x, <span style=color:#ae81ff>10</span><span style=color:#f92672>&gt;</span>
</code></pre></div><h4 id=llvm---bit-3-address-code>LLVM - bit (3-address code)</h4>
<ul>
<li>LLVM IR : 언어와 머신에 독립적</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>@var = <span style=color:#66d9ef>global</span> <span style=color:#66d9ef>i32</span> <span style=color:#ae81ff>14</span> <span style=color:#75715e>; 전역변수 var에 14 대입
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#75715e></span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i32</span> @main() <span style=color:#66d9ef>nounwind</span> { <span style=color:#75715e>; i32(int) 반환형
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#75715e></span>  entry:
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>    %a = <span style=color:#66d9ef>alloca</span> <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>4</span> <span style=color:#75715e>; 지역변수 a 선언, int 할당
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#75715e></span>    %1 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i32</span> * @var <span style=color:#75715e>; %1 임시변수에 var값 대입
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span style=color:#75715e></span>    <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i32</span> %1 <span style=color:#75715e>; 임시변수 값 반환
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span style=color:#75715e></span>}
</code></pre></div><h4 id=jvm---byte-code-stack-machine-code>JVM - byte code (stack machine code)</h4>
<ul>
<li>가상 기계 코드 (Bytecode, MSIL)
<ul>
<li>가상 기계에서 동작하도록 함</li>
<li>이식성, 호환성이 목적 : java bytecode는 machine 호환성, c# msil은 language 호환성</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Employee</span><span style=color:#f92672>(</span>String strName<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> num<span style=color:#f92672>)</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#f92672>{</span>name <span style=color:#f92672>=</span> strName<span style=color:#f92672>;</span> idNumber <span style=color:#f92672>=</span> num<span style=color:#f92672>;</span> storeData<span style=color:#f92672>(</span>strName<span style=color:#f92672>,</span> num<span style=color:#f92672>);}</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>Method <span style=color:#a6e22e>Employee</span><span style=color:#f92672>(</span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>String</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>)</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>0 aload_0 <span style=color:#f92672>;</span> 0번째 <span style=color:#a6e22e>로컬변수</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span>를 스택에 push
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>1 invokespecial <span style=color:#960050;background-color:#1e0010>#</span>3 <span style=color:#f92672>&lt;</span>Method java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Object</span><span style=color:#f92672>()&gt;</span> <span style=color:#f92672>;</span> 함수 호출
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#f92672>---</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>4 aload_0
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>5 aload_1 <span style=color:#f92672>;</span> strName을 스택에 push
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>6 putfield <span style=color:#960050;background-color:#1e0010>#</span>5 <span style=color:#f92672>&lt;</span>Field java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>String</span> name<span style=color:#f92672>&gt;</span> <span style=color:#f92672>;</span> name에 strName 대입
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#f92672>---</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>9 aload_0
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>10 iload_2 <span style=color:#f92672>;</span> num을 스택에 push
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span>11 putfield <span style=color:#960050;background-color:#1e0010>#</span>7 <span style=color:#f92672>&lt;</span>Field <span style=color:#66d9ef>int</span> idNumber<span style=color:#f92672>&gt;</span> <span style=color:#f92672>;</span> idNumber에 num 대입
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#f92672>---</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span>14 aload_0
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span>15 aload_1 <span style=color:#f92672>;</span> strName을 스택에 push
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span>16 iload_2 <span style=color:#f92672>;</span> num을 스택에 push
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span>17 invokespecial <span style=color:#960050;background-color:#1e0010>#</span>9 <span style=color:#f92672>&lt;</span>Method <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>storeData</span><span style=color:#f92672>(</span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>String</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>)&gt;</span> <span style=color:#f92672>;</span> 함수 호출
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span>20 <span style=color:#66d9ef>return</span>
</code></pre></div><ul>
<li>line number : 명령이 시작하는 바이트 주소</li>
<li>aload : 객체를 push, iload : 정수를 push</li>
<li>원래는 aload가 명령, 자주 쓰는 명령 aload 0을 묶어서 bind -> aload_0</li>
</ul>
<h4 id=cil-common-intermediate-language-stack-machine-code>CIL (Common Intermediate Language) (stack machine code)</h4>
<ul>
<li>C#, VB.NET, J# 등에서 사용</li>
<li>MSIL은 옛날 이름</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#a6e22e>.assembly</span> Hello <span style=color:#960050;background-color:#1e0010>{}</span> <span style=color:#75715e>; .assembly: 어셈블리 선언</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#a6e22e>.assembly</span> extern mscorlib <span style=color:#960050;background-color:#1e0010>{}</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#a6e22e>.method</span> static void Main() <span style=color:#960050;background-color:#1e0010>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>  <span style=color:#a6e22e>.entrypoint</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>  <span style=color:#a6e22e>.maxstack</span> <span style=color:#ae81ff>1</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>  <span style=color:#a6e22e>ldstr</span> <span style=color:#e6db74>&#34;Hello, world!&#34;</span> <span style=color:#75715e>; stack에 저장</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span>  <span style=color:#a6e22e>call</span> void [mscorlib]System.Console::WriteLine(string)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span>  <span style=color:#a6e22e>ret</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span style=color:#960050;background-color:#1e0010>}</span>
</code></pre></div><h4 id=gcc-rtlregister-transfer-language-tree구조-코드>GCC RTL(Register Transfer Language) (Tree구조 코드)</h4>
<ul>
<li>Lisp <em>S-expression</em> 사용</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>(set (reg:SI 140)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>     (plus:SI (reg:SI 138)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>              (reg:SI 139)))
</code></pre></div><ul>
<li>=> reg140 = reg138+reg139</li>
</ul>
<h2 id=ir-generation>IR generation</h2>
<h3 id=3-address-translation-규칙>3-address Translation 규칙</h3>
<ul>
<li>Binary operations: <code>t = [[el OP e2]]</code></li>
<li>Unary operations: <code>t = [[OP el]]</code></li>
<li>Array access: <code>t = [[ v[e] ]]</code></li>
<li>Structure access: <code>t = [[ v.f ]]</code></li>
<li>Short-circuit OR: <code>t = [[ el SC-OR e2]]</code></li>
<li>Statement sequence: <code>[[s1; s2; ...; sN]]</code></li>
<li>Variable assignment: <code>[[ v = e ]]</code></li>
<li>Array assignment: <code>[[ v[e1] = e2 ]]</code></li>
<li>If: <code>[[ if(e) then s ]]</code>, <code>[[ if(e) then s1 else s2]]</code></li>
<li>While: <code>[[ while (e) s ]]</code></li>
<li>Switch: <code>[[ switch (e) case v1:s1, ..., case vN:sN ]]</code></li>
<li>Function Call: <code>[[ call f(e1, e2, ..., eN) ]]</code></li>
<li>Fucntion Return: <code>[[ return e ]]</code></li>
</ul>
<h3 id=statement-expression>Statement Expression</h3>
<ul>
<li>Statement도 expression 처럼 값을 가지도록 확장</li>
<li><code>t = [[ S ]]</code>를 추가하여 결과값을 저장하자</li>
</ul>
<h3 id=nested-expressions>Nested Expressions</h3>
<ul>
<li><code>t = [[ (a - b) * (c + d) ]]</code></li>
<li><code>t = [[ if c then if d then a = b ]]</code></li>
<li>가장 큰 덩어리부터 바꾼다</li>
</ul>
<h3 id=storage-management>Storage Management</h3>
<h4 id=2가지-storage>2가지 Storage</h4>
<ul>
<li>Register : 빠른 접근, 간접 접근 불가</li>
<li>Memory : 상대적으로 느린 접근, 간접 접근 가능</li>
</ul>
<h4 id=2가지-접근-방식>2가지 접근 방식</h4>
<h4 id=all-memory-approach>All memory approach</h4>
<ul>
<li>모든 변수를 memory에 저장, 가능한것만 register</li>
</ul>
<h4 id=standard-approach>Standard approach</h4>
<ul>
<li>Global, Statics, Local(composite)는 memory에 저장</li>
<li>Local(scalar)는 memory 또는 virtual register에 저장</li>
</ul>
<h4 id=memory의-4대-영역>Memory의 4대 영역</h4>
<ul>
<li>Code space : 명령어를 저장 read-only일때 빠름</li>
<li>Static data : 프로그램과 lifetime을 함께하는 데이터</li>
<li>Stack : Local 변수들</li>
<li>Heap : 동적으로 할당되는 데이터</li>
</ul>
<h4 id=file-format>File Format</h4>
<ul>
<li>Windows : PE (Portable Executable)</li>
<li>Unix : ELF (Executable and Linkable Format)</li>
</ul>
<h4 id=변수-바인딩>변수 바인딩</h4>
<ul>
<li>environment : &lt;변수, storage location> 정보
<ul>
<li>state: &lt;변수, 값> 정보</li>
</ul>
</li>
<li>어떤 변수 N이 storage location S에 지정되면 바인딩 된다고 한다</li>
</ul>
<h4 id=static-allocation>Static Allocation</h4>
<ul>
<li>프로그램 수행하는 동안 변하지 않는 location으로 바인딩</li>
</ul>
<h4 id=heap-allocation>Heap Allocation</h4>
<ul>
<li>연속적인 global 영역의 일부를 OS로부터 받은 것</li>
<li>프로그램 수행 중 요청과 반환</li>
</ul>
<h3 id=stack-management>Stack Management</h3>
<ul>
<li>Run-time stack : 한 함수 call마다 하나씩두는 frames</li>
<li>Activation record : 함수 수행을 위한 execution env(local var, parameter, return address, etc.)</li>
<li>Top frame : 현재 수행중인 함수의 frame</li>
</ul>
<h3 id=stack-pointers>Stack pointers</h3>
<ul>
<li>SP : Frame top</li>
<li>FP : Frame base</li>
<li>두 개를 쓰는 이유
<ul>
<li>가까운 거 기준으로 offset 계산 -> small offset 유지</li>
<li>수행 중 top frame의 위치를 알 수 없음</li>
</ul>
</li>
<li></li>
</ul>
</article>
<div id=meta class=my-16>
<div>
<div class="flex justify-between w-full text-lg">
<a class="previous mr-5 overflow-ellipsis-bundle hover-bold" href=/til/school/operatingsystem2/>
<span class=mx-3>◀</span>
운영체제 - 기말범위
</a>
<a class="next ml-5 overflow-ellipsis-bundle hover-bold" href=/til/school/film_and_literature/>
영화와 문학
<span class=mx-3>▶</span>
</a>
</div>
</div>
</div>
<div id=comment-box></div>
</section>
</main>
</div>
</body>
</html>
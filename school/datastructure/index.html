<!doctype html><html>
<head>
<title>자료구조</title>
<meta charset=utf-8>
<meta property="og:title" content="Bong-u's til">
<meta property="og:type" content="blog">
<meta property="og:url" content="https://github.com/bong-u/til-hugo">
<meta property="og:image" content="https://bong-u.github.io/til/asset/profile.jpg">
<script type=text/javascript src=https://bong-u.github.io/til/src/script.js></script>
<link rel=icon href=https://bong-u.github.io/til/favicon16.png sizes=16x16>
<link rel=icon href=https://bong-u.github.io/til/favicon32.png sizes=32x32>
<link id=twCSS rel=stylesheet href=https://bong-u.github.io/til/src/style.css>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script>
<script>MathJax={tex:{inlineMath:[['$','$']]}}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HE9FQR1ML7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-HE9FQR1ML7')</script>
</head>
<body class="flex justify-center my-16">
<header class="fixed w-full top-0 px-8 py-4 text-3xl z-10">
<div class="flex gap-3 float-right">
<a class=hover-bigger href=https://bong-u.github.io/til/>
🏠
</a>
<a class=hover-bigger href=https://github.com/bong-u/til>
🐈
</a>
<label id=toggleButton class="cursor-pointer hover-bigger" for=toggleDarkMode>
☀️
</label>
<a id=scrollButton onclick=scrollToTop() class="cursor-pointer hover-bigger">
🔽
</a>
</div>
</header>
<input type=checkbox id=toggleDarkMode onchange=toggleDarkModeHandler() hidden>
<script>let anchorsCache=null;document.addEventListener("DOMContentLoaded",()=>{window.addEventListener("scroll",()=>{const c=document.getElementById("TableOfContents"),b=document.querySelectorAll("#TableOfContents a"),a=getCurrentAnchor();let d=0;for(let c=0;c<b.length;c++)b[c].classList.remove("current"),b[c]===a&&(d=c);a&&a.classList.add("current"),c.scroll(0,a.offsetTop-c.offsetHeight/2)})});const getTocItem=a=>document.querySelector('[href="'+a+'"]'),getCurrentAnchor=()=>{const c=window.pageYOffset,a=getAnchors();let b=null;for(let d=0;d<a.length;d++){const e=getHeading(a[d]).getBoundingClientRect().top+c;if(e<c+window.innerHeight*.23)b=a[d];else break}return b||(b=a[0]),getTocItem(b)},getAnchors=()=>(anchorsCache||(anchorsCache=Array.from(document.querySelectorAll("#TableOfContents a")).map(a=>a.getAttribute("href"))),anchorsCache),getHeading=a=>document.getElementById(a.substr(1))</script>
<nav class="fixed hidden lg:flex flex-col h-full left-0 top-0 py-24 gap-3 p-7">
<a class="flex py-3 hover-bold hover-bigger" href=/til/mogako23/>
<span class="text-xl mr-3">👨‍💻</span>
<span>23-모각코 (13)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/algorithm/>
<span class="text-xl mr-3">🧠</span>
<span>Algorithm (93)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/java/>
<span class="text-xl mr-3">☕</span>
<span>Java (6)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/javascript/>
<span class="text-xl mr-3">🍌</span>
<span>Javascript (7)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/kubernetes/>
<span class="text-xl mr-3">☸</span>
<span>Kubernetes (4)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/spring/>
<span class="text-xl mr-3">🍃</span>
<span>Spring (29)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/sql/>
<span class="text-xl mr-3">🥞</span>
<span>SQL (1)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/issues/>
<span class="text-xl mr-3">🧐</span>
<span>기타 Issues (1)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/lecture/>
<span class="text-xl mr-3">👨‍🏫</span>
<span>특강 (4)</span>
</a>
<a class="flex py-3 hover-bold hover-bigger" href=/til/school/>
<span class="text-xl mr-3">🏫</span>
<span>학과 공부 (10)</span>
</a>
</nav>
<aside class="fixed top-0 right-0 py-24 w-2/12 gap-3 mx-9 hidden lg:flex text-sm overflow-hidden">
<nav id=TableOfContents>
<ul>
<li><a href=#제-1장--자료구조를-배우기-위한-준비-230302>제 1장 : 자료구조를 배우기 위한 준비 (230302)</a>
<ul>
<li><a href=#배열>배열</a></li>
<li><a href=#추상데이터-타입>추상데이터 타입</a></li>
</ul>
</li>
<li><a href=#1-2-수행시간의-분석>1-2 수행시간의 분석</a></li>
<li><a href=#1-3-수행시간의-점근표기법>1-3 수행시간의 점근표기법</a>
<ul>
<li><a href=#o-big-oh-표기법>O (Big-Oh) 표기법</a></li>
<li><a href=#ω-big-omega-표기법>Ω (Big-Omega) 표기법</a></li>
<li><a href=#θ-theta-표기법>Θ (Theta) 표기법</a></li>
<li><a href=#자주-사용되는-함수의-o-표기와-이름>자주 사용되는 함수의 O-표기와 이름</a></li>
</ul>
</li>
<li><a href=#1-5-순환-recursion>1-5 순환 (Recursion)</a>
<ul>
<li><a href=#순환으로-구현된-메소드의-구성요소>순환으로 구현된 메소드의 구성요소</a></li>
<li><a href=#꼬리-순환-tail-recursion>꼬리 순환 (Tail Recursion)</a></li>
</ul>
</li>
<li><a href=#제-2장--리스트>제 2장 : 리스트</a>
<ul>
<li><a href=#리스트>리스트</a></li>
<li><a href=#배열-1>배열</a></li>
<li><a href=#배열로-리스트-구현-arrlist>배열로 리스트 구현 (ArrList)</a></li>
<li><a href=#단순-연결-리스트singly-linked-list>단순 연결 리스트(Singly Linked List)</a></li>
<li><a href=#이중-연결-리스트-doubly-linked-list>이중 연결 리스트 (Doubly Linked List)</a></li>
<li><a href=#원형-연결-리스트circular-linked-list>원형 연결 리스트(Circular Linked List)</a></li>
</ul>
</li>
<li><a href=#제-3장--스택과-큐>제 3장 : 스택과 큐</a>
<ul>
<li><a href=#스택>스택</a></li>
</ul>
</li>
<li><a href=#제-4장--트리>제 4장 : 트리</a>
<ul>
<li><a href=#용어>용어</a></li>
<li><a href=#왼쪽-자식-오른쪽-형제-left-child-right-sibling-표현>왼쪽 자식-오른쪽 형제 (Left Child-Right Sibling) 표현</a></li>
<li><a href=#이진-트리-binary-tree>이진 트리 (Binary Tree)</a></li>
<li><a href=#이진-트리의-순회>이진 트리의 순회</a></li>
<li><a href=#수행-시간>수행 시간</a></li>
<li><a href=#집합의-표현>집합의 표현</a></li>
</ul>
</li>
<li><a href=#제-5장--탐색-트리>제 5장 : 탐색 트리</a>
<ul>
<li><a href=#51-이진탐색트리>5.1 이진탐색트리</a></li>
<li><a href=#시간-복잡도>시간 복잡도</a></li>
<li><a href=#52-avl-트리>5.2 AVL 트리</a></li>
<li><a href=#53-2-3-트리>5.3 2-3 트리</a></li>
<li><a href=#54-2-3-4-트리>5.4 2-3-4 트리</a></li>
<li><a href=#55-b-트리>5.5 B-트리</a></li>
</ul>
</li>
<li><a href=#제-6장--해시-테이블>제 6장 : 해시 테이블</a>
<ul>
<li></li>
</ul>
</li>
<li><a href=#제-7장--우선순위-큐>제 7장 : 우선순위 큐</a>
<ul>
<li><a href=#우선순위-큐-priority-queue>우선순위 큐 (Priority Queue)</a></li>
<li><a href=#힙-heap>힙 (Heap)</a></li>
<li><a href=#힙의-연산>힙의 연산</a></li>
<li><a href=#상향식-힙>상향식 힙</a></li>
<li><a href=#수행-시간-1>수행 시간</a></li>
</ul>
</li>
<li><a href=#제-8장--정렬>제 8장 : 정렬</a>
<ul>
<li><a href=#선택-정렬-selection-sort>선택 정렬 (Selection Sort)</a></li>
<li><a href=#삽입-정렬-insertion-sort>삽입 정렬 (Insertion Sort)</a></li>
<li><a href=#힙-정렬-heap-sort>힙 정렬 (Heap Sort)</a></li>
<li><a href=#합병-정렬-merge-sort>합병 정렬 (Merge Sort)</a></li>
<li><a href=#퀵-정렬-quick-sort>퀵 정렬 (Quick Sort)</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
<main class="flex w-full justify-center">
<section class="px-4 w-11/12 lg:w-1/2 xl:w-7/12">
<div class="mb-10 whitespace-nowrap">
<div class="flex justify-between items-baseline my-4 gap-8">
<h1 id=title class="overflow-ellipsis-bundle text-3xl font-bold p-1">
자료구조
</h1>
<div class="flex flex-col items-end">
<h4 id=date> CREATED 2023-03-02 </h4>
<h4 id=date> MODIFIED 2023-06-10</h4>
</div>
</div>
</div>
<article id=content class="bg-inherit markdown-body flex flex-col">
<h2 id=제-1장--자료구조를-배우기-위한-준비-230302>제 1장 : 자료구조를 배우기 위한 준비 (230302)</h2>
<h3 id=배열>배열</h3>
<ul>
<li>배열(Array): 동일한 타입의 원소들이 <strong>연속적인 메모리 공간</strong>에 할당되어 있는 기초적인 자료구조</li>
</ul>
<h3 id=추상데이터-타입>추상데이터 타입</h3>
<ul>
<li>추상데이터타입(<strong>ADT</strong>:Abstract Data Type) : 데이터와 그 데이터에 대한 추상적인 연산들로써 구성</li>
<li>ADT =~ 자바의 interface, 자료구조 =~ 자바의 class</li>
<li>자료구조는 추상데이터타입을 구체적으로 구현한 것</li>
</ul>
<h2 id=1-2-수행시간의-분석>1-2 수행시간의 분석</h2>
<ul>
<li>알고리즘의 성능: 수행시간을 나타내는 **시간복잡도(Time Complexity)**와 알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기를 나타내는 **공간복잡도(Space Complexity)**에 기반하여 분석</li>
</ul>
<ul>
<li>
<p>시간 복잡도</p>
<ul>
<li>시간복잡도는 알고리즘(연산)이 실행되는 동안에 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타낸다.</li>
<li>기본 연산(Elementary Operation)이란 데이터 간 크기 비교, 데이터 읽기 및 갱신, 숫자 계산 등과 같은 단순한 연산을 의미</li>
</ul>
</li>
<li>
<p>4가지 종류의 분석</p>
<ul>
<li>최악경우 분석(Worst-case Analysis) : 상한선의 의미</li>
<li>평균경우 분석(Average-case Analysis)</li>
<li>최선경우 분석(Best-case Analysis) : 가장 빠른 수행시간</li>
<li>상각분석(Amortized Analysis) : 총 연산횟수를 합하고 연산 횟수로 나누어 수행시간을 분석</li>
</ul>
</li>
</ul>
<h2 id=1-3-수행시간의-점근표기법>1-3 수행시간의 점근표기법</h2>
<ul>
<li>O (Big-Oh)-표기법</li>
<li>Ω (Big-Omega)-표기법</li>
<li>Θ (Theta)-표기법</li>
</ul>
<h3 id=o-big-oh-표기법>O (Big-Oh) 표기법</h3>
<ul>
<li>모든 N ≥ N0에 대해서 f(N) ≤ cg(N)이 성립하는 양의 상수 c와N0가 존재하면, f(N) = O(g(N))이다. 모든 N ≥ N0에 대해서 f(N) ≤ cg(N)이 성립하는 양의 상수 c와 N0가 존재하면, f(N) = O(g(N))</li>
</ul>
<ul>
<li>f(N) = O(g(N))은 N0 보다 큰 모든 N 대해서 f(N)이 양의 상수를 곱한 g(N)에 미치지 못한다는 뜻</li>
<li>g(N)은 f(N)의 <strong>상한(Upper Bound)</strong> 이라고 한다</li>
</ul>
<h3 id=ω-big-omega-표기법>Ω (Big-Omega) 표기법</h3>
<ul>
<li>모든 N ≥ N0에 대해서 f(N) ≥ cg(N)이 성립하는 양의 상수 c와 N0가 존재하면, f(N) = Ω(g(N))</li>
<li>f(N) = Ω(g(N))은 양의 상수를 곱한 g(N)이 f(N)에 미치지 못한다는 뜻</li>
<li>g(N)을 f(N)의 <strong>하한(Lower Bound)</strong> 이라고 한다</li>
</ul>
<h3 id=θ-theta-표기법>Θ (Theta) 표기법</h3>
<ul>
<li>모든 N ≥ N0에 대해서 c1g(N) ≥ f(N) ≥ c2g(N)이 성립하는 양의 상수 c1, c2, N0가 존재하면, f(N) = Θ(g(N))</li>
<li>Θ-표기는 수행시간의 O-표기와 Ω-표기가 동일한 경우에 사용</li>
</ul>
<h3 id=자주-사용되는-함수의-o-표기와-이름>자주 사용되는 함수의 O-표기와 이름</h3>
<ul>
<li>O(1), O(logN), O(N), O(NlogN), O(N2), O(N3), O(2N)</li>
</ul>
<h2 id=1-5-순환-recursion>1-5 순환 (Recursion)</h2>
<h3 id=순환으로-구현된-메소드의-구성요소>순환으로 구현된 메소드의 구성요소</h3>
<ul>
<li>기본(Base) case : 스스로를 더 이상 호출하지 않는 부분</li>
<li>순환 case : 스스로를 호출하는 부분</li>
</ul>
<h3 id=꼬리-순환-tail-recursion>꼬리 순환 (Tail Recursion)</h3>
<ul>
<li>메소드의 마지막 부분에서 순환 (호출 후 되돌아 왔을때 수행할 연산이 없는 경우)</li>
<li>꼬리 순환은 반복문으로 변환하는 것이 효율적이다</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TailRecursion</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>factorial</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> fact<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>==</span>1<span style=color:#f92672>)</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>      <span style=color:#66d9ef>return</span> fact<span style=color:#f92672>;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>    <span style=color:#66d9ef>return</span> factorial<span style=color:#f92672>(</span> <span style=color:#f92672>,);</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>  <span style=color:#f92672>}</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span style=color:#f92672>}</span>
</code></pre></div><h2 id=제-2장--리스트>제 2장 : 리스트</h2>
<h3 id=리스트>리스트</h3>
<ul>
<li>일련의 동일한 타입의 항목들이 나열된 것</li>
</ul>
<h3 id=배열-1>배열</h3>
<ul>
<li>동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 각 항목이 하나의 원소에 저장되는 기본적인 자료구조</li>
<li>접근 : O(1), 삽입/삭제 : O(n)</li>
</ul>
<h3 id=배열로-리스트-구현-arrlist>배열로 리스트 구현 (ArrList)</h3>
<ul>
<li>peek, insert, resize, delete</li>
</ul>
<h3 id=단순-연결-리스트singly-linked-list>단순 연결 리스트(Singly Linked List)</h3>
<ul>
<li>print, search, insertFront, insertAfter</li>
</ul>
<ul>
<li>자기참조변수
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>  <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next<span style=color:#f92672>;</span> <span style=color:#75715e>// 자기 참조 변수
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#75715e></span>  <span style=color:#f92672>...</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#f92672>}</span>
</code></pre></div></li>
<li>수행시간
<ul>
<li>search : O(n)</li>
<li>insert, delete : O(1), p가 안주어지면 O(n)</li>
</ul>
</li>
</ul>
<h3 id=이중-연결-리스트-doubly-linked-list>이중 연결 리스트 (Doubly Linked List)</h3>
<ul>
<li>head, tail, item</li>
<li>insertBefore, insertAfter, delete,</li>
</ul>
<ul>
<li>수행시간
<ul>
<li>삽입/삭제 연산 : O(1)</li>
<li>탐색 연산 : O(n)</li>
</ul>
</li>
</ul>
<h3 id=원형-연결-리스트circular-linked-list>원형 연결 리스트(Circular Linked List)</h3>
<ul>
<li>수행시간
<ul>
<li>삽입/삭제 연산 : O(1)</li>
<li>탐색 연산 : O(n)</li>
</ul>
</li>
</ul>
<h2 id=제-3장--스택과-큐>제 3장 : 스택과 큐</h2>
<h3 id=스택>스택</h3>
<ul>
<li>배열로 구현 / LinkedList로 구현</li>
<li>후위 표기 &lt;-> 중위 표기</li>
<li>수행시간
<ul>
<li>push, pop : O(1)</li>
<li>배열 크기의 확대/축소 : O(n)</li>
<li>단순 연결 리스트의 pop, push : O(1)</li>
</ul>
</li>
</ul>
<h2 id=제-4장--트리>제 4장 : 트리</h2>
<h3 id=용어>용어</h3>
<ul>
<li>root, parent, child</li>
<li>leaf, sibling, ancesto리(조상), descendant(후손)</li>
<li>subtree(노드 자신과 후손으로 구성된 트리)</li>
<li>degree(차수 : 자식 수)</li>
<li>level (깊이와 동일, 0 또는 1부터 시작)</li>
<li>height (트리의 최대 level)</li>
<li>key (탐색에 사용되는 노드에 저장된 정보)</li>
</ul>
<h3 id=왼쪽-자식-오른쪽-형제-left-child-right-sibling-표현>왼쪽 자식-오른쪽 형제 (Left Child-Right Sibling) 표현</h3>
<ul>
<li>노드의 왼쪽 자식과 오른쪽 형제를 가리키는 2개의 레퍼런스만 사용</li>
</ul>
<h3 id=이진-트리-binary-tree>이진 트리 (Binary Tree)</h3>
<ul>
<li>각 노드의 자식 수가 2 이하인 트리</li>
</ul>
<ul>
<li>
<p>특별한 형태의 이진트리</p>
<p><img src=/static/image/ds_speical_binary_tree.png alt="speical binary tree"></p>
<ul>
<li>포화 이진 트리(Perfect Binary Tree)
<ul>
<li>각 내부 노드가 2개의 자식을 가지고 모든 이파리가 같은 층에 있는 트리</li>
</ul>
</li>
<li>완전 이진 트리(Complete Binary Tree)
<ul>
<li>마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차있고, 마지막 레벨에는 노드들이 왼쪽부터 빠짐없이 채워진 트리</li>
</ul>
</li>
</ul>
</li>
<li>
<p>이진 트리의 속성</p>
<ul>
<li>레벨 k에 있는 최대 노드 수 = $2^{k-1}$</li>
<li>높이가 h인 포화 이진 트리에 있는 노드 수 = $2^{h}-1$</li>
<li>n개의 노드를 가진 완전 이진 트리의 높이 = $log_{2}(n+1)$</li>
<li>높이가 h인 완전 이진트리에 존재할 수 있는 노드 수 n</li>
</ul>
</li>
<li>
<p>배열에 저장된 이진 트리</p>
<ul>
<li>
<p>트리</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span>A
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span>├── B
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>│   ├-─ D
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span>│   │   ├── H
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>│   │   └── I
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>│   └-─ E
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>│       ├── J
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>│       └── K
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>└── C
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>    ├── F
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>    └── G
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<ul>
<li>
<p>위 트리를 배열에 저장하면 (인덱스 1부터 시작)</p>
<pre tabindex=0><code>A = [A, B, C, D, E, F, G, H, I, J, K]
</code></pre><ul>
<li>a[i]의 부모는 <strong>a[i/2]</strong>, 단 i>1</li>
<li>a[i]의 왼쪽 자식은 <strong>a[2i]</strong>, 단 2i &lt;= n</li>
<li>a[i]의 오른쪽 자식은 <strong>a[2i+1]</strong>, 단 2i+1 &lt;= n</li>
</ul>
</li>
<li>
<p>편향(skewed) 이진 트리</p>
<ul>
<li>메모리 낭비가 심하다</li>
</ul>
</li>
</ul>
<h3 id=이진-트리의-순회>이진 트리의 순회</h3>
<p>preorder ; root - left - right
inorder : left - root - right
postorder : left - right - root
levelorder : left -> right (from top level)</p>
<h3 id=수행-시간>수행 시간</h3>
<ul>
<li>O(n) 시간이 소요</li>
</ul>
<h3 id=집합의-표현>집합의 표현</h3>
<ul>
<li>배열
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>4</td>
<td>2</td>
<td>7</td>
<td>7</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>7</td>
<td>7</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ul>
<ul>
<li>집합 1</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#ae81ff>7</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>├── <span style=color:#ae81ff>2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>│   ├-─ <span style=color:#ae81ff>1</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>│   └-─ <span style=color:#ae81ff>6</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>├── <span style=color:#ae81ff>8</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>└── <span style=color:#ae81ff>3</span>
</code></pre></div><ul>
<li>집합2</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#ae81ff>4</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>├── <span style=color:#ae81ff>0</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>├── <span style=color:#ae81ff>5</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>└── <span style=color:#ae81ff>9</span>
</code></pre></div><ul>
<li>수행 시간
<ul>
<li>union : O(N)</li>
<li>find : O(N)</li>
</ul>
</li>
</ul>
<h2 id=제-5장--탐색-트리>제 5장 : 탐색 트리</h2>
<h3 id=51-이진탐색트리>5.1 이진탐색트리</h3>
<h4 id=min-함수>min 함수</h4>
<h4 id=deletemin-함수>deleteMin 함수</h4>
<h4 id=delete-함수>delete 함수</h4>
<ul>
<li>CASE 1 : 삭제할 노드의 두 자식이 모두 null</li>
<li>CASE 2 : 삭제할 노드의 오른쪽 자식만 null</li>
<li>CASE 3 : 삭제할 노드의 왼쪽 자식만 null</li>
<li>CASE 4 : 삭제할 노드의 자식이 둘다 존재</li>
</ul>
<h3 id=시간-복잡도>시간 복잡도</h3>
<ul>
<li>O($logn$)</li>
</ul>
<h3 id=52-avl-트리>5.2 AVL 트리</h3>
<h4 id=avl트리의-정의>AVL트리의 정의</h4>
<blockquote>
<p>임의의 노드 x에 대해 x의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1을 넘지 않는 이진 탐색 트리</p>
</blockquote>
<h4 id=avl트리의-회전-연산>AVL트리의 회전 연산</h4>
<ul>
<li>LL 회전 : 왼쪽으로 치우친 경우 rotateRight(n)를 통해 해결</li>
<li>RR 회전 : 오른쪽으로 치우친 경우 rotateLeft(n)를 통해 해결</li>
<li>LR 회전 : rotateLeft(n.left) -> rotateRight(n)로 해결</li>
<li>RL 회전 : rotateRight(n.right) -> rotateLeft(n)로 해결</li>
<li>4가지 회전의 공통점
<blockquote>
<p>회전 후의 트리들이 모두 같다, 모두 O(1)</p>
</blockquote>
</li>
</ul>
<h4 id=avl트리의-연산>AVL트리의 연산</h4>
<ul>
<li>삽입 연산
<ol>
<li>이진 트리의 삽입과 동일하게 새 노드 삽입</li>
<li>새 노드로부터 루트로 거슬러 올라가며 불균형이 발생하면 적절하게 회전 연산 수행</li>
</ol>
</li>
<li>삭제 연산</li>
</ul>
<h3 id=53-2-3-트리>5.3 2-3 트리</h3>
<h4 id=2-3-트리의-정의>2-3 트리의 정의</h4>
<blockquote>
<p>임의의 노드가 2개 또는 3개의 자식을 가질 수 있는 트리로, 모든 리프 노드가 같은 레벨에 있다.</p>
</blockquote>
<h4 id=2-3-트리의-연산>2-3 트리의 연산</h4>
<ul>
<li>탐색 연산
<blockquote>
<p>이진 탐색 트리와 동일한 방법으로 탐색</p>
</blockquote>
</li>
<li>분리 연산
<blockquote>
<p>키를 부모로 올려 보냄<br>
부모가 3-노드이면 다시 분리연산 수행<br>
루트에서 일어나면 트리의 높이 1 증가</p>
</blockquote>
</li>
<li>삽입 연산
<blockquote>
<p>삽입 후 분리 연산을 수행</p>
</blockquote>
</li>
<li>삭제 연산
<blockquote>
<p>삭제할 노드가 이파리 노드이면 그냥 삭제<br>
삭제한 노드가 이파리 노드가 아니라면 교환 후 삭제
이동 연산, 통합 연산 사용</p>
</blockquote>
</li>
<li>이동 연산
<blockquote>
<p>빈 자리를 형제와 바꾼다<br>
이동연산이 불가능하면 통합 연산 수행</p>
</blockquote>
</li>
<li>통합 연산
<blockquote>
<p>삭제한 노드의 부모와 형제를 통합한다</p>
</blockquote>
</li>
</ul>
<h4 id=2-3-트리의-수행시간>2-3 트리의 수행시간</h4>
<ul>
<li>탐색, 삽입, 삭제 연산 -> O($logn$) -> 트리의 높이에 비례</li>
<li>분리 연산, 통합 연산 -> O(1)</li>
<li>2-3트리가 가장 높은 경우 모든 노두가 2-노드인 경우
<blockquote>
<p>높이 : $ log_2(n+1) $</p>
</blockquote>
</li>
<li>2-3트리가 가장 낮은 경우 모든 노드가 3-노드인 경우
<blockquote>
<p>높이 : $ log_3(n) $</p>
</blockquote>
</li>
</ul>
<h3 id=54-2-3-4-트리>5.4 2-3-4 트리</h3>
<blockquote>
<p>2-3트리를 확장한 2-3-4 트리는 노드가 자식을 4개까지 가질 수 있는 완전균형트리</p>
</blockquote>
<ul>
<li>이론적으로는 2-3트리와 동일하다 실제로는 더 빠름</li>
</ul>
<h3 id=55-b-트리>5.5 B-트리</h3>
<h4 id=b-트리의-정의>B-트리의 정의</h4>
<blockquote>
<p>다수의 키를 가진 노드로 구성되어 다방향 탐색이 가능한 균현트리</p>
</blockquote>
<h4 id=b-트리의-연산>B-트리의 연산</h4>
<ul>
<li>탐색 연산
<blockquote>
<p>루트 부터 시작 각 노드에서 이진 탐색 수행</p>
</blockquote>
</li>
<li>삽입 연산
<blockquote>
<p>이파리에 새 키를 수용할 공간이 있다면, 정렬된 상태를 유지하도록 삽입
이미 M-1개의 키를 가지고 있으면, 분리 연산을 수행</p>
</blockquote>
</li>
<li>삭제 연산
<blockquote>
<p>삭제할 노드가 이파리 노드이면 그냥 삭제
삭제한 노드가 이파리 노드가 아니라면 교환 후 삭제
이동 연산, 통합 연산 사용</p>
</blockquote>
</li>
<li>이동 연산
<blockquote>
<p>키의 수가 M/2-1보다 작으면(underflow) 형제, 부모노드를 이능
이동 연산이 불가능하면 통합 연산 수행</p>
</blockquote>
</li>
<li>통합 연산
<blockquote>
<p>삭제한 노드의 부모와 형제를 통합한다</p>
</blockquote>
</li>
</ul>
<h4 id=b-트리의-수행시간>B-트리의 수행시간</h4>
<ul>
<li>탐색, 삽입, 삭제 연산 -> O($log_{M/2}n$) -> 트리의 높이에 비례</li>
</ul>
<h2 id=제-6장--해시-테이블>제 6장 : 해시 테이블</h2>
<h4 id=대표적인-해시-함수>대표적인 해시 함수</h4>
<ul>
<li>중간 제곱 함수 : 키를 제곱한 후, 적절한 크기의 중간 부분을 사용</li>
<li>접기 함수 : 키를 여러 부분으로 나눈 후, 이들을 더한 값을 사용</li>
</ul>
<h4 id=자바의-hashcode>자바의 hashCode()</h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>(</span>Key k<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>k<span style=color:#f92672>.</span><span style=color:#a6e22e>hashCode</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;</span> 0x7fffffff<span style=color:#f92672>)</span> <span style=color:#f92672>%</span> M<span style=color:#f92672>;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#f92672>}</span>
</code></pre></div><h4 id=해시-테이블의-저장-방식>해시 테이블의 저장 방식</h4>
<ul>
<li>개방 주소 방식 : 충돌된 키를 일정한 방식에 따라 찾아낸 empty원소에 저장</li>
<li>선형 조사, 이차조사, 이중해싱</li>
</ul>
<h4 id=선형-조사--충돌이-일어난-곳으로부터-순차적으로-탐색>선형 조사 : 충돌이 일어난 곳으로부터 순차적으로 탐색</h4>
<ul>
<li>1차 군집화 (키들이 뭉쳐지는 현상) 발생</li>
<li>군집화는 군집된 키들을 순차적으로 방문해야하는 문제점을 일으킨다</li>
</ul>
<h2 id=제-7장--우선순위-큐>제 7장 : 우선순위 큐</h2>
<h3 id=우선순위-큐-priority-queue>우선순위 큐 (Priority Queue)</h3>
<ul>
<li>가장 높은 우선순위를 가진 항목에 접근과 삭제, 임의의 우선순위를 가진 항목의 삽입을 지원하는 자료구조</li>
</ul>
<h3 id=힙-heap>힙 (Heap)</h3>
<ul>
<li>완전 이진 트리로서 부모의 우선순위가 자식의 우선순위보다 높은 자료구조</li>
<li>최소 힙, 최대 힙</li>
</ul>
<h3 id=힙의-연산>힙의 연산</h3>
<h4 id=최솟값-삭제>최솟값 삭제</h4>
<ul>
<li>루트 삭제 후, 마지막 노드를 루트로 이동</li>
<li>downheap 수행 : 루트부터 비교하면서 내려감</li>
</ul>
<h4 id=삽입>삽입</h4>
<ul>
<li>마지막 항목의 다음에 삽입</li>
<li>upheap 수행 : 루트로 비교하면서 올라감</li>
</ul>
<h3 id=상향식-힙>상향식 힙</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createHeap</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>  <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> N<span style=color:#f92672>/</span>2<span style=color:#f92672>;</span> i<span style=color:#f92672>&gt;</span>0<span style=color:#f92672>;</span> i<span style=color:#f92672>--)</span> <span style=color:#f92672>{</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span>    downheap<span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>  <span style=color:#f92672>}</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>O(n)</li>
</ul>
<h3 id=수행-시간-1>수행 시간</h3>
<ul>
<li>접근, 삽입, 삭제 : O(logn)</li>
</ul>
<h2 id=제-8장--정렬>제 8장 : 정렬</h2>
<h3 id=선택-정렬-selection-sort>선택 정렬 (Selection Sort)</h3>
<ul>
<li>항상 O(n^2)</li>
</ul>
<h3 id=삽입-정렬-insertion-sort>삽입 정렬 (Insertion Sort)</h3>
<ul>
<li>최악 : O(n^2)</li>
<li>최선 : O(n) : 이미 정렬된 경우</li>
</ul>
<h3 id=힙-정렬-heap-sort>힙 정렬 (Heap Sort)</h3>
<ul>
<li>항상 : O(nlogn)</li>
</ul>
<h3 id=합병-정렬-merge-sort>합병 정렬 (Merge Sort)</h3>
<ul>
<li>항상 : O(nlogn)</li>
<li>Stable Sort : 같은 값의 키를 가진 레코드의 순서가 정렬 후에도 유지되는 정렬</li>
</ul>
<h3 id=퀵-정렬-quick-sort>퀵 정렬 (Quick Sort)</h3>
<ul>
<li>
<p>최악 : O(n^2)</p>
</li>
<li>
<p>최선 : O(nlogn)</p>
</li>
<li>
<p>성능 향상 방법</p>
<ul>
<li>Median of Three : 첫번째, 마지막, 중간값 중에서 중간값을 피벗으로 선택</li>
<li>입력이 작은 크기가 되었을때 삽입 정렬을 사용</li>
</ul>
</li>
</ul>
</article>
<div id=meta class=mt-24>
<div>
<div class="flex justify-between w-full whitespace-nowrap">
<a class="previous mr-5 overflow-hidden overflow-ellipsis hover-bold" href=/til/school/probabilityandstatistics/>
확률과 통계</a>
<a class="next ml-5 overflow-hidden overflow-ellipsis hover-bold" href=/til/school/operatingsystem1/>
운영체제 - 중간범위</a>
</div>
</div>
</div>
</section>
</main>
</body>
</html>
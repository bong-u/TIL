<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🍃|Spring on Bong-u's TIL</title><link>https://bong-u.github.io/til/spring/</link><description>Recent content in 🍃|Spring on Bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://bong-u.github.io/til/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring - JPA : getReferenceById vs findById</title><link>https://bong-u.github.io/til/spring/jpa_getbyid_refbyid/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/jpa_getbyid_refbyid/</guid><description>배경 Service layer에서 createPost 메소드를 구현하는 중 이었다 Post entity는 User entity와 ManyToOne 관계이다 User entity를 가져오는 방식에 따라 두가지 방식의 구현이 가능했다 두 방식의 장단점을 파악해보았다 getReferenceById 사용 public Post createPost(PostDTO.Request postDTO, int userId) { // 프록시 객체를 가져온다 User user = userRepository.getReferenceById(userId); Post post = Post.builder() .title(postDTO.getTitle()) .content(postDTO.getContent()) .created_at(LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS)) .author(user) .build(); try { return postRepository.save(post); } catch (DataIntegrityViolationException e) { throw new EntityNotFoundException(&amp;#34;해당 유저가 없습니다.&amp;#34;); } } 장점 : 쿼리 한번으로 Post entity를 생성할 수 있다 단점 : insert 쿼리 실행 중 발생한 예외를 잡기 때문에 안정적이지 않다 findById 사용 public Post createPost(PostDTO.</description></item><item><title>Spring - JPA : 프록시 객체, 영속성 전이, 고아 객체</title><link>https://bong-u.github.io/til/spring/jpa2/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/jpa2/</guid><description>프록시 객체 프록시는 JPA의 실제 엔티티를 필요할 때만 꺼내쓰도록하는 가짜 객체이다 em.find 대신 em.getReference를 사용하면 프록시 객체를 얻을 수 있다 JPA에서는 프록시 객체를 사용하여 지연 로딩을 지원한다 FetchType.EAGER (즉시 로딩) Order order = em.find(Order.class, orderId); Member member = order.getMember(); // 지금 member는 실제 객체이다 String name = member.getName(); // 1차 캐시에서 조회한다 FetchType.LAZY (지연 로딩) Order order = em.find(Order.class, orderId); Member member = order.getMember(); // 지금 member는 프록시 객체이다 String name = member.</description></item><item><title>Spring - JPA : 개념, 영속성 컨텍스트, 연관 관계 매핑</title><link>https://bong-u.github.io/til/spring/jpa1/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/jpa1/</guid><description>JPA (Java Persistence API) JAVA진영의 ORM 기술 표준, interface 모음 Hibernate, EclipseLink, DataNucleus 등의 구현체가 존재 EntityManager Entity : RDB의 Table과 매핑되는 객체 EntityManagerFactory Entity를 관리하는 EntityManager를 생산하는 공장 Thread safe: O EntityManager Entity의 CRUD등 모든 일을 처리 Thread safe: X 영속성 컨텍스트 Entity를 영구 저장하는 환경 EntityManager는 Entity를 영속성 컨텍스트에 보관하고 관리한다 영속성 컨텍스트에서 관리되는 Entity는 식별자값을 가져야 한다 (ID) -&amp;gt; key-value로 Entity를 관리하기 때문 flush: 영속성 컨텍스트에 변경 내용들을 DB에 동기화하는 작업 영속성 컨텍스트의 이점 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩 Entity의 Life cycle 비영속 (New / Transient): 영속성 컨텍스트와 전혀 관계가 없는 상태 영속 (Managed): 영속성 컨텍스트에 저장된 상태 준영속 (Detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제 (Removed): 삭제된 상태 저장 EntityManager em = emf.</description></item><item><title>Spring - Bean Validation : Annotation으로 Validation하기</title><link>https://bong-u.github.io/til/spring/bean_validation/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/bean_validation/</guid><description>Bean Validation Annotation을 달아서 Validation을 수행할 수 있다. 주로 jakarta.validation과 hibernate.validator 두 패키지를 사용한다. Dependency Diagram 구조 spring-boot-starter-validation -&amp;gt; hibernate-validator -&amp;gt; jakarta.validation-api
jakarta.validation에서 지원하는 annotation Annotation Description @NotNull null이 아닌가 (&amp;quot;&amp;quot;, &amp;quot; &amp;quot; =&amp;gt; 통과) @NotEmpty null이 아니고, size가 0인가 (&amp;quot; &amp;quot; =&amp;gt; 통과) @NotBlank null이 아니고, trim한 결과가 empty인가 @Size 문자열, 배열의 길이가 해당 범위에 있는가 @Min 숫자가 해당 범위에 있는가 @Max 숫자가 해당 범위에 있는가 @Email 이메일 형식에 맞는가 @Pattern Regex(정규식)에 맞는가 @Past 과거의 날짜인가 @Future 미래의 날짜인가 @Digits 정수, 소수 자릿수가 해당 범위에 있는가 @DecimalMin, @DecimalMax 자릿수가 해당 범위에 있는가 (소수 이하 자릿수 포함) @Positive, @PositiveOrZero, @Negative, @NegativeOrZero hibernate.</description></item><item><title>Spring - RESTful API에서 내맘대로 에러 응답하기</title><link>https://bong-u.github.io/til/spring/rest_error_response/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/rest_error_response/</guid><description>1. 클래스 정의 @Getter @RequiredArgsConstructor public class ExceptionResponse { private final LocalDateTime timestamp = LocalDateTime.now(); // 2023-08-01T00:00:57.5995502 private final int status; // 400 private final String error; // MethodArumentNotValidException private final String message; // 이메일 형식이 아닙니다 private final String path; // /api/customer } 내가 원하는 방식대로 클래스를 정의한다, 주석에는 해당 필드의 예시를 적어놓았다 2. ResponseEntity 만드는 함수 정의 private ResponseEntity&amp;lt;ExceptionResponse&amp;gt; handleException(HttpStatus status, Exception e, HttpServletRequest request) { ExceptionResponse response = new ExceptionResponse( status.</description></item><item><title>Spring - ResponseEntity 정리</title><link>https://bong-u.github.io/til/spring/responseentity/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/responseentity/</guid><description>ResponseEntity Spring에서 HttpEntity라는 클래스를 지원한다 HttpEntity를 상속받는 두 클래스가 RequestEntity와 ResponseEntity이다 RequestEntity는 http요청을 보낼때 사용하고 ResponseEntity는 http응답을 할때 사용한다 정의 body, header, status를 인자로 넘길 수 있다 public class ResponseEntity&amp;lt;T&amp;gt; extends HttpEntity&amp;lt;T&amp;gt; { public ResponseEntity(HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, HttpStatusCode status) {...} public ResponseEntity(MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, @Nullable MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {...} public ResponseEntity(@Nullable T body, @Nullable MultiValueMap&amp;lt;String, String&amp;gt; headers, int rawStatus) {.</description></item><item><title>Spring - @RestController 정리</title><link>https://bong-u.github.io/til/spring/restcontroller/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/restcontroller/</guid><description>@RestController @Controller와 @ResponseBody를 합친 Annotation이다 @Controller는 ViewName을 반환해서 DispatcherServlet이 ViewResolver을 사용한다 @RestController는 객체를 반환해서 HttpMessageConverter가 객체를 Json으로 변환한다 @Controller와의 코드 비교 @Controller @GetMapping(&amp;#34;&amp;#34;) public @ResponseBody List&amp;lt;Voucher&amp;gt; getVouchers() { return voucherRepository.list(); } @RestController @GetMapping(&amp;#34;&amp;#34;) public List&amp;lt;Voucher&amp;gt; getVouchers() { return voucherRepository.list(); } @RestControllerAdvice @ControllerAdvice와 같이 @Controller에서 발생한 예외를 전역적으로 처리하는 Annotation이다 @ControllerAdvice와 @RestControllerAdvice의 차이는 @Controller와 @RestController의 차이와 같다 예제 - @RestControllerAdvice 구현 필자는 Controller에서 발생한 IllegalArgumentException을 400 Bad Request로 처리하였다 @RestControllerAdvice public class ControllerExceptionHandler { @ExceptionHandler(IllegalArgumentException.</description></item><item><title>Spring 개념 - POJO, DAO, DTO, VO, Entity</title><link>https://bong-u.github.io/til/spring/object/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/object/</guid><description>Spring의 여러 객체들 여기저기서 들어봤지만 개념이 머리에 정리되지 않아 기술한다 POJO (Plain Old Java Object) 특정 기술에 종속되지 않는 순수한 자바 객체
기본 생성자를 가진다 아무것도 상속받거나, 구현하지 않아야 한다 getter랑 setter만 존재 해야한다 public class Person { private String name; private int age; public Person() { } public String getName() { return name; } public int getAge() { return age; } public void setName(String name) { this.</description></item><item><title>Spring 개념 - MVC 패턴, Servlet (서블릿)</title><link>https://bong-u.github.io/til/spring/mvc_servlet/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/mvc_servlet/</guid><description>Servlet 개념 클라이언트의 요청을 처리하고, 그 결과를 반환하는 자바 웹 프로그래밍 기술
웹페이지를 동적으로 생성하는 역할을 수행한다 Servlet Conainer의 역할 Servlet의 생명주기를 관리한다 웹서버와의 통신지원 멀티쓰레드 지원, 관리 선언적인 보안 관리 예제 - Servlet 구현 public class TestServlet extends HttpServlet { private static final Logger logger = LoggerFactory.getLogger(TestServlet.class); @Override public void init() throws ServletException {} } doGet, doPost 등의 메소드를 구현해서 http 요청을 처리할 수 있다 Servlet Context를 등록하는 방법 web.</description></item><item><title>Spring 개념 - Transaction (트랜잭션)</title><link>https://bong-u.github.io/til/spring/transaction/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/transaction/</guid><description>상황 소비자가 판매자의 물건을 구매하는 함수를 구현 중이라고 하자 물건을 샀을때, 물건의 가격만큼 판매자의 돈은 증가시키고, 소비자의 돈은 감소시켜야한다 판매자의 돈은 증가시켰는데, 소비자의 돈을 감소시키는 중 오류가 났다 오류가 난 경우, 판매자의 돈을 증가시키기 이전으로 Rollback 해야 한다 위의 두가지 연산은 하나의 Transaction으로 묶여서 한번에 처리되어야 한다 Transaction 관리의 종류 Programmatic transaction management (프로그래밍적 트랜잭션 관리)
Transaction 관련 코드를 직접 작성 예제 - TransactionManager 사용 // Bean 등록 @Bean public PlatformTransactionManager platformTransactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } // 사용할 때 // 새로운 트랜잭션을 시작한다 var transaction = transactionManager.</description></item><item><title>Spring 개념 - JDBC, DBCP, JdbcTemplate</title><link>https://bong-u.github.io/til/spring/jdbc/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/jdbc/</guid><description>JDBC 자바 프로그램을 DB와 연결해주는 API
JDBC 드라이버 DBMS와 통신을 담당하는 자바 클래스
JDBC 드라이버는 4가지 종류가 있다 (Type 1~4) Mysql은 Type 4를 지원한다 예제 - Connection을 직접 연결 public List&amp;lt;UUID&amp;gt; findAllIds() { List&amp;lt;UUID&amp;gt; uuids = new ArrayList&amp;lt;&amp;gt;(); try ( var connection = DriverManager.getConnection(url, username, password); var statement = connection.createStatement(); var resultSet = statement.executeQuery(SELECT_ALL_SQL); ) { while (resultSet.next()) { var customerName = resultSet.getString(&amp;#34;name&amp;#34;); var customerId = toUUID(resultSet.</description></item><item><title>Issue - Jar 실행환경에서 ClassPathResource를 가져오지 못하는 문제</title><link>https://bong-u.github.io/til/spring/class_resource_issue/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/class_resource_issue/</guid><description>상황 개발 환경에서는 ClassPathResource를 문제없이 불러온다
jar로 package해서 실행했을 때 오류가 발생한다
Caused by: java.lang.RuntimeException: Cannot read blacklist file at org.academy.springorder.blacklist.BlacklistRepository.list(BlacklistRepository.java:25) at org.academy.springorder.blacklist.BlacklistService.list(BlacklistService.java:16) at org.academy.springorder.CommandLineApplication.main(CommandLineApplication.java:66) ... 8 more 문제의 코드
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); try { list = Files.readAllLines(blacklist.getFile().toPath()); } catch (IOException e) { throw new RuntimeException(&amp;#34;Cannot read blacklist file&amp;#34;); } 해결 readAllLines를 사용하지 않고 InputStreamReader와 BufferedRearder를 사용하여 해결하였다.</description></item><item><title>Spring 개념 - Profile</title><link>https://bong-u.github.io/til/spring/profile/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/profile/</guid><description>Profile 프로그램을 개발, 테스트, 배포 환경으로 나눠서 실행해야할때가 있다 환경 설정을 위해 spring boot에서는 profile을 사용할 수 있다. 환경 변수 application.yml spring.config.activate.on-profile: dev env: version: &amp;#34;v1.0.0 dev&amp;#34; --- spring.config.activate.on-profile: local env: version: &amp;#34;v1.0.0 local&amp;#34; --- yml 파일에서는 &amp;mdash;를 이용해 파일 분할이 가능하다 spring.config.active.on-profile을 설정해서 특정 프로필에 적용하고 싶은 환경변수를 설정 할 수 있다. application-&amp;lt;profile&amp;gt;.properties .properties파일에서는 여러 파일로 분할하여 설정한다 예를 들어 &amp;ldquo;dev&amp;quot;프로파일에서 적용될 파일은 &amp;ldquo;application-dev.properties&amp;quot;이다. @Profile 프로파일마다 Bean객체를 다르게 등록할 수 있다.</description></item><item><title>Spring 개념 - Environment</title><link>https://bong-u.github.io/til/spring/environment/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/environment/</guid><description>application.properties 환경변수 설정 application.properties 파일을 작성한다 파일 위치 : reousrces/application.properties 파일 내용 예시 : key = value 형태 app.name = spring Configuration에 설정한다 @Configuration @PropertySource(&amp;#34;application.properties&amp;#34;) public class AppConfiguration {...} 환경변수 가져오기 ApplicationContext 활용하는 방법 var environment = applicationContext.getEnvironment(); var property = environment.getProperty(&amp;#34;app.name&amp;#34;) @Value Annotation 활용 @Value(&amp;#34;${app.name}&amp;#34;) private String name; 별도의 클래스 정의 클래스 정의
@Component @PropertySource(&amp;#34;version.properties&amp;#34;) public class VersionProvider { private final String version; public VersionProvider(@Value(&amp;#34;${version:v0.</description></item><item><title>Spring 개념 - IoC (Inversion of Control)</title><link>https://bong-u.github.io/til/spring/ioc/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/ioc/</guid><description>IoC (Inversion of Control) 제어의 역전 메소드나 객체의 호출 작업이, 개발자가 아니라, 외부에서 결정되는 것 객체 간 결합도를 줄이고 유연한 코드를 작성하게 한다 IoC Container IoC가 일어나는 곳, IoC를 수행하는 대상 IoC 클래스 예제 public class OrderContext { public OrderRepository orderRepository() { return new OrderRepository(); } public OrderService orderService() { return new OrderService(voucherService(), orderRepository()); } } 위 예제에서 OrderContext 클래스가 IoC 컨테이너 역할을 하고 있다 BeanFactory Spring container의 최상위 interface Bean을 생성하고 의존관계를 설정하는 기능을 담당하는 가장 기본적인 IoC 컨테이너 Lazy-loading 방식 사용 : Bean을 사용할때 loading -&amp;gt; 경량 컨테이너 ApplicationContext BeanFactroy의 구현체 Eager-loading 방식 : Runtime에 Bean을 loading &amp;lt;-&amp;gt; Lazy-loading AnnotationConfigApplicationContext ApplicationContext의 구현체 Annotation 기반으로 설정하는 방식 &amp;lt;-&amp;gt; XML방식</description></item><item><title>Spring 개념 - Logging</title><link>https://bong-u.github.io/til/spring/logging/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/logging/</guid><description>Java Logging Framework java.util.logging Apache Commons logging Log4J Logback SLF4J SLF4J (Simple Loggin Facade for Java) Loggin Framework들을 추상화시켜 놓은 것 Facade Pattern을 이용한 Logging framework Log Level trace - debug - info - warn - error
Logger Logger 만들기 private static final Logger logger = LoggerFactory.getLogger(OrderTester.class); Logger 이름은 보통 FQCN (상위 패키지 + 클래스)으로 사용한다 Logger 사용 logger.info(&amp;#34;version -&amp;gt; {}&amp;#34;, logger.getName()); logback logback 설정파일 우선순위 logback-test.</description></item><item><title>Spring 개념 - Maven</title><link>https://bong-u.github.io/til/spring/maven/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/maven/</guid><description>Maven coordinates groupId : 회사나 단체명 ex) org.springframework, org.prgms artifactId : 프로젝트 명 ex) spring-context, order-api version : 프로젝트 버전 ex) 5.2.15-RELEASE, 1.0-SNAPSHOT Build lifecycle validate, compile, test, package, verify, install, deploy Trnsitive Dependencies A ├── B │ └─ C └── D C는 A의 transitive 의존성 Dependency Scope (&amp;lt;scope&amp;gt;) compile(default) : 컴파일, 테스트, 실행에 라이브러리가 필요할때 provided : JDK 또는 컨테이너가 해당 라이브러리를 제공할때 (JSP, servlet) runtime : 실행과 테스트에만 사용될때 (JDBC driver) test : 테스트 컴파일 및 실행에만 필요할때 (easymock, junit) system: provided와 비슷하지만, 사용자가 jar파일의 위치를 지정 example &amp;lt;project xmlns=&amp;#34;http://maven.</description></item><item><title>MVC 3 : Session, Interceptor, Cookies</title><link>https://bong-u.github.io/til/spring/13_mvc_3/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/13_mvc_3/</guid><description>Session 로그인 할 때 세션에 등록 LoginController.java @PostMapping public String submit(LoginCommand loginCommand, Errors errors, HttpSession session) { new LoginCommandValidator().validate(loginCommand, errors); if (errors.hasErrors()) { return &amp;#34;login/loginForm&amp;#34;; } try { AuthInfo authInfo = authService.authenticate(loginCommand.getEmail(), loginCommand.getPassword()); session.setAttribute(&amp;#34;authInfo&amp;#34;, authInfo); return &amp;#34;login/loginSuccess&amp;#34;; } catch (WrongIdPasswordException e) { errors.reject(&amp;#34;idPasswordNotMatching&amp;#34;); return &amp;#34;login/loginForm&amp;#34;; } } 로그아웃 할때 세션에서 삭제 LogoutController.java @RequestMapping(&amp;#34;/logout&amp;#34;) public String logout(HttpSession session) { session.invalidate(); return &amp;#34;redirect:/main&amp;#34;; } 로그인 상태 여부에 따라 다르게 보여주기 &amp;lt;c:if test=&amp;#34;${ empty authInfo }&amp;#34;&amp;gt; &amp;lt;p&amp;gt;환영합니다.</description></item><item><title>MVC 2 : Messages, Validate command object</title><link>https://bong-u.github.io/til/spring/12_mvc_2/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/12_mvc_2/</guid><description>Messages label.properties member.register=회원가입 &amp;lt;%@ taglib prefix=&amp;#34;spring&amp;#34; uri=&amp;#34;http://www.springframework.org/tags&amp;#34; %&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;spring:message code=&amp;#34;member.register&amp;#34; /&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; 사이트가 여러 언어를 지원해야할 때 label_ko.properties, label_en.properties와 같이 만든다고 한다 http헤더의 Accept-Launguage를 자동으로 인식한다고 하니까 편할 것 같다 Validate command object Validation RegisterRequestValidator @Override public void validate(Object target, Errors errors) { RegisterRequest regReq = (RegisterRequest) target; if(regReq.getEmail() == null | regReq.getEmail().trim().isEmpty()) { errors.rejectValue(&amp;#34;email&amp;#34;, &amp;#34;bad&amp;#34;); } else { Matcher matcher = pattern.matcher(regReq.getEmail()); if(!</description></item><item><title>MVC 1 : Request Mapping, Command Object, Redirect, Form Tag, Model</title><link>https://bong-u.github.io/til/spring/11_mvc_1/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/11_mvc_1/</guid><description>Request Mapping GetMapping/PostMapping으로 처리할 method를 지정하거나 RequestMapping을 사용할 수 있다. Access request parameter : HttpServletRequest @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2(HttpServletRequest request) { String agreeParam = request.getParameter(&amp;#34;agree&amp;#34;); if (agreeParam == null || !agreeParam.equals(&amp;#34;true&amp;#34;)) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Access request parameter : RequestParam Annotation @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2( @RequestParam(value=&amp;#34;agree&amp;#34;, defaultValue=&amp;#34;false&amp;#34;) Boolean agree) { if (!agree) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Redirect @GetMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2Get() { return &amp;#34;redirect:/register/step1&amp;#34;; Command Object Use request parameter as command object RegisterController.</description></item><item><title>08_connect_DB</title><link>https://bong-u.github.io/til/spring/08_connect_db/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/08_connect_db/</guid><description>DataSource 설정 AppCtx.java @Bean(destroyMethod = &amp;#34;close&amp;#34;) public DataSource dataSource() { DataSource ds = new DataSource(); ds.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); ds.setUrl(&amp;#34;jdbc:mysql://localhost/spring5fs?&amp;#34;+ &amp;#34;enabledTLSProtocols=TLSv1.2&amp;amp;&amp;#34;+ &amp;#34;useSSL=false&amp;amp;&amp;#34;+ &amp;#34;characterEncoding=utf8&amp;#34;); ds.setUsername(&amp;#34;spring5&amp;#34;); ds.setPassword(&amp;#34;spring5&amp;#34;); ds.setInitialSize(2); ds.setMaxActive(10); ds.setTestWhileIdle(true); ds.setMinEvictableIdleTimeMillis(60000 * 3); ds.setTimeBetweenEvictionRunsMillis(10 * 1000); return ds; } Query 실행 JdbcTemplate을 이용한 select jdbcTemplate.query( &amp;#34;select * from MEMBER where EMAIL = ?&amp;#34;, new RowMapper&amp;lt;Member&amp;gt;() { @Override public Member mapRow(ResultSet rs, int rowNum) throws SQLException { Member member = new Member( rs.getString(&amp;#34;EMAIL&amp;#34;), rs.getString(&amp;#34;PASSWORD&amp;#34;), rs.</description></item><item><title>Spring 개념 - AOP (Aspect Oriented Programming)</title><link>https://bong-u.github.io/til/spring/aop/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/aop/</guid><description>AOP (Aspect Oriented Programming) 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법 기본 개념 : 핵심 기능에 공통 기능을 삽입 구현하는 3가지 방법 컴파일 시점에 코드에 공통 기능을 삽입하는 방법 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법 AOP 주요 용어 Target 부가 기능을 부여할 대상
Advice 부가기능을 담고 있는 모듈</description></item><item><title>09_spring_MVC</title><link>https://bong-u.github.io/til/spring/09_spring_mvc/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/09_spring_mvc/</guid><description>Spring MVC 시작하기 프로젝트 생성 앞에서 만들었던 자바 애플리케이션과는 좀 다른점이 있었다 jar이 아닌 war을 사용하는 등 여러가지 많았는데 일일이 적지는 않을 것이다 Controller @Controller public class HelloController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(Model model, @RequestParam(value=&amp;#34;name&amp;#34;, required=false) String name) { model.addAttribute(&amp;#34;greeting&amp;#34;, &amp;#34;안녕하세요&amp;#34; + name); return &amp;#34;hello&amp;#34;; } } JSP &amp;lt;%@ page contentType=&amp;#34;text/html; charset=utf-8&amp;#34; %&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 인사말 : ${greeting} &amp;lt;/body&amp;gt; &amp;lt;/html URL접속해도 해당 jsp파일이 나오지 않는 문제 vscode에서 community server connector라는 extension을 통해 tomcat을 띄워서 할려고 한다 특정 jsp를 감지했는지, serving하는지에 대한 로그가 없어 되는건지 알 수가 없다 web.</description></item><item><title>Spring 개념 - Autowired</title><link>https://bong-u.github.io/til/spring/autowired/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/autowired/</guid><description>@Autowired를 이용한 자동 객체 주입 방법1 : Field에 적용
public class MemberListPrinter { @Autowired private MemberDao memberDao; @Autowired private MemberPrinter printer; public MemberListPrinter() {} public void printAll() { Collection&amp;lt;Member&amp;gt; members = memberDao.selectAll(); members.forEach(m -&amp;gt; printer.print(m)); } } 방법2 : Method에 적용
public class MemberListPrinter { private MemberDao memberDao; private MemberPrinter printer; public MemberListPrinter() {} @Autowired public void setMemberDao(MemberDao memberDao) { this.memberDao = meberDao; } @Autowired public void setMemberPrinter(MemberPrinter memberPrinter) { this.</description></item><item><title>Spring 개념 - Bean Lifecycle &amp; Scope</title><link>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</guid><description>Bean 객체의 Lifecycle Bean 객체가 생성 또는 소멸될때 특정 코드를 실행하게 할 수 있다. @PostConstruct, @PreDestroy Annotation 사용
// Bean 객체 생성될 때 실행 @PostConstruct public void postConstruct() {...} // Bean 객체 소멸될 때 실행 @PreDestroy public void preDestroy() {...} InitializingBean, DisposableBean 구현
public class Client implements InitializingBean, DisposableBean { // Bean 객체 생성될 때 실행 @Override public void afterPropertiesSet() throws Exception {...} // Bean 객체 소멸될 때 실행 @Override public void destroy() throws Exception {.</description></item><item><title>Spring 개념 - Component Scan</title><link>https://bong-u.github.io/til/spring/component_scan/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/component_scan/</guid><description>개념 Component Scan은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다 xml 또는 annotation을 통해 사용 가능하다 @ComponentScan basePacakges : 패키지 이름을 통해 스캔할 범위를 지정한다
@ComponentScan(basePackages=&amp;#34;org.academy.order&amp;#34;) @ComponentScan(basePackages={&amp;#34;org.academy.order&amp;#34;, &amp;#34;org.academy.voucher&amp;#34;}) basePackageClasses : 해당 클래스가 들어있는 패키지를 범위로 지정한다
@ComponentScan(basePackageClasses=&amp;#34;Order.class&amp;#34;) @ComponentScan(basePackages={&amp;#34;Order.class&amp;#34;, &amp;#34;Voucher.class&amp;#34;}) 예제 AppCtx.java
@Configuration @ComponentScan(basePackages = {&amp;#34;spring&amp;#34;}) public class AppCtx {...} MemberInfoPrinter.java
@Component(&amp;#34;infoPrinter&amp;#34;) public class MemberInfoPrinter {...} 효과</description></item><item><title>Spring 개념 - DI (Dependency Injection)</title><link>https://bong-u.github.io/til/spring/di/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/di/</guid><description>의존 주입 (DI : Dependency Injection)을 하는 방법 Assembler라는 별도의 클래스 생성
public class Assembler { private MemberDao memberDao; private MemberRegisterService regSvc; public Assembler() { memberDao = new MemberDao(); regSvc = new MemberRegisterService(memberDao); } public MemberDao getMemberDao() { return memberDao; } public MemberRegisterService getMemberRegisterService() { return regSvc; } } Spring에서 지원하는 DI 사용
@Configuration public class AppCtx { @Bean public MemberDao memberDao() { return new MemberDao(); } @Bean public MemberRegisterService memberRegSvc() { return new MemberRegisterService(memberDao()); } } DI 방식 Constructor 방식 @Bean public MemberListPrinter listPrinter() { return new MemberListPrinter(memberDao(), memberPrinter()); } Setter method 방식 @Bean public MemberInfoPrinter infoPrinter() { MemberInfoPrinter infoPrinter = new MemberInfoPrinter(); infoPrinter.</description></item><item><title>Spring 개념 - Testing</title><link>https://bong-u.github.io/til/spring/testing/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://bong-u.github.io/til/spring/testing/</guid><description>Unit Test (단위 테스트) 가장 작은 단위 (클래스 또는 메소드)를 고립시켜서 테스트하는 방식
관련 용어 SUT (Sytem Under Test) 테스트하고자하는 주요 대상이 되는 Unit
DOC (Depended On Component) SUT가 의존하는 객체
Test double DOC를 대신해 줄 수 있는 객체
Test double의 종류 : Mock, Stub Mock 행위 검증 (객체가 특정 동작을 수행하는지 검증) 사용 test framework : Mockito, JMock, EasyMock Stub 상태 검증 (객체의 상태를 확인하여 검정) 사용 Integration Test (통합 테스트) 여러 개의 Unit을 통합해서 테스트하는 방식</description></item></channel></rss>
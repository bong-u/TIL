<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Springs on bong-u's TIL</title><link>/spring/</link><description>Recent content in Springs on bong-u's TIL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 06 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>MVC 3 : Session, Interceptor, Cookies</title><link>/spring/13_mvc_3/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>/spring/13_mvc_3/</guid><description>Session 로그인 할 때 세션에 등록 LoginController.java @PostMapping public String submit(LoginCommand loginCommand, Errors errors, HttpSession session) { new LoginCommandValidator().validate(loginCommand, errors); if (errors.hasErrors()) { return &amp;#34;login/loginForm&amp;#34;; } try { AuthInfo authInfo = authService.authenticate(loginCommand.getEmail(), loginCommand.getPassword()); session.setAttribute(&amp;#34;authInfo&amp;#34;, authInfo); return &amp;#34;login/loginSuccess&amp;#34;; } catch (WrongIdPasswordException e) { errors.reject(&amp;#34;idPasswordNotMatching&amp;#34;); return &amp;#34;login/loginForm&amp;#34;; } } 로그아웃 할때 세션에서 삭제 LogoutController.java @RequestMapping(&amp;#34;/logout&amp;#34;) public String logout(HttpSession session) { session.invalidate(); return &amp;#34;redirect:/main&amp;#34;; } 로그인 상태 여부에 따라 다르게 보여주기 &amp;lt;c:if test=&amp;#34;${ empty authInfo }&amp;#34;&amp;gt; &amp;lt;p&amp;gt;환영합니다.</description></item><item><title>MVC 2 : Messages, Validate command object</title><link>/spring/12_mvc_2/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>/spring/12_mvc_2/</guid><description>Messages label.properties member.register=회원가입 &amp;lt;%@ taglib prefix=&amp;#34;spring&amp;#34; uri=&amp;#34;http://www.springframework.org/tags&amp;#34; %&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;spring:message code=&amp;#34;member.register&amp;#34; /&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; 사이트가 여러 언어를 지원해야할 때 label_ko.properties, label_en.properties와 같이 만든다고 한다 http헤더의 Accept-Launguage를 자동으로 인식한다고 하니까 편할 것 같다 Validate command object Validation RegisterRequestValidator @Override public void validate(Object target, Errors errors) { RegisterRequest regReq = (RegisterRequest) target; if(regReq.getEmail() == null | regReq.getEmail().trim().isEmpty()) { errors.rejectValue(&amp;#34;email&amp;#34;, &amp;#34;bad&amp;#34;); } else { Matcher matcher = pattern.matcher(regReq.getEmail()); if(!</description></item><item><title>MVC 1 : Request Mapping, Command Object, Redirect, Form Tag, Model</title><link>/spring/11_mvc_1/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/11_mvc_1/</guid><description>Request Mapping GetMapping/PostMapping으로 처리할 method를 지정하거나 RequestMapping을 사용할 수 있다. Access request parameter : HttpServletRequest @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2(HttpServletRequest request) { String agreeParam = request.getParameter(&amp;#34;agree&amp;#34;); if (agreeParam == null || !agreeParam.equals(&amp;#34;true&amp;#34;)) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Access request parameter : RequestParam Annotation @PostMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2( @RequestParam(value=&amp;#34;agree&amp;#34;, defaultValue=&amp;#34;false&amp;#34;) Boolean agree) { if (!agree) { return &amp;#34;register/step1&amp;#34;; } return &amp;#34;register/step2&amp;#34;; Redirect @GetMapping(&amp;#34;/register/step2&amp;#34;) public String handleStep2Get() { return &amp;#34;redirect:/register/step1&amp;#34;; Command Object Use request parameter as command object RegisterController.</description></item><item><title>08_connect_DB</title><link>/spring/08_connect_db/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/08_connect_db/</guid><description>DataSource 설정 AppCtx.java @Bean(destroyMethod = &amp;#34;close&amp;#34;) public DataSource dataSource() { DataSource ds = new DataSource(); ds.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); ds.setUrl(&amp;#34;jdbc:mysql://localhost/spring5fs?&amp;#34;+ &amp;#34;enabledTLSProtocols=TLSv1.2&amp;amp;&amp;#34;+ &amp;#34;useSSL=false&amp;amp;&amp;#34;+ &amp;#34;characterEncoding=utf8&amp;#34;); ds.setUsername(&amp;#34;spring5&amp;#34;); ds.setPassword(&amp;#34;spring5&amp;#34;); ds.setInitialSize(2); ds.setMaxActive(10); ds.setTestWhileIdle(true); ds.setMinEvictableIdleTimeMillis(60000 * 3); ds.setTimeBetweenEvictionRunsMillis(10 * 1000); return ds; } Query 실행 JdbcTemplate을 이용한 select jdbcTemplate.query( &amp;#34;select * from MEMBER where EMAIL = ?&amp;#34;, new RowMapper&amp;lt;Member&amp;gt;() { @Override public Member mapRow(ResultSet rs, int rowNum) throws SQLException { Member member = new Member( rs.getString(&amp;#34;EMAIL&amp;#34;), rs.getString(&amp;#34;PASSWORD&amp;#34;), rs.</description></item><item><title>07_AOP</title><link>/spring/07_aop/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/07_aop/</guid><description>AOP (Aspect Oriented Programming) 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법 기본 개념 : 핵심 기능에 공통 기능을 삽입 이를 구현하는 3가지 방법 컴파일 시점에 코드에 공통 기능을 삽입하는 방법 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법 주요 용어 Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지 Joinpoint : Advice를 적용 가능한 지점 Pointcut : Joinpoint의 부분 집합으로서 실제 Advice가 적용되는 Joinpoint를 나타낸다 Weaving : Advice를 핵심 로직 코드에 적용하는 것 Aspect : 여러 객체에 공통으로 적용되는 기능 Spring AOP 구현 MainAspect.</description></item><item><title>03_DI</title><link>/spring/03_di/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/03_di/</guid><description>의존 주입 (DI : Dependency Injection)을 하는 방법 Assembler라는 별도의 클래스 생성
public class Assembler { private MemberDao memberDao; private MemberRegisterService regSvc; public Assembler() { memberDao = new MemberDao(); regSvc = new MemberRegisterService(memberDao); } public MemberDao getMemberDao() { return memberDao; } public MemberRegisterService getMemberRegisterService() { return regSvc; } } Spring에서 지원하는 DI 사용
@Configuration public class AppCtx { @Bean public MemberDao memberDao() { return new MemberDao(); } @Bean public MemberRegisterService memberRegSvc() { return new MemberRegisterService(memberDao()); } } DI방식 Constructor 방식 @Bean public MemberListPrinter listPrinter() { return new MemberListPrinter(memberDao(), memberPrinter()); } Setter method 방식 @Bean public MemberInfoPrinter infoPrinter() { MemberInfoPrinter infoPrinter = new MemberInfoPrinter(); infoPrinter.</description></item><item><title>04_DI_automatic</title><link>/spring/04_di_automatic/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/04_di_automatic/</guid><description>Maven project 만들기 복습 pom.xml을 만든다. 프로젝트 구조를 만든다 구조는 프로젝트폴더/src/main/java/패키지/클래스 이다. eclipse에서 import maven project로 Maven dependencies를 인식시킨다 @Autowired를 이용한 자동 객체 주입 방법1 : Field에 적용
public class MemberListPrinter { @Autowired private MemberDao memberDao; @Autowired private MemberPrinter printer; public MemberListPrinter() {} public void printAll() { Collection&amp;lt;Member&amp;gt; members = memberDao.selectAll(); members.forEach(m -&amp;gt; printer.print(m)); } } 방법2 : Method에 적용
public class MemberListPrinter { private MemberDao memberDao; private MemberPrinter printer; public MemberListPrinter() {} @Autowired public void setMemberDao(MemberDao memberDao) { this.</description></item><item><title>05_bean_lifecycle_scope</title><link>/spring/06_bean_lifecycle_scope/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/06_bean_lifecycle_scope/</guid><description>빈 객체의 lifecycle InitializingBean, DisposableBean 상속받기 public class Client implements InitializingBean, DisposableBean { @Override public void afterPropertiesSet() throws Exception {...} @Override public void destroy() throws Exception {...} } 두 인터페이스 구현을 통해 빈 객체의 생성과 소멸에 원하는 일을 수행할 수 있다 Custom Method @Bean(initMethod = &amp;#34;connect&amp;#34;, destroyMethod=&amp;#34;close&amp;#34;) public class Client2{ public void connect() {...} public void close() {...} } 인터페이스 구현하기 싫거나 외부에서 제공받은 클래스를 사용할 때 위와 같이 구현한다 빈 객체의 Scope 기본적으로 빈 객체는 Singleton scope를 갖는다 하지만 임의로 Prototype scope를 갖게 할 수 있다.</description></item><item><title>05_Component_scan</title><link>/spring/05_component_scan/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/05_component_scan/</guid><description>@Component scan Component Scan은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다
AppCtx.java
@Configuration @ComponentScan(basePackages = {&amp;#34;spring&amp;#34;}) public class AppCtx {...} MemberInfoPrinter.java @Component(&amp;#34;infoPrinter&amp;#34;) public class MemberInfoPrinter {...} 효과 // before MemberInfoPrinter infoPrinter = ctx.getBean(&amp;#34;infoPrinter&amp;#34;, MemberInfoPrinter.class); // after MemberInfoPrinter infoPrinter = ctx.getBean(MemberInfoPrinter.class);</description></item><item><title>09_spring_MVC</title><link>/spring/09_spring_mvc/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>/spring/09_spring_mvc/</guid><description>Spring MVC 시작하기 프로젝트 생성 앞에서 만들었던 자바 애플리케이션과는 좀 다른점이 있었다 jar이 아닌 war을 사용하는 등 여러가지 많았는데 일일이 적지는 않을 것이다 Controller @Controller public class HelloController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello(Model model, @RequestParam(value=&amp;#34;name&amp;#34;, required=false) String name) { model.addAttribute(&amp;#34;greeting&amp;#34;, &amp;#34;안녕하세요&amp;#34; + name); return &amp;#34;hello&amp;#34;; } } JSP &amp;lt;%@ page contentType=&amp;#34;text/html; charset=utf-8&amp;#34; %&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 인사말 : ${greeting} &amp;lt;/body&amp;gt; &amp;lt;/html URL접속해도 해당 jsp파일이 나오지 않는 문제 vscode에서 community server connector라는 extension을 통해 tomcat을 띄워서 할려고 한다 특정 jsp를 감지했는지, serving하는지에 대한 로그가 없어 되는건지 알 수가 없다 web.</description></item></channel></rss>
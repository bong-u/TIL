<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on bong-u/til</title><link>https://bong-u.github.io/til/tags/c++/</link><description>Recent content in C++ on bong-u/til</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Nov 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://bong-u.github.io/til/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>백준 - 20125 : 쿠키의 신체 측정 (S4)</title><link>https://bong-u.github.io/til/algorithm/boj_20125/</link><pubDate>Fri, 15 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_20125/</guid><description>1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3 4char board[1000][1000] = { NULL }; 5int n; 6 7tuple&amp;lt;int, int, int&amp;gt; getlength(int sx, int sy, int dx, int dy) { 8 int cnt = 0; 9 int x = sx; 10 int y = sy; 11 12 while (true) { 13 x += dx; 14 y += dy; 15 if (y &amp;lt; 0 || y &amp;gt;= n || x &amp;lt; 0 || x &amp;gt;= n || board[x][y] !</description></item><item><title>백준 - 8979 : 올림픽 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_8979/</link><pubDate>Fri, 15 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_8979/</guid><description>1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3 4struct medal { 5 int number; 6 int gold; 7 int silver; 8 int bronze; 9}; 10bool cmp(medal a, medal b) { 11 if (a.gold != b.gold) return a.gold &amp;gt; b.gold; 12 if (a.silver != b.silver) return a.silver &amp;gt; b.silver; 13 return a.bronze &amp;gt; b.bronze; 14 15} 16int main() { 17 cin.tie(0)-&amp;gt;sync_with_stdio(false); 18 int n = 0, target = 0, rank = 0; 19 cin &amp;gt;&amp;gt; n; 20 cin &amp;gt;&amp;gt; target; 21 22 medal* arr = new medal[n]; 23 24 for (int i = 0; i &amp;lt; n; i++) { 25 cin &amp;gt;&amp;gt; arr[i].</description></item><item><title>C++ 개념 정리</title><link>https://bong-u.github.io/til/c_cpp/cpp_concept/</link><pubDate>Thu, 10 Oct 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/c_cpp/cpp_concept/</guid><description>본 내용은 2023 MISRA-CPP 가이드라인을 공부하면서 개념을 정리한 것이다.
참조(Reference)와 포인터(Pointer) 포인터(Pointer) 메모리 주소를 저장하는 변수
1// 변수 선언 2int a = 10; 3int* b = &amp;amp;a; // a의 주소를 저장 4 5// 매개변수로 전달 6void add(int* a, int* b) { 7 *a + *b; 8} 9 10add(&amp;amp;a, &amp;amp;b); 참조(Reference) 변수에 별칭을 부여하는 것
이름으로 대상을 가리킨다.
제약사항
참조는 선언과 동시에 초기화해야 한다.</description></item><item><title>객체지향설계</title><link>https://bong-u.github.io/til/school/ood/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/ood/</guid><description>Dynamic dispatch and Multiple inheritance Polymorphism Function overloading using compile time types of arguments Function overriding using runtime types of receiver objects virtual function for dynamic dispatch dynamic dispatch를 사용하기 위한 조건
함수가 virtual keyword로 정의되어 있어야 한다.
receiver object가 포인터(*), 참조(&amp;amp;)를 통해 refer되어야 한다
1// from parent class : Employee 2virtual std::string GetInfo() { 3 return &amp;#34;Employee: &amp;#34; + name_ ; 4} 5// from child class : Developer 6std::string GetInfo() { 7 return &amp;#34;Developer: &amp;#34; + name_; 8} override keyword override 키워드를 사용하는 이유 직관적인 코드</description></item></channel></rss>